from __future__ import annotations

from dataclasses import dataclass
import ast
import json
import random
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Callable, Dict, Iterable, Mapping, Optional, Sequence

"""
PDL policy evaluator for TraceMind DSL.

Interprets compiled policy artifacts (JSON generated by `tm dsl compile`)
without requiring bespoke Python strategy code.  Policies are executed
against an input context (`values`, optional epsilon/random source) and
produce an `emit` payload.
"""

PolicyData = Mapping[str, Any]
RandomFunc = Callable[[], float]


class PolicyEvaluationError(RuntimeError):
    """Raised when a policy definition cannot be evaluated."""


@dataclass
class EvaluationInput:
    values: Mapping[str, Any]
    epsilon: Optional[float] = None
    random_func: Optional[RandomFunc] = None


def load_policy(path: Path) -> PolicyData:
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise PolicyEvaluationError(f"Invalid policy JSON at {path}: {exc}") from exc
    except OSError as exc:
        raise PolicyEvaluationError(f"Unable to read policy {path}: {exc}") from exc
    return data


def evaluate_policy(policy_data: PolicyData, inputs: EvaluationInput) -> Dict[str, Any]:
    policy = policy_data.get("policy")
    if not isinstance(policy, Mapping):
        raise PolicyEvaluationError("policy root object missing")
    params = policy.get("params")
    if not isinstance(params, Mapping):
        raise PolicyEvaluationError("policy params missing or invalid")

    evaluator = _PolicyEvaluator(params, inputs)
    evaluator.execute()
    return evaluator.render_emit()


class _PolicyEvaluator:
    def __init__(self, params: Mapping[str, Any], inputs: EvaluationInput) -> None:
        self.params = params
        self.inputs = inputs
        self.state: Dict[str, Any] = {}
        self.random = inputs.random_func or random.random
        self.values = inputs.values
        self.epsilon = float(inputs.epsilon) if inputs.epsilon is not None else _coerce_float(params.get("epsilon"))
        self.arms = _wrap_namespace(params.get("arms", {}))

        self._globals = {
            "__builtins__": {},
            "coalesce": _fn_coalesce,
            "first_numeric": _fn_first_numeric,
            "min": min,
            "max": max,
            "abs": abs,
            "float": float,
            "int": int,
            "len": len,
            "round": round,
        }

    def execute(self) -> None:
        evaluate_block = self.params.get("evaluate", [])
        if not isinstance(evaluate_block, Sequence):
            return
        for stmt in evaluate_block:
            if isinstance(stmt, Mapping):
                self._exec_statement(stmt)

    def render_emit(self) -> Dict[str, Any]:
        emit = self.params.get("emit", {})
        if not isinstance(emit, Mapping):
            raise PolicyEvaluationError("emit payload missing or invalid")
        return {key: self._eval_value(value) for key, value in emit.items()}

    # ------------------------------------------------------------------ statements
    def _exec_statement(self, stmt: Mapping[str, Any]) -> None:
        stmt_type = stmt.get("type")
        if stmt_type == "assignment":
            self._exec_assignment(stmt)
        elif stmt_type == "if":
            self._exec_if(stmt)
        elif stmt_type == "choose":
            self._exec_choose(stmt)
        else:
            raise PolicyEvaluationError(f"Unsupported statement type {stmt_type!r}")

    def _exec_assignment(self, stmt: Mapping[str, Any]) -> None:
        target = stmt.get("target")
        expression = stmt.get("expression")
        if not isinstance(target, str) or not isinstance(expression, str):
            raise PolicyEvaluationError("assignment requires string target/expression")
        value = self._eval_expr(expression)
        self.state[target] = value

    def _exec_if(self, stmt: Mapping[str, Any]) -> None:
        condition = stmt.get("condition")
        if not isinstance(condition, str):
            raise PolicyEvaluationError("if condition must be string")
        block = stmt.get("then") if self._truthy(self._eval_expr(condition)) else stmt.get("else")
        if isinstance(block, Sequence):
            for child in block:
                if isinstance(child, Mapping):
                    self._exec_statement(child)

    def _exec_choose(self, stmt: Mapping[str, Any]) -> None:
        options = stmt.get("options")
        if not isinstance(options, Sequence) or not options:
            raise PolicyEvaluationError("choose requires non-empty options")

        default_target = self._infer_choose_target(options)
        fallback: Optional[Mapping[str, Any]] = None
        for option in options:
            if not isinstance(option, Mapping):
                continue
            probability = option.get("probability")
            if probability is not None:
                prob_value = self._eval_probability(probability)
                if prob_value > 0 and self.random() < prob_value:
                    self._apply_choose_option(option, default_target)
                    return
            if fallback is None:
                fallback = option
        if fallback is not None:
            self._apply_choose_option(fallback, default_target)

    def _apply_choose_option(self, option: Mapping[str, Any], default_target: Optional[str]) -> None:
        expression = option.get("expression")
        if not isinstance(expression, str):
            raise PolicyEvaluationError("choose option missing expression")
        if "=" in expression or ":=" in expression:
            target, value_expr = _split_assignment(expression)
            value = self._eval_expr(value_expr)
            self.state[target] = value
        elif default_target:
            self.state[default_target] = self._eval_expr(expression)
        else:
            self._eval_expr(expression)

    def _infer_choose_target(self, options: Sequence[Mapping[str, Any]]) -> Optional[str]:
        for option in options:
            if not isinstance(option, Mapping):
                continue
            expression = option.get("expression")
            if not isinstance(expression, str):
                continue
            if "=" in expression or ":=" in expression:
                target, _ = _split_assignment(expression)
                return target
        return None

    # ------------------------------------------------------------------ evaluation helpers
    def _eval_expr(self, expression: str) -> Any:
        return self._eval_value(expression)

    def _eval_probability(self, probability: Any) -> float:
        value = self._eval_value(probability)
        try:
            prob = float(value)
        except (TypeError, ValueError):
            prob = 0.0
        return max(0.0, min(1.0, prob))

    def _eval_value(self, value: Any) -> Any:
        if isinstance(value, str):
            expr = value.strip()
            if expr in self.state:
                return self.state[expr]
            if expr == "epsilon":
                return self.epsilon if self.epsilon is not None else 0.0
            try:
                return ast.literal_eval(expr)
            except Exception:
                env = {
                    **self.state,
                    "values": self.values,
                    "arms": SimpleNamespace(active=_select_active_arm(self.arms)),
                    "epsilon": self.epsilon if self.epsilon is not None else 0.0,
                    "random": self._random_choice,
                }
                env.update(self._globals)
                try:
                    return eval(expr, self._globals, env)  # noqa: S307 (controlled environment)
                except Exception as exc:
                    raise PolicyEvaluationError(f"Failed to evaluate expression '{expr}': {exc}") from exc
        elif isinstance(value, Mapping):
            return {k: self._eval_value(v) for k, v in value.items()}
        elif isinstance(value, Sequence) and not isinstance(value, (str, bytes)):
            return [self._eval_value(v) for v in value]
        return value

    def _random_choice(self, iterable: Iterable[Any]) -> Any:
        seq = list(iterable)
        if not seq:
            return None
        idx = int(self.random() * len(seq))
        return seq[idx]

    def _truthy(self, value: Any) -> bool:
        return bool(value)


# --------------------------------------------------------------------------- helpers


def _coerce_float(value: Any) -> Optional[float]:
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        try:
            return float(value)
        except ValueError:
            return None
    return None


def _split_assignment(expr: str) -> tuple[str, str]:
    if ":=" in expr:
        target, value = expr.split(":=", 1)
    elif "=" in expr:
        target, value = expr.split("=", 1)
    else:
        raise PolicyEvaluationError(f"choose expression must contain '=' or ':=': {expr}")
    return target.strip(), value.strip()


def _wrap_namespace(obj: Any) -> Any:
    if isinstance(obj, Mapping):
        return {k: _wrap_namespace(v) for k, v in obj.items()}
    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):
        return [_wrap_namespace(v) for v in obj]
    return _coerce_literal(obj)


def _select_active_arm(arms: Any) -> Any:
    if isinstance(arms, Mapping):
        if "default" in arms:
            return _namespace(arms["default"])
        first_value: Any = next(iter(arms.values()), {})
        return _namespace(first_value)
    return _namespace({})


def _namespace(obj: Any) -> Any:
    if isinstance(obj, Mapping):
        return SimpleNamespace(**{k: _namespace(v) for k, v in obj.items()})
    if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes)):
        return [_namespace(v) for v in obj]
    return _coerce_literal(obj)


def _coerce_literal(value: Any) -> Any:
    if isinstance(value, str):
        try:
            literal = ast.literal_eval(value)
            return literal
        except Exception:
            return value
    return value


def _fn_coalesce(*values: Any) -> Any:
    for value in values:
        if value not in (None, "", [], {}):
            return value
    return None


def _fn_first_numeric(values: Any) -> Optional[float]:
    if isinstance(values, Mapping):
        for value in values.values():
            number = _coerce_float(value)
            if number is not None:
                return number
    if isinstance(values, Sequence) and not isinstance(values, (str, bytes)):
        for value in values:
            number = _coerce_float(value)
            if number is not None:
                return number
    return None


__all__ = ["PolicyEvaluationError", "EvaluationInput", "load_policy", "evaluate_policy"]
