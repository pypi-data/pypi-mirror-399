---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/metaclass_forward_ref_renamed/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
yaml_module_loader = _cribo.types.SimpleNamespace(__name__='yaml_module.loader')
yaml_module = _cribo.types.SimpleNamespace(__name__='yaml_module', __initializing__=False, __initialized__=False, __path__=[])
yaml_module.loader = yaml_module_loader
class Loader:

    @classmethod
    def add_constructor(cls, tag, constructor):
        print(f"Loader: Registering {tag}")
Loader.__module__ = 'yaml_module.loader'
class Dumper:

    @classmethod
    def add_representer(cls, data_type, representer):
        print(f"Dumper: Registering {data_type}")
Dumper.__module__ = 'yaml_module.loader'
yaml_module_loader.Loader = Loader
yaml_module_loader.Dumper = Dumper
yaml_module_other = _cribo.types.SimpleNamespace(__name__='yaml_module.other', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_1fd8cb_yaml_module_other(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True

    class YAMLObjectMetaclass(type):
        """First version of the metaclass"""
        pass
    YAMLObjectMetaclass.__module__ = 'yaml_module.other'
    self.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """First version of YAMLObject"""
        source = "other"
    YAMLObject.__module__ = 'yaml_module.other'
    self.YAMLObject = YAMLObject
    self.__initialized__ = True
    self.__initializing__ = False
    return self
yaml_module_other.__init__ = _cribo_init___cribo_1fd8cb_yaml_module_other
yaml_module.other = yaml_module_other
def _cribo_init___cribo_1309dd_yaml_module(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    self.Dumper = yaml_module_loader.Dumper
    self.Loader = yaml_module_loader.Loader
    global yaml_module_other
    """\nModule that mimics PyYAML's pattern where:\n1. It uses wildcard imports\n2. It defines YAMLObjectMetaclass and YAMLObject (causing collisions with other.py)\n3. YAMLObject references symbols from wildcard imports in its class body\n4. When bundled, the renamed class still references the original metaclass name\n"""
    yaml_module_other = _cribo_init___cribo_1fd8cb_yaml_module_other(yaml_module_other)
    OtherYAMLObject = yaml_module_other.YAMLObject
    self.OtherYAMLObject = OtherYAMLObject
    self.OtherYAMLObject = OtherYAMLObject
    yaml_module_other = _cribo_init___cribo_1fd8cb_yaml_module_other(yaml_module_other)
    OtherYAMLObjectMetaclass = yaml_module_other.YAMLObjectMetaclass
    self.OtherYAMLObjectMetaclass = OtherYAMLObjectMetaclass
    self.OtherYAMLObjectMetaclass = OtherYAMLObjectMetaclass

    class YAMLObjectMetaclass(type):
        """The metaclass for YAMLObject"""

        def __init__(cls, name, bases, kwds):
            super(YAMLObjectMetaclass, cls).__init__(name, bases, kwds)
            if "yaml_tag" in kwds and kwds["yaml_tag"] is not None:
                cls.yaml_loader.add_constructor(cls.yaml_tag, cls.from_yaml)
                cls.yaml_dumper.add_representer(cls, cls.to_yaml)
    YAMLObjectMetaclass.__module__ = 'yaml_module'
    self.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """\n    YAMLObject that references wildcard-imported symbols in class body.\n    When bundled and renamed, this will become something like:\n    class YAMLObject_1(metaclass=YAMLObjectMetaclass):\n    But YAMLObjectMetaclass won't exist - only YAMLObjectMetaclass_1 will.\n    """
        __slots__ = ()
        yaml_loader = Loader
        yaml_dumper = Dumper
        yaml_tag = None

        @classmethod
        def from_yaml(cls, loader, node):
            return f"Loading {cls.__name__}"

        @classmethod
        def to_yaml(cls, dumper, data):
            return f"Dumping {cls.__name__}"
    YAMLObject.__module__ = 'yaml_module'
    self.YAMLObject = YAMLObject
    self.loader = yaml_module_loader
    self.__initialized__ = True
    self.__initializing__ = False
    return self
yaml_module.__init__ = _cribo_init___cribo_1309dd_yaml_module
"""\nTest case that reproduces the PyYAML metaclass renaming bug.\n\nExpected behavior: The bundled code should work correctly.\nActual behavior: NameError because renamed class references original metaclass name.\n"""
__cribo_init_result = _cribo_init___cribo_1309dd_yaml_module(yaml_module)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(yaml_module, attr, getattr(__cribo_init_result, attr))
print("Module loaded successfully")
print(f"OtherYAMLObject source: {yaml_module.OtherYAMLObject.source}")
print(f"YAMLObject name: {yaml_module.YAMLObject.__name__}")
class MyYAML(yaml_module.YAMLObject):
    yaml_tag = "!my"
print("Created subclass successfully")
print(f"Loader: {yaml_module.Loader.__name__}")
print(f"Dumper: {yaml_module.Dumper.__name__}")
print("All tests passed!")
other = yaml_module.other
loader = yaml_module.loader
