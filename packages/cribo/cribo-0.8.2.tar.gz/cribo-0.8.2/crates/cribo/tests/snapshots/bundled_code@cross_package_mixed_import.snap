---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/cross_package_mixed_import/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
core_utils_helpers = _cribo.types.SimpleNamespace(__name__='core.utils.helpers', __doc__='Helper utilities for the core package.')
core = _cribo.types.SimpleNamespace(__name__='core', __initializing__=False, __initialized__=False, __path__=[])
core_utils = _cribo.types.SimpleNamespace(__name__='core.utils', __initializing__=False, __initialized__=False, __path__=[])
core.utils = core_utils
core_utils.helpers = core_utils_helpers
"""Helper utilities for the core package."""
def validate(value: str) -> bool:
    """Validate a string value.\n\n    This function is imported by core.database.connection using\n    a relative import (..utils.helpers), demonstrating relative\n    imports within the same package hierarchy.\n    """
    return bool(value and not value.startswith("_"))
core_utils_helpers.validate = validate
core_version = _cribo.types.SimpleNamespace(__name__='core.version', __doc__='Version module separate from __init__ to avoid circular imports.')
core.version = core_version
"""Version module separate from __init__ to avoid circular imports."""
CORE_MODEL_VERSION = "1.0.0"
core_version.CORE_MODEL_VERSION = CORE_MODEL_VERSION
core_utils_config = _cribo.types.SimpleNamespace(__name__='core.utils.config', __doc__='Configuration utilities for the core package.')
core_utils.config = core_utils_config
"""Configuration utilities for the core package."""
_module_config = None
def set_config_reference(config):
    """Set the configuration reference - called by parent package."""
    global _module_config
    _module_config = config
def get_config():
    """Get the current configuration."""
    if _module_config is None:
        return {"debug": False}
    return _module_config.copy()
def is_debug():
    """Check if debug mode is enabled."""
    if _module_config is None:
        return False
    return _module_config.get("debug", False)
core_utils_config.get_config = get_config
core_utils_config.is_debug = is_debug
core_utils_config.set_config_reference = set_config_reference
_cribo_core__initialized = None
_cribo_core__config = None
def _cribo_init___cribo_f00e4b_core(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    global _cribo_core__config, _cribo_core__initialized
    """Core package with initialization logic and cross-package imports."""
    _initialized = False
    _cribo_core__initialized = _initialized
    self._initialized = _cribo_core__initialized
    _config = {"debug": False}
    _cribo_core__config = _config
    self._config = _cribo_core__config
    CORE_MODEL_VERSION = core_version.CORE_MODEL_VERSION
    core.CORE_MODEL_VERSION = CORE_MODEL_VERSION
    validate = core_utils_helpers.validate
    core.validate = validate
    get_config = core_utils_config.get_config
    core.get_config = get_config
    set_config_reference = core_utils_config.set_config_reference
    core.set_config_reference = set_config_reference
    set_config_reference(self._config)

    def initialize_core(debug=False):
        """Initialize the core package with configuration."""
        global _cribo_core__initialized, _cribo_core__config
        _cribo_core__initialized = True
        core._initialized = _cribo_core__initialized
        _cribo_core__config["debug"] = debug
        if debug:
            print(f"Core initialized with version: {CORE_MODEL_VERSION}")
        return _cribo_core__initialized
    self.initialize_core = initialize_core

    def is_initialized():
        """Check if core is initialized."""
        return self._initialized
    self.is_initialized = is_initialized
    self.version = core_version
    self.utils = core_utils
    self.validate = validate
    self.get_config = get_config
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core.__init__ = _cribo_init___cribo_f00e4b_core
models_base = _cribo.types.SimpleNamespace(__name__='models.base', __doc__='Base model module.')
models = _cribo.types.SimpleNamespace(__name__='models', __initializing__=False, __initialized__=False, __path__=[])
models.base = models_base
"""Base model module."""
class BaseModel:
    """Base model class."""

    def __init__(self, name: str):
        if not name or name.startswith("_"):
            raise ValueError(f"Invalid model name: {name}")
        self.name = name
        self.version = "1.0.0"

    def get_info(self):
        """Get model information."""
        return {"name": self.name, "type": "base", "model_version": self.version}
BaseModel.__module__ = 'models.base'
models_base.BaseModel = BaseModel
models_user = _cribo.types.SimpleNamespace(__name__='models.user', __doc__='User model providing cross-package functionality.')
models.user = models_user
"""User model providing cross-package functionality."""
def process_user(name: str) -> str:
    """Process a user-related string.\n\n    This function is imported by core.database.connection,\n    demonstrating a cross-package absolute import.\n    """
    return f"user_{name}_processed"
models_user.process_user = process_user
_cribo_models__base_model = None
def _cribo_init___cribo_563ea2_models(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    global _cribo_models__base_model
    """Models package with conditional imports and circular dependency handling."""
    sys = _cribo.sys
    self.sys = sys
    self.sys = sys
    _VERSION = "1.0.0"
    self._VERSION = _VERSION

    def get_model_version():
        """Get the models package version."""
        return self._VERSION
    self.get_model_version = get_model_version
    if _cribo.sys.version_info >= (3, 9):
        TypeAlias = _cribo.typing.TypeAlias
        models.TypeAlias = TypeAlias
        ModelID: _cribo.typing.TypeAlias = str
    else:
        ModelID = str
        models.ModelID = self.ModelID
    _base_model = None
    _cribo_models__base_model = _base_model
    self._base_model = _cribo_models__base_model

    def get_base_model():
        """Lazy import of BaseModel to avoid circular imports."""
        global _cribo_models__base_model
        if _cribo_models__base_model is None:
            BaseModel = models_base.BaseModel
            models.BaseModel = BaseModel
            _cribo_models__base_model = BaseModel
        return _cribo_models__base_model
    self.get_base_model = get_base_model
    process_user = models_user.process_user
    models.process_user = process_user
    DEFAULT_MODEL_CONFIG = {"version": self._VERSION, "features": ["user_processing", "lazy_loading"]}
    self.DEFAULT_MODEL_CONFIG = DEFAULT_MODEL_CONFIG
    try:
        from models.advanced import AdvancedModel
        models.AdvancedModel = AdvancedModel
        HAS_ADVANCED = True
        models.HAS_ADVANCED = HAS_ADVANCED
        DEFAULT_MODEL_CONFIG["features"].append("advanced_model")
    except ImportError:
        HAS_ADVANCED = False
        models.HAS_ADVANCED = HAS_ADVANCED
        AdvancedModel = None
        models.AdvancedModel = AdvancedModel
    __all__ = ["get_model_version", "process_user", "get_base_model", "ModelID", "DEFAULT_MODEL_CONFIG", "HAS_ADVANCED"]
    if self.HAS_ADVANCED:
        __all__.append("AdvancedModel")
    self.user = models_user
    self.base = models_base
    self.__initialized__ = True
    self.__initializing__ = False
    return self
models.__init__ = _cribo_init___cribo_563ea2_models
core_database_connection = _cribo.types.SimpleNamespace(__name__='core.database.connection', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_1f0c3d_core_database_connection(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    """Database connection module demonstrating mixed import patterns.\n\nThis module combines:\n1. Absolute import from a different package (models.user)\n2. Relative import from within the same package (..utils.helpers)\n3. Import from parent package's version module (not __init__.py)\n4. No imports from parent package's __init__.py to avoid circular dependencies\n"""
    process_user = models_user.process_user
    core_database_connection.process_user = process_user
    helper_validate = validate
    core_database_connection.helper_validate = helper_validate
    CORE_MODEL_VERSION = core_version.CORE_MODEL_VERSION
    core_database_connection.CORE_MODEL_VERSION = CORE_MODEL_VERSION
    __cribo_init_result = _cribo_init___cribo_563ea2_models(models)
    for attr in dir(__cribo_init_result):
        if not attr.startswith('_'):
            setattr(models, attr, getattr(__cribo_init_result, attr))
    DEFAULT_MODEL_CONFIG = models.DEFAULT_MODEL_CONFIG
    self.DEFAULT_MODEL_CONFIG = DEFAULT_MODEL_CONFIG
    self.DEFAULT_MODEL_CONFIG = DEFAULT_MODEL_CONFIG
    get_base_model = models.get_base_model
    self.get_base_model = get_base_model
    self.get_base_model = get_base_model
    _connection_types = ["standard", "pooled", "async"]
    self._connection_types = _connection_types
    CONNECTION_METADATA = {"supported_types": _connection_types, "validator": helper_validate.__name__, "processor": process_user.__name__, "core_version": CORE_MODEL_VERSION, "model_config": DEFAULT_MODEL_CONFIG}
    self.CONNECTION_METADATA = CONNECTION_METADATA

    class Connection:
        """Connection class using mixed imports."""

        def __init__(self, database_name: str):
            if not helper_validate(database_name) or any(char in database_name for char in ["/", "\\", ":"]):
                raise ValueError(f"Invalid database name: {database_name}")
            self.name = process_user(database_name)
            self.metadata = CONNECTION_METADATA.copy()
            if database_name.startswith("model_"):
                BaseModel = get_base_model()
                self.model = BaseModel(database_name)
                self.metadata["model_info"] = self.model.get_info()

        def __str__(self):
            return f"Connection to {self.name}"
    Connection.__module__ = 'core.database.connection'
    self.Connection = Connection

    def connect(database_name: str) -> Connection:
        """Create a new database connection."""
        return Connection(database_name)
    self.connect = connect

    def get_connection_info() -> dict:
        """Get general connection information."""
        is_debug = core_utils_config.is_debug
        core_database_connection.is_debug = is_debug
        info = {"metadata": CONNECTION_METADATA, "debug_mode": is_debug(), "available_validators": ["validate_db_name", helper_validate.__name__]}
        if is_debug():
            get_full_config = get_config
            core_database_connection.get_full_config = get_full_config
            info["config"] = get_full_config()
        return info
    self.get_connection_info = get_connection_info
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core_database_connection.__init__ = _cribo_init___cribo_1f0c3d_core_database_connection
core_database = _cribo.types.SimpleNamespace(__name__='core.database', __initializing__=False, __initialized__=False, __path__=[])
core.database = core_database
core_database.connection = core_database_connection
def _cribo_init___cribo_782908_core_database(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    global core_database_connection
    """Database subpackage with import-time initialization and re-exports."""
    validate = core_utils_helpers.validate
    core_database.validate = validate
    _registered_types = []
    self._registered_types = _registered_types

    def _register_type(type_name):
        """Internal function to register database types."""
        _registered_types.append(type_name)
        return type_name
    self._register_type = _register_type
    _register_type("connection")
    _register_type("cursor")

    def validate_db_name(name: str) -> bool:
        """Validate database name with additional rules."""
        if not validate(name):
            return False
        return not any(char in name for char in ["/", "\\", ":"])
    self.validate_db_name = validate_db_name
    core_database_connection = _cribo_init___cribo_1f0c3d_core_database_connection(core_database_connection)
    connect = core_database_connection.connect
    self.connect = connect
    self.connect = connect
    get_connection_info = core_database_connection.get_connection_info
    self.get_connection_info = get_connection_info
    self.get_connection_info = get_connection_info

    def safe_connect(database_name: str) -> str:
        """Connect only if core is initialized."""
        is_initialized = _cribo_init___cribo_f00e4b_core(self.__dict__['core']).is_initialized
        if not is_initialized():
            raise RuntimeError("Core package must be initialized before connecting")
        return connect(database_name)
    self.safe_connect = safe_connect
    self.__initialized__ = True
    self.__initializing__ = False
    return self
core_database.__init__ = _cribo_init___cribo_782908_core_database
"""Test fixture demonstrating cross-package mixed import patterns.\n\nThis tests the specific pattern where a module uses both:\n1. Deep absolute imports crossing package boundaries (e.g., from models.user)\n2. Relative imports within its package (e.g., from ..utils.helpers)\n3. Import order dependencies with __init__.py files\n"""
__cribo_init_result = _cribo_init___cribo_f00e4b_core(core)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core, attr, getattr(__cribo_init_result, attr))
initialize_core = core.initialize_core
__cribo_init_result = _cribo_init___cribo_f00e4b_core(core)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core, attr, getattr(__cribo_init_result, attr))
__cribo_init_result = _cribo_init___cribo_782908_core_database(core_database)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core.database, attr, getattr(__cribo_init_result, attr))
db_connect = core.database.connect
__cribo_init_result = _cribo_init___cribo_f00e4b_core(core)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core, attr, getattr(__cribo_init_result, attr))
__cribo_init_result = _cribo_init___cribo_782908_core_database(core_database)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core.database, attr, getattr(__cribo_init_result, attr))
core_database_connection = _cribo_init___cribo_1f0c3d_core_database_connection(core_database_connection)
connect = core.database.connection.connect
get_connection_info = core.database.connection.get_connection_info
CONNECTION_METADATA = core.database.connection.CONNECTION_METADATA
__cribo_init_result = _cribo_init___cribo_563ea2_models(models)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(models, attr, getattr(__cribo_init_result, attr))
get_model_version = models.get_model_version
DEFAULT_MODEL_CONFIG = models.DEFAULT_MODEL_CONFIG
HAS_ADVANCED = models.HAS_ADVANCED
__cribo_init_result = _cribo_init___cribo_f00e4b_core(core)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(core, attr, getattr(__cribo_init_result, attr))
def demonstrate_import_patterns():
    """Demonstrate various import pattern behaviors."""
    print("=== Import Pattern Demonstration ===")
    print(f"\n1. Import-time values:")
    print(f"   - Model version from models package: {get_model_version()}")
    print(f"   - Core model version: {CONNECTION_METADATA['core_version']}")
    print(f"   - Model config features: {DEFAULT_MODEL_CONFIG['features']}")
    print(f"   - Has advanced model: {HAS_ADVANCED}")
    print(f"\n2. Pre-initialization state:")
    print(f"   - Config before init: {get_config()}")
    initialize_core(debug=True)
    print(f"\n3. Post-initialization state:")
    print(f"   - Config after init: {get_config()}")
    print(f"\n4. Testing connections:")
    conn1 = connect("test_db")
    print(f"   - Direct import: {conn1}")
    conn2 = db_connect("prod_db")
    print(f"   - Package-level import: {conn2}")
    conn3 = connect("model_user_db")
    print(f"   - With lazy import: {conn3}")
    info = get_connection_info()
    print(f"\n5. Connection info shows all imports:")
    print(f"   - Debug mode: {info['debug_mode']}")
    print(f"   - Available validators: {info['available_validators']}")
    print(f"   - Metadata processor: {info['metadata']['processor']}")
    print(f"   - Config included: {'config' in info}")
    return info
def main():
    """Main entry point."""
    results = demonstrate_import_patterns()
    print(f"\n6. Package-level re-exports:")
    print(f"   - validate('test'): {validate('test')}")
    print(f"   - validate('_hidden'): {validate('_hidden')}")
    return results
if __name__ == "__main__":
    result = main()
    print(f"\n=== Final Result ===")
    print(f"Successfully demonstrated cross-package mixed import patterns")
user = models.user
base = models.base
