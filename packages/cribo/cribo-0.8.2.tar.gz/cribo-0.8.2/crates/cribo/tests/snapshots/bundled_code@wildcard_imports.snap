---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/wildcard_imports/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
explicit_all = _cribo.types.SimpleNamespace(__name__='explicit_all', __doc__='Module with no side-effects and explicit __all__.')
"""Module with no side-effects and explicit __all__."""
def safe_function():
    """A function that will be exported via __all__."""
    return "safe_function_result"
class SafeClass:
    """A class that will be exported via __all__."""

    def method(self):
        return "SafeClass.method_result"
SafeClass.__module__ = 'explicit_all'
SAFE_CONSTANT = "SAFE_VALUE"
explicit_all.safe_function = safe_function
explicit_all.SafeClass = SafeClass
explicit_all.SAFE_CONSTANT = SAFE_CONSTANT
with_side_effects = _cribo.types.SimpleNamespace(__name__='with_side_effects', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_9a9871_with_side_effects(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    """Module with side-effects and no explicit __all__."""
    print("Loading with_side_effects module")
    _module_state = []
    self._module_state = _module_state
    _module_state.append("initialized")

    def effect_function():
        """Function from module with side-effects."""
        return "effect_function_result"
    self.effect_function = effect_function

    class EffectClass:
        """Class from module with side-effects."""
        instances = []

        def __init__(self):
            self.instances.append(self)

        def method(self):
            return "EffectClass.method_result"
    EffectClass.__module__ = 'with_side_effects'
    self.EffectClass = EffectClass
    EFFECT_CONSTANT = "EFFECT_VALUE"
    self.EFFECT_CONSTANT = EFFECT_CONSTANT
    _registry = {}
    self._registry = _registry

    def register(name):
        """Decorator with side-effects."""

        def decorator(func):
            _registry[name] = func
            return func
        return decorator
    self.register = register

    @register("sample")
    def registered_function():
        """Function registered as a side-effect."""
        return "registered_result"
    self.registered_function = registered_function
    if len(_module_state) > 0:
        print(f"Module state initialized with {len(_module_state)} items")
    self.__initialized__ = True
    self.__initializing__ = False
    return self
with_side_effects.__init__ = _cribo_init___cribo_9a9871_with_side_effects
clash_module_a = _cribo.types.SimpleNamespace(__name__='clash_module_a', __doc__='First module with potentially clashing names (no side-effects).')
"""First module with potentially clashing names (no side-effects)."""
def shared_function_2():
    """Function with same name in multiple modules."""
    return "shared_function_from_module_a"
class SharedClass_2:
    """Class with same name in multiple modules."""

    def method(self):
        return "SharedClass_from_module_a"
SharedClass_2.__module__ = 'clash_module_a'
SharedClass_2.__name__ = 'SharedClass'
SharedClass_2.__qualname__ = 'SharedClass'
SHARED_CONSTANT_2 = "SHARED_FROM_A"
def unique_a_function():
    """Function unique to module A."""
    return "unique_a_result"
clash_module_a.shared_function = shared_function_2
clash_module_a.SharedClass = SharedClass_2
clash_module_a.SHARED_CONSTANT = SHARED_CONSTANT_2
clash_module_a.unique_a_function = unique_a_function
clash_module_b = _cribo.types.SimpleNamespace(__name__='clash_module_b', __doc__='Second module with potentially clashing names (no side-effects).')
"""Second module with potentially clashing names (no side-effects)."""
def shared_function_1():
    """Function with same name in multiple modules."""
    return "shared_function_from_module_b"
class SharedClass_1:
    """Class with same name in multiple modules."""

    def method(self):
        return "SharedClass_from_module_b"
SharedClass_1.__module__ = 'clash_module_b'
SharedClass_1.__name__ = 'SharedClass'
SharedClass_1.__qualname__ = 'SharedClass'
SHARED_CONSTANT_1 = "SHARED_FROM_B"
def unique_b_function():
    """Function unique to module B."""
    return "unique_b_result"
clash_module_b.shared_function = shared_function_1
clash_module_b.SharedClass = SharedClass_1
clash_module_b.SHARED_CONSTANT = SHARED_CONSTANT_1
clash_module_b.unique_b_function = unique_b_function
"""Main module demonstrating various wildcard import patterns."""
with_side_effects = _cribo_init___cribo_9a9871_with_side_effects(with_side_effects)
EFFECT_CONSTANT = with_side_effects.EFFECT_CONSTANT
EffectClass = with_side_effects.EffectClass
effect_function = with_side_effects.effect_function
register = with_side_effects.register
registered_function = with_side_effects.registered_function
shared_function = shared_function_2
SharedClass = SharedClass_2
SHARED_CONSTANT = SHARED_CONSTANT_2
shared_function = shared_function_1
SharedClass = SharedClass_1
SHARED_CONSTANT = SHARED_CONSTANT_1
def main():
    """Test all imported symbols."""
    results = []
    results.append(f"safe_function: {safe_function()}")
    results.append(f"SafeClass: {SafeClass().method()}")
    results.append(f"SAFE_CONSTANT: {SAFE_CONSTANT}")
    try:
        results.append(f"_private_function: {_private_function()}")
    except NameError:
        results.append("_private_function: correctly not imported")
    try:
        results.append(f"PRIVATE_CONSTANT: {PRIVATE_CONSTANT}")
    except NameError:
        results.append("PRIVATE_CONSTANT: correctly not imported")
    results.append(f"effect_function: {effect_function()}")
    results.append(f"EffectClass: {EffectClass().method()}")
    results.append(f"EFFECT_CONSTANT: {EFFECT_CONSTANT}")
    results.append(f"registered_function: {registered_function()}")
    results.append(f"shared_function: {shared_function()}")
    results.append(f"SharedClass: {SharedClass().method()}")
    results.append(f"SHARED_CONSTANT: {SHARED_CONSTANT}")
    results.append(f"unique_a_function: {unique_a_function()}")
    results.append(f"unique_b_function: {unique_b_function()}")
    return results
if __name__ == "__main__":
    print("Testing wildcard imports:")
    print("-" * 40)
    for result in main():
        print(result)
    print("-" * 40)
    print("All tests completed!")
