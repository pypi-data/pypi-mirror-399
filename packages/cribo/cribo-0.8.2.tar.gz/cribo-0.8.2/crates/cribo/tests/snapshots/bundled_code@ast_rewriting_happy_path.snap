---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/ast_rewriting_happy_path/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
utils_helpers = _cribo.types.SimpleNamespace(__name__='utils.helpers', __doc__="\nUtility helper functions for the happy path test.\nThese functions have unique names that shouldn't conflict.\n")
utils = _cribo.types.SimpleNamespace(__name__='utils', __initializing__=False, __initialized__=False, __path__=[])
utils.helpers = utils_helpers
"""\nUtility helper functions for the happy path test.\nThese functions have unique names that shouldn't conflict.\n"""
def format_message(greeting: str, name: str) -> str:
    """Format a greeting message."""
    return f"{greeting}, {name}!"
def calculate_total(values: _cribo.typing.List[int]) -> int:
    """Calculate the sum of a list of integers."""
    return sum(values)
utils_helpers.calculate_total = calculate_total
utils_helpers.format_message = format_message
models_user = _cribo.types.SimpleNamespace(__name__='models.user', __doc__='\nUser model with role enumeration.\nNo naming conflicts with other modules.\n')
models = _cribo.types.SimpleNamespace(__name__='models', __initializing__=False, __initialized__=False, __path__=[])
models.user = models_user
"""\nUser model with role enumeration.\nNo naming conflicts with other modules.\n"""
class UserRole(_cribo.enum.Enum):
    """User role enumeration."""
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"
UserRole.__module__ = 'models.user'
class User:
    """Simple user model."""

    def __init__(self, name: str, email: str, role: UserRole=UserRole.USER):
        self.name = name
        self.email = email
        self.role = role
        self.active = True

    def __str__(self) -> str:
        return f"User(name='{self.name}', email='{self.email}', role={self.role.value})"

    def __repr__(self) -> str:
        return self.__str__()

    def activate(self) -> None:
        """Activate the user."""
        self.active = True

    def deactivate(self) -> None:
        """Deactivate the user."""
        self.active = False
User.__module__ = 'models.user'
models_user.User = User
models_user.UserRole = UserRole
services_database = _cribo.types.SimpleNamespace(__name__='services.database', __doc__='\nDatabase service module.\nContains database-related functionality with unique names.\n')
services = _cribo.types.SimpleNamespace(__name__='services', __initializing__=False, __initialized__=False, __path__=[])
services.database = services_database
"""\nDatabase service module.\nContains database-related functionality with unique names.\n"""
class DatabaseConnection:
    """Represents a database connection."""

    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.is_connected = False

    def connect(self) -> bool:
        """Connect to the database."""
        self.is_connected = True
        return True

    def disconnect(self) -> None:
        """Disconnect from the database."""
        self.is_connected = False
DatabaseConnection.__module__ = 'services.database'
class DatabaseService:
    """Service for database operations."""

    def __init__(self, database_path: str):
        self.connection_string = f"sqlite://{database_path}"
        self.connection = DatabaseConnection(self.connection_string)
        self.cache: _cribo.typing.Dict[str, _cribo.typing.Any] = {}

    def connect(self) -> bool:
        """Connect to the database."""
        return self.connection.connect()

    def query(self, sql: str) -> _cribo.typing.Optional[_cribo.typing.Dict[str, _cribo.typing.Any]]:
        """Execute a query."""
        if not self.connection.is_connected:
            self.connect()
        return {"result": f"Executed: {sql}"}

    def close(self) -> None:
        """Close the database connection."""
        self.connection.disconnect()
DatabaseService.__module__ = 'services.database'
services_database.DatabaseConnection = DatabaseConnection
services_database.DatabaseService = DatabaseService
"""\nHappy path main module that uses multiple nested modules without name collisions.\nThis should bundle cleanly without any AST rewriting for conflicts.\n"""
def main():
    user = User("Alice", "alice@example.com", UserRole.ADMIN)
    db = DatabaseService("test.db")
    message = format_message("Welcome", user.name)
    total = calculate_total([10, 20, 30])
    print(message)
    print(f"User: {user}")
    print(f"Role: {user.role.value}")
    print(f"Database: {db.connection_string}")
    print(f"Total: {total}")
    return {"user": user.name, "email": user.email, "role": user.role.value, "total": total, "message": message}
if __name__ == "__main__":
    result = main()
    print("Result:", result)
database = services.database
