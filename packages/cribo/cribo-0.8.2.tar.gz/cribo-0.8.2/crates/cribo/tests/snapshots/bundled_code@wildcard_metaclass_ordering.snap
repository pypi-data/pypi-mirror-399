---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/wildcard_metaclass_ordering/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
yaml_module_loader = _cribo.types.SimpleNamespace(__name__='yaml_module.loader')
yaml_module = _cribo.types.SimpleNamespace(__name__='yaml_module', __initializing__=False, __initialized__=False, __path__=[])
yaml_module.loader = yaml_module_loader
class BaseLoader:
    """Base loader class"""

    def __init__(self):
        self.name = "BaseLoader"
BaseLoader.__module__ = 'yaml_module.loader'
class Loader(BaseLoader):
    """Standard YAML loader"""

    def __init__(self):
        super().__init__()
        self.name = "Loader"
Loader.__module__ = 'yaml_module.loader'
class FullLoader(BaseLoader):
    """Full featured YAML loader"""

    def __init__(self):
        super().__init__()
        self.name = "FullLoader"
FullLoader.__module__ = 'yaml_module.loader'
class UnsafeLoader(BaseLoader):
    """Unsafe loader that can execute arbitrary Python"""

    def __init__(self):
        super().__init__()
        self.name = "UnsafeLoader"
UnsafeLoader.__module__ = 'yaml_module.loader'
class SafeLoader(BaseLoader):
    """Safe loader with limited functionality"""

    def __init__(self):
        super().__init__()
        self.name = "SafeLoader"
SafeLoader.__module__ = 'yaml_module.loader'
yaml_module_loader.BaseLoader = BaseLoader
yaml_module_loader.Loader = Loader
yaml_module_loader.FullLoader = FullLoader
yaml_module_loader.UnsafeLoader = UnsafeLoader
yaml_module_loader.SafeLoader = SafeLoader
yaml_module_dumper = _cribo.types.SimpleNamespace(__name__='yaml_module.dumper')
yaml_module.dumper = yaml_module_dumper
class BaseDumper:
    """Base dumper class"""

    def __init__(self):
        self.name = "BaseDumper"
BaseDumper.__module__ = 'yaml_module.dumper'
class Dumper(BaseDumper):
    """Standard YAML dumper"""

    def __init__(self):
        super().__init__()
        self.name = "Dumper"
Dumper.__module__ = 'yaml_module.dumper'
class SafeDumper(BaseDumper):
    """Safe YAML dumper"""

    def __init__(self):
        super().__init__()
        self.name = "SafeDumper"
SafeDumper.__module__ = 'yaml_module.dumper'
yaml_module_dumper.BaseDumper = BaseDumper
yaml_module_dumper.Dumper = Dumper
yaml_module_dumper.SafeDumper = SafeDumper
def _cribo_init___cribo_952a76_yaml_module(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True

    class YAMLObjectMetaclass(type):
        """The metaclass for YAMLObject."""

        def __init__(cls, name, bases, kwds):
            super().__init__(name, bases, kwds)
            if "yaml_tag" in kwds and kwds.get("yaml_tag") is not None:
                print(f"Metaclass: Registering {name} with tag {kwds['yaml_tag']}")
                if hasattr(cls, "yaml_loader"):
                    if isinstance(cls.yaml_loader, list):
                        for loader in cls.yaml_loader:
                            print(f"  - Would register with {loader.__name__}")
                    else:
                        print(f"  - Would register with {cls.yaml_loader.__name__}")
    YAMLObjectMetaclass.__module__ = 'yaml_module'
    self.YAMLObjectMetaclass = YAMLObjectMetaclass

    class YAMLObject(metaclass=YAMLObjectMetaclass):
        """\n    An object that can be serialized to/from YAML.\n    Uses wildcard-imported symbols in class body.\n    """
        __slots__ = ()
        yaml_loader = [Loader, FullLoader, UnsafeLoader]
        yaml_dumper = Dumper
        yaml_tag = None
        yaml_flow_style = None

        def __repr__(self):
            return f"YAMLObject(loaders={len(self.yaml_loader)}, dumper={self.yaml_dumper.__name__})"

        @classmethod
        def from_yaml(cls, loader, node):
            return f"Loading {cls.__name__} from YAML"

        @classmethod
        def to_yaml(cls, dumper, data):
            return f"Dumping {cls.__name__} to YAML"
    YAMLObject.__module__ = 'yaml_module'
    self.YAMLObject = YAMLObject
    self.dumper = yaml_module_dumper
    self.loader = yaml_module_loader
    self.__initialized__ = True
    self.__initializing__ = False
    return self
yaml_module.__init__ = _cribo_init___cribo_952a76_yaml_module
"""\nTest fixture for wildcard imports with metaclass ordering.\n\nThis tests that when using wildcard imports, symbols from __all__\nare properly included even if not directly used in the class body.\n"""
__cribo_init_result = _cribo_init___cribo_952a76_yaml_module(yaml_module)
for attr in dir(__cribo_init_result):
    if not attr.startswith('_'):
        setattr(yaml_module, attr, getattr(__cribo_init_result, attr))
assert hasattr(yaml_module, "YAMLObject")
assert hasattr(yaml_module, "YAMLObjectMetaclass")
print("Testing YAMLObject...")
obj = yaml_module.YAMLObject()
print(f"YAMLObject created: {obj}")
print(f"YAMLObject has metaclass: {type(yaml_module.YAMLObject).__name__}")
class CustomYAML(yaml_module.YAMLObject):
    yaml_tag = "!custom"
print("CustomYAML class created successfully")
print("All tests passed!")
dumper = yaml_module.dumper
loader = yaml_module.loader
