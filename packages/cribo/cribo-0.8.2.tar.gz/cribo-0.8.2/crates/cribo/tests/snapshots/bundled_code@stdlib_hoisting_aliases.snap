---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/stdlib_hoisting_aliases/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import sys as _sys
import importlib as _importlib
class _CriboModule():

    def __init__(self, m, p):
        self._m, self._p = m, p

    def __getattr__(self, n):
        f = self._p + '.' + n
        try:
            return _CriboModule(_importlib.import_module(f), f)
        except ImportError:
            return getattr(self._m, n)

    def __getattribute__(self, n):
        return object.__getattribute__(self, n) if n in ('_m', '_p', '__getattr__', '__class__', '__dict__', '__dir__', '__module__', '__qualname__') else getattr(object.__getattribute__(self, '_m'), n)
class _Cribo():

    def __getattr__(self, n):
        m = _sys.modules.get(n) or _importlib.import_module(n)
        return _CriboModule(m, n)
_cribo = _Cribo()
file_utils = _cribo.types.SimpleNamespace(__name__='file_utils', __doc__='File utilities module - no side effects, uses aliased stdlib imports.')
"""File utilities module - no side effects, uses aliased stdlib imports."""
def get_current_directory() -> str:
    """Get current directory using aliased os module."""
    fixed_path = "/home/user/project"
    path_obj = _cribo.pathlib.Path(fixed_path)
    return str(path_obj.name)
def get_mock_file_info() -> dict:
    """Get mock file information using aliased imports."""
    path_obj = _cribo.pathlib.Path("/home/user/test.txt")
    mod_time = _cribo.datetime.datetime.fromisoformat("2023-11-14T23:13:20")
    info = {"size": 1024, "name": "test.txt", "parent": "/home/user", "modified": mod_time.isoformat(), "exists": True, "is_absolute": True}
    return _cribo.json.loads(_cribo.json.dumps(info))
file_utils.get_current_directory = get_current_directory
file_utils.get_mock_file_info = get_mock_file_info
logger = _cribo.types.SimpleNamespace(__name__='logger', __initializing__=False, __initialized__=False)
def _cribo_init___cribo_60bb0a_logger(self):
    if getattr(self, '__initialized__', False):
        return self
    if getattr(self, '__initializing__', False):
        return self
    self.__initializing__ = True
    """Logger module - has side effects (print), uses different aliased stdlib imports."""
    python_sys = _cribo.sys
    self.python_sys = python_sys
    self.python_sys = python_sys
    log_lib = _cribo.logging
    self.log_lib = log_lib
    self.log_lib = log_lib
    ODict = _cribo.collections.OrderedDict
    self.ODict = ODict
    json_stringify = _cribo.json.dumps
    self.json_stringify = json_stringify
    print("Initializing logger module...")
    _cribo.logging.basicConfig(level=_cribo.logging.INFO, format="%(levelname)s - %(message)s")
    logger = _cribo.logging.getLogger(self.__name__)
    self.logger = logger

    def log_message(message: str) -> None:
        """Log a message using aliased logging module."""
        logger.info(f"[ALIASED LOG] {message}")
        _cribo.sys.stdout.write(f"[STDOUT] {message}\n")
        _cribo.sys.stdout.flush()
    self.log_message = log_message

    def get_logger_info() -> str:
        """Get information about the logger configuration."""
        info = _cribo.collections.OrderedDict([("python_version", "3.12.0"), ("logger_name", logger.name), ("log_level", _cribo.logging.getLevelName(logger.level)), ("handlers", len(logger.handlers))])
        return _cribo.json.dumps(info, indent=2)
    self.get_logger_info = get_logger_info
    self.ODict = _cribo.collections.OrderedDict
    self.json_stringify = _cribo.json.dumps
    self.__initialized__ = True
    self.__initializing__ = False
    return self
logger.__init__ = _cribo_init___cribo_60bb0a_logger
"""Test stdlib hoisting with aliases and renamed imports."""
logger = _cribo_init___cribo_60bb0a_logger(logger)
log_message = logger.log_message
get_logger_info = logger.get_logger_info
dir_name = get_current_directory()
print(f"Current directory name: {dir_name}")
info = get_mock_file_info()
print(f"Mock file info: {info}")
log_message("Starting application")
logger_info = get_logger_info()
print(f"Logger info: {logger_info}")
print("All tests completed successfully!")
