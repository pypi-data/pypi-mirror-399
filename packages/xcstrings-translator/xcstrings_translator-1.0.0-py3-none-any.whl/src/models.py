"""
Pydantic models for Apple's Localizable.xcstrings format.

The xcstrings format is a JSON-based localization file format introduced
in Xcode 15 (WWDC 2023). It replaces the traditional .strings and 
.stringsdict files with a single, structured format that supports:

- Multiple languages in one file
- Pluralization (one, zero, two, few, many, other)
- Device-specific variations (iPhone, iPad, Mac, Apple Watch)
- Translation state tracking (new, translated, needs_review, stale)
- Comments for translator context
- Format specifiers preservation (%@, %lld, %1$@, etc.)

Structure:
{
    "sourceLanguage": "en",
    "version": "1.0",
    "strings": {
        "key": {
            "comment": "Context for translators",
            "extractionState": "manual|extracted_with_value|stale",
            "localizations": {
                "en": {
                    "stringUnit": {
                        "state": "translated|new|needs_review",
                        "value": "Translated text"
                    }
                }
            }
        }
    }
}
"""

from __future__ import annotations
from typing import Any
from pydantic import BaseModel, Field


class StringUnit(BaseModel):
    """A single translated string unit."""
    state: str = "translated"
    value: str


class PluralVariation(BaseModel):
    """Plural variation for a string (one, other, zero, two, few, many)."""
    stringUnit: StringUnit


class Variations(BaseModel):
    """Container for plural and device variations."""
    plural: dict[str, PluralVariation] | None = None
    device: dict[str, Any] | None = None


class Localization(BaseModel):
    """A localization entry for a specific language."""
    stringUnit: StringUnit | None = None
    variations: Variations | None = None


class StringEntry(BaseModel):
    """A single string entry with all its localizations."""
    comment: str | None = None
    extractionState: str | None = None
    isCommentAutoGenerated: bool | None = None
    localizations: dict[str, Localization] = Field(default_factory=dict)


class XCStringsFile(BaseModel):
    """Root model for an xcstrings file."""
    sourceLanguage: str = "en"
    version: str = "1.0"
    strings: dict[str, StringEntry] = Field(default_factory=dict)
    
    @classmethod
    def from_file(cls, path: str) -> "XCStringsFile":
        """Load an xcstrings file from disk."""
        import json
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        return cls.model_validate(data)
    
    def to_file(self, path: str) -> None:
        """Save the xcstrings file to disk."""
        import json
        with open(path, "w", encoding="utf-8") as f:
            json.dump(
                self.model_dump(exclude_none=True, by_alias=True),
                f,
                ensure_ascii=False,
                indent=2
            )
    
    def get_existing_languages(self) -> set[str]:
        """Get all languages that have at least one translation."""
        languages = set()
        for entry in self.strings.values():
            languages.update(entry.localizations.keys())
        return languages

    def get_languages_with_localizations(self) -> set[str]:
        """Get all non-source languages that have at least one translation."""
        all_langs = self.get_existing_languages()
        return {lang for lang in all_langs if lang != self.sourceLanguage}
    
    def get_translatable_strings(self) -> list[tuple[str, StringEntry]]:
        """Get all strings that can be translated (non-empty, not just format specifiers)."""
        translatable = []
        for key, entry in self.strings.items():
            # Skip empty keys
            if not key.strip():
                continue
            # Skip keys that are just format specifiers or symbols
            if self._is_format_only(key):
                continue
            translatable.append((key, entry))
        return translatable
    
    @staticmethod
    def _is_format_only(key: str) -> bool:
        """Check if a key is only format specifiers or symbols."""
        import re
        # Remove format specifiers (order matters: %lld before general pattern)
        cleaned = re.sub(r'%lld', '', key)
        cleaned = re.sub(r'%%', '', cleaned)
        cleaned = re.sub(r'%[\d$]*[@dlfse]', '', cleaned)
        # Remove common symbols and punctuation
        cleaned = cleaned.strip(' •©+~/')
        # If nothing left, it's format-only
        return len(cleaned) == 0


# Models for translation requests and responses

class TranslationContext(BaseModel):
    """Context for a translation request."""
    key: str
    comment: str | None = None
    existing_translations: dict[str, str] = Field(default_factory=dict)
    has_format_specifiers: bool = False
    format_specifiers: list[str] = Field(default_factory=list)


class TranslatedString(BaseModel):
    """A translated string with metadata."""
    key: str
    language: str
    value: str
    confidence: float = Field(ge=0.0, le=1.0, default=1.0)


class TranslationBatch(BaseModel):
    """A batch of translations for multiple strings."""
    translations: list[TranslatedString]


# Language metadata

SUPPORTED_LANGUAGES = {
    # European
    "en": "English",
    "de": "German (Deutsch)",
    "fr": "French (Français)",
    "es": "Spanish (Español)",
    "it": "Italian (Italiano)",
    "pt": "Portuguese (Português)",
    "pt-BR": "Brazilian Portuguese (Português do Brasil)",
    "nl": "Dutch (Nederlands)",
    "pl": "Polish (Polski)",
    "sv": "Swedish (Svenska)",
    "da": "Danish (Dansk)",
    "no": "Norwegian (Norsk)",
    "nb": "Norwegian Bokmål (Norsk Bokmål)",
    "nn": "Norwegian Nynorsk (Norsk Nynorsk)",
    "fi": "Finnish (Suomi)",
    "cs": "Czech (Čeština)",
    "sk": "Slovak (Slovenčina)",
    "hu": "Hungarian (Magyar)",
    "ro": "Romanian (Română)",
    "bg": "Bulgarian (Български)",
    "el": "Greek (Ελληνικά)",
    "sq": "Albanian (Shqip)",
    "sq-AL": "Albanian (Albania) (Shqip)",
    "uk": "Ukrainian (Українська)",
    "ru": "Russian (Русский)",
    "tr": "Turkish (Türkçe)",
    
    # Asian
    "ja": "Japanese (日本語)",
    "ko": "Korean (한국어)",
    "zh-Hans": "Simplified Chinese (简体中文)",
    "zh-Hant": "Traditional Chinese (繁體中文)",
    "th": "Thai (ไทย)",
    "vi": "Vietnamese (Tiếng Việt)",
    "id": "Indonesian (Bahasa Indonesia)",
    "ms": "Malay (Bahasa Melayu)",
    "hi": "Hindi (हिन्दी)",
    
    # Middle Eastern
    "ar": "Arabic (العربية)",
    "he": "Hebrew (עברית)",
    
    # Other
    "ca": "Catalan (Català)",
    "eu": "Basque (Euskara)",
}

# Apple's supported locale codes
APPLE_LOCALE_CODES = list(SUPPORTED_LANGUAGES.keys())
