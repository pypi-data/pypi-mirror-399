<!DOCTYPE html>
<html>
<head>
    <title>D3 Tree Debug - Minimal Test</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #0d1117;
            color: #c9d1d9;
        }
        #controls {
            margin-bottom: 20px;
            padding: 10px;
            background: #161b22;
            border-radius: 6px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            background: #238636;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        button:hover {
            background: #2ea043;
        }
        #debug-output {
            background: #161b22;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        svg {
            background: #0d1117;
            border: 1px solid #30363d;
        }
        .node circle {
            fill: #58a6ff;
            stroke: #1f6feb;
            stroke-width: 2px;
            cursor: pointer;
        }
        .node circle:hover {
            fill: #79c0ff;
        }
        .node text {
            fill: #c9d1d9;
            font-size: 12px;
        }
        .link {
            fill: none;
            stroke: #6e7681;
            stroke-width: 2px;
        }
    </style>
</head>
<body>
    <h1>D3 Tree Layout Debug - Minimal Test</h1>

    <div id="controls">
        <button onclick="loadGraphData()">Load Graph Data</button>
        <button onclick="testSimpleTree()">Test Simple Tree</button>
        <button onclick="clearVisualization()">Clear</button>
    </div>

    <div id="debug-output"></div>

    <svg width="1400" height="800"></svg>

    <script>
        const svg = d3.select("svg");
        const g = svg.append("g");
        const debugOutput = document.getElementById('debug-output');

        let allNodes = [];
        let allLinks = [];

        function log(message) {
            debugOutput.textContent += message + '\n';
            console.log(message);
        }

        function clearLog() {
            debugOutput.textContent = '';
        }

        function clearVisualization() {
            g.selectAll("*").remove();
            clearLog();
            log('Visualization cleared');
        }

        // Test with simple hardcoded tree
        function testSimpleTree() {
            clearLog();
            log('Testing simple tree structure...');

            const data = {
                name: "root",
                children: [
                    {
                        name: "child1",
                        children: [
                            { name: "grandchild1" },
                            { name: "grandchild2" }
                        ]
                    },
                    {
                        name: "child2",
                        children: [
                            { name: "grandchild3" }
                        ]
                    },
                    { name: "child3" }
                ]
            };

            log('Tree structure:');
            log(JSON.stringify(data, null, 2));

            renderTree(data);
        }

        function renderTree(treeData) {
            clearVisualization();
            clearLog();

            // Create D3 hierarchy
            const root = d3.hierarchy(treeData);
            log(`Hierarchy created with ${root.descendants().length} nodes`);

            // Create tree layout
            const treeLayout = d3.tree()
                .size([700, 1200]);

            // Apply layout
            treeLayout(root);

            log('Tree layout calculated:');
            root.descendants().forEach(node => {
                log(`  ${node.data.name}: x=${node.x.toFixed(0)}, y=${node.y.toFixed(0)}, depth=${node.depth}`);
            });

            // Transform coordinates for horizontal tree
            const margin = {top: 20, right: 120, bottom: 20, left: 120};

            // Render links
            const linkGenerator = d3.linkHorizontal()
                .x(d => d.y + margin.left)
                .y(d => d.x + margin.top);

            g.selectAll('.link')
                .data(root.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', linkGenerator);

            log(`\nRendered ${root.links().length} links`);

            // Render nodes
            const nodes = g.selectAll('.node')
                .data(root.descendants())
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.y + margin.left},${d.x + margin.top})`);

            nodes.append('circle')
                .attr('r', 8);

            nodes.append('text')
                .attr('dx', 12)
                .attr('dy', 4)
                .text(d => d.data.name);

            log(`Rendered ${root.descendants().length} nodes`);
        }

        // Load actual graph data
        async function loadGraphData() {
            clearLog();
            log('Loading graph.json...');

            try {
                const response = await fetch('http://localhost:8081/chunk-graph.json');
                const data = await response.json();

                allNodes = data.nodes;
                allLinks = data.links;

                log(`Loaded ${allNodes.length} nodes and ${allLinks.length} links`);
                log('\nNode types:');

                const typeCounts = {};
                allNodes.forEach(n => {
                    typeCounts[n.type] = (typeCounts[n.type] || 0) + 1;
                });
                Object.entries(typeCounts).forEach(([type, count]) => {
                    log(`  ${type}: ${count}`);
                });

                log('\nLink types:');
                const linkTypeCounts = {};
                allLinks.forEach(l => {
                    linkTypeCounts[l.type] = (linkTypeCounts[l.type] || 0) + 1;
                });
                Object.entries(linkTypeCounts).forEach(([type, count]) => {
                    log(`  ${type}: ${count}`);
                });

                // Find root nodes (no incoming containment edges)
                const targetIds = new Set(
                    allLinks
                        .filter(l => l.type.includes('containment') || l.type.includes('hierarchy'))
                        .map(l => l.target.id || l.target)
                );

                const rootNodes = allNodes.filter(n => !targetIds.has(n.id));
                log(`\nFound ${rootNodes.length} root nodes:`);
                rootNodes.slice(0, 10).forEach(n => {
                    log(`  ${n.type}: ${n.name || n.id}`);
                });

                // Build tree from first root
                if (rootNodes.length > 0) {
                    log(`\nBuilding tree from: ${rootNodes[0].name || rootNodes[0].id}`);
                    const tree = buildTreeFromNode(rootNodes[0]);
                    log('\nTree structure:');
                    log(JSON.stringify(tree, null, 2).substring(0, 500) + '...');

                    renderTree(tree);
                }

            } catch (error) {
                log(`ERROR: ${error.message}`);
                log('Make sure the visualization server is running on port 8765');
            }
        }

        function buildTreeFromNode(node, maxDepth = 3, currentDepth = 0) {
            if (currentDepth >= maxDepth) {
                return {
                    name: node.name || node.id,
                    type: node.type
                };
            }

            // Find children via containment links
            const childLinks = allLinks.filter(l => {
                const sourceId = l.source.id || l.source;
                const linkType = l.type;
                return sourceId === node.id &&
                       (linkType === 'dir_containment' ||
                        linkType === 'file_containment' ||
                        linkType === 'dir_hierarchy');
            });

            const children = childLinks.map(l => {
                const targetId = l.target.id || l.target;
                const childNode = allNodes.find(n => n.id === targetId);
                return childNode ? buildTreeFromNode(childNode, maxDepth, currentDepth + 1) : null;
            }).filter(c => c);

            return {
                name: node.name || node.id,
                type: node.type,
                children: children.length > 0 ? children : undefined
            };
        }
    </script>

</body>
</html>
