# Generated from Dax.g4 by ANTLR 4.13.2
import sys

from antlr4 import *

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4,
        1,
        40,
        205,
        2,
        0,
        7,
        0,
        2,
        1,
        7,
        1,
        2,
        2,
        7,
        2,
        2,
        3,
        7,
        3,
        2,
        4,
        7,
        4,
        2,
        5,
        7,
        5,
        2,
        6,
        7,
        6,
        2,
        7,
        7,
        7,
        2,
        8,
        7,
        8,
        2,
        9,
        7,
        9,
        2,
        10,
        7,
        10,
        2,
        11,
        7,
        11,
        2,
        12,
        7,
        12,
        2,
        13,
        7,
        13,
        2,
        14,
        7,
        14,
        2,
        15,
        7,
        15,
        2,
        16,
        7,
        16,
        2,
        17,
        7,
        17,
        2,
        18,
        7,
        18,
        2,
        19,
        7,
        19,
        2,
        20,
        7,
        20,
        2,
        21,
        7,
        21,
        1,
        0,
        1,
        0,
        1,
        0,
        3,
        0,
        48,
        8,
        0,
        1,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        5,
        1,
        57,
        8,
        1,
        10,
        1,
        12,
        1,
        60,
        9,
        1,
        1,
        2,
        1,
        2,
        3,
        2,
        64,
        8,
        2,
        1,
        3,
        1,
        3,
        3,
        3,
        68,
        8,
        3,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        1,
        4,
        3,
        4,
        77,
        8,
        4,
        1,
        5,
        1,
        5,
        1,
        5,
        5,
        5,
        82,
        8,
        5,
        10,
        5,
        12,
        5,
        85,
        9,
        5,
        1,
        6,
        1,
        6,
        1,
        6,
        5,
        6,
        90,
        8,
        6,
        10,
        6,
        12,
        6,
        93,
        9,
        6,
        1,
        7,
        1,
        7,
        1,
        7,
        5,
        7,
        98,
        8,
        7,
        10,
        7,
        12,
        7,
        101,
        9,
        7,
        1,
        8,
        1,
        8,
        1,
        8,
        5,
        8,
        106,
        8,
        8,
        10,
        8,
        12,
        8,
        109,
        9,
        8,
        1,
        9,
        1,
        9,
        1,
        9,
        5,
        9,
        114,
        8,
        9,
        10,
        9,
        12,
        9,
        117,
        9,
        9,
        1,
        10,
        1,
        10,
        1,
        10,
        5,
        10,
        122,
        8,
        10,
        10,
        10,
        12,
        10,
        125,
        9,
        10,
        1,
        11,
        1,
        11,
        1,
        11,
        3,
        11,
        130,
        8,
        11,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        1,
        12,
        3,
        12,
        141,
        8,
        12,
        1,
        13,
        1,
        13,
        1,
        14,
        1,
        14,
        1,
        14,
        3,
        14,
        148,
        8,
        14,
        1,
        14,
        1,
        14,
        1,
        15,
        1,
        15,
        1,
        16,
        1,
        16,
        1,
        16,
        5,
        16,
        157,
        8,
        16,
        10,
        16,
        12,
        16,
        160,
        9,
        16,
        1,
        17,
        3,
        17,
        163,
        8,
        17,
        1,
        17,
        1,
        17,
        1,
        18,
        1,
        18,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        1,
        19,
        3,
        19,
        178,
        8,
        19,
        1,
        20,
        1,
        20,
        1,
        20,
        1,
        20,
        5,
        20,
        184,
        8,
        20,
        10,
        20,
        12,
        20,
        187,
        9,
        20,
        1,
        20,
        1,
        20,
        1,
        21,
        1,
        21,
        1,
        21,
        1,
        21,
        5,
        21,
        195,
        8,
        21,
        10,
        21,
        12,
        21,
        198,
        9,
        21,
        1,
        21,
        1,
        21,
        1,
        21,
        3,
        21,
        203,
        8,
        21,
        1,
        21,
        0,
        0,
        22,
        0,
        2,
        4,
        6,
        8,
        10,
        12,
        14,
        16,
        18,
        20,
        22,
        24,
        26,
        28,
        30,
        32,
        34,
        36,
        38,
        40,
        42,
        0,
        8,
        1,
        0,
        4,
        5,
        1,
        0,
        17,
        18,
        1,
        0,
        19,
        23,
        2,
        0,
        24,
        25,
        28,
        28,
        1,
        0,
        26,
        27,
        2,
        0,
        16,
        16,
        24,
        25,
        2,
        0,
        11,
        13,
        38,
        38,
        2,
        0,
        35,
        35,
        38,
        38,
        211,
        0,
        44,
        1,
        0,
        0,
        0,
        2,
        51,
        1,
        0,
        0,
        0,
        4,
        61,
        1,
        0,
        0,
        0,
        6,
        67,
        1,
        0,
        0,
        0,
        8,
        69,
        1,
        0,
        0,
        0,
        10,
        78,
        1,
        0,
        0,
        0,
        12,
        86,
        1,
        0,
        0,
        0,
        14,
        94,
        1,
        0,
        0,
        0,
        16,
        102,
        1,
        0,
        0,
        0,
        18,
        110,
        1,
        0,
        0,
        0,
        20,
        118,
        1,
        0,
        0,
        0,
        22,
        129,
        1,
        0,
        0,
        0,
        24,
        140,
        1,
        0,
        0,
        0,
        26,
        142,
        1,
        0,
        0,
        0,
        28,
        144,
        1,
        0,
        0,
        0,
        30,
        151,
        1,
        0,
        0,
        0,
        32,
        153,
        1,
        0,
        0,
        0,
        34,
        162,
        1,
        0,
        0,
        0,
        36,
        166,
        1,
        0,
        0,
        0,
        38,
        177,
        1,
        0,
        0,
        0,
        40,
        179,
        1,
        0,
        0,
        0,
        42,
        202,
        1,
        0,
        0,
        0,
        44,
        45,
        5,
        1,
        0,
        0,
        45,
        47,
        3,
        26,
        13,
        0,
        46,
        48,
        3,
        2,
        1,
        0,
        47,
        46,
        1,
        0,
        0,
        0,
        47,
        48,
        1,
        0,
        0,
        0,
        48,
        49,
        1,
        0,
        0,
        0,
        49,
        50,
        5,
        0,
        0,
        1,
        50,
        1,
        1,
        0,
        0,
        0,
        51,
        52,
        5,
        2,
        0,
        0,
        52,
        53,
        5,
        3,
        0,
        0,
        53,
        58,
        3,
        4,
        2,
        0,
        54,
        55,
        5,
        33,
        0,
        0,
        55,
        57,
        3,
        4,
        2,
        0,
        56,
        54,
        1,
        0,
        0,
        0,
        57,
        60,
        1,
        0,
        0,
        0,
        58,
        56,
        1,
        0,
        0,
        0,
        58,
        59,
        1,
        0,
        0,
        0,
        59,
        3,
        1,
        0,
        0,
        0,
        60,
        58,
        1,
        0,
        0,
        0,
        61,
        63,
        3,
        6,
        3,
        0,
        62,
        64,
        7,
        0,
        0,
        0,
        63,
        62,
        1,
        0,
        0,
        0,
        63,
        64,
        1,
        0,
        0,
        0,
        64,
        5,
        1,
        0,
        0,
        0,
        65,
        68,
        3,
        8,
        4,
        0,
        66,
        68,
        3,
        10,
        5,
        0,
        67,
        65,
        1,
        0,
        0,
        0,
        67,
        66,
        1,
        0,
        0,
        0,
        68,
        7,
        1,
        0,
        0,
        0,
        69,
        70,
        5,
        9,
        0,
        0,
        70,
        71,
        5,
        38,
        0,
        0,
        71,
        72,
        5,
        17,
        0,
        0,
        72,
        76,
        3,
        6,
        3,
        0,
        73,
        77,
        3,
        8,
        4,
        0,
        74,
        75,
        5,
        10,
        0,
        0,
        75,
        77,
        3,
        6,
        3,
        0,
        76,
        73,
        1,
        0,
        0,
        0,
        76,
        74,
        1,
        0,
        0,
        0,
        77,
        9,
        1,
        0,
        0,
        0,
        78,
        83,
        3,
        12,
        6,
        0,
        79,
        80,
        5,
        15,
        0,
        0,
        80,
        82,
        3,
        12,
        6,
        0,
        81,
        79,
        1,
        0,
        0,
        0,
        82,
        85,
        1,
        0,
        0,
        0,
        83,
        81,
        1,
        0,
        0,
        0,
        83,
        84,
        1,
        0,
        0,
        0,
        84,
        11,
        1,
        0,
        0,
        0,
        85,
        83,
        1,
        0,
        0,
        0,
        86,
        91,
        3,
        14,
        7,
        0,
        87,
        88,
        5,
        14,
        0,
        0,
        88,
        90,
        3,
        14,
        7,
        0,
        89,
        87,
        1,
        0,
        0,
        0,
        90,
        93,
        1,
        0,
        0,
        0,
        91,
        89,
        1,
        0,
        0,
        0,
        91,
        92,
        1,
        0,
        0,
        0,
        92,
        13,
        1,
        0,
        0,
        0,
        93,
        91,
        1,
        0,
        0,
        0,
        94,
        99,
        3,
        16,
        8,
        0,
        95,
        96,
        7,
        1,
        0,
        0,
        96,
        98,
        3,
        16,
        8,
        0,
        97,
        95,
        1,
        0,
        0,
        0,
        98,
        101,
        1,
        0,
        0,
        0,
        99,
        97,
        1,
        0,
        0,
        0,
        99,
        100,
        1,
        0,
        0,
        0,
        100,
        15,
        1,
        0,
        0,
        0,
        101,
        99,
        1,
        0,
        0,
        0,
        102,
        107,
        3,
        18,
        9,
        0,
        103,
        104,
        7,
        2,
        0,
        0,
        104,
        106,
        3,
        18,
        9,
        0,
        105,
        103,
        1,
        0,
        0,
        0,
        106,
        109,
        1,
        0,
        0,
        0,
        107,
        105,
        1,
        0,
        0,
        0,
        107,
        108,
        1,
        0,
        0,
        0,
        108,
        17,
        1,
        0,
        0,
        0,
        109,
        107,
        1,
        0,
        0,
        0,
        110,
        115,
        3,
        20,
        10,
        0,
        111,
        112,
        7,
        3,
        0,
        0,
        112,
        114,
        3,
        20,
        10,
        0,
        113,
        111,
        1,
        0,
        0,
        0,
        114,
        117,
        1,
        0,
        0,
        0,
        115,
        113,
        1,
        0,
        0,
        0,
        115,
        116,
        1,
        0,
        0,
        0,
        116,
        19,
        1,
        0,
        0,
        0,
        117,
        115,
        1,
        0,
        0,
        0,
        118,
        123,
        3,
        22,
        11,
        0,
        119,
        120,
        7,
        4,
        0,
        0,
        120,
        122,
        3,
        22,
        11,
        0,
        121,
        119,
        1,
        0,
        0,
        0,
        122,
        125,
        1,
        0,
        0,
        0,
        123,
        121,
        1,
        0,
        0,
        0,
        123,
        124,
        1,
        0,
        0,
        0,
        124,
        21,
        1,
        0,
        0,
        0,
        125,
        123,
        1,
        0,
        0,
        0,
        126,
        127,
        7,
        5,
        0,
        0,
        127,
        130,
        3,
        22,
        11,
        0,
        128,
        130,
        3,
        24,
        12,
        0,
        129,
        126,
        1,
        0,
        0,
        0,
        129,
        128,
        1,
        0,
        0,
        0,
        130,
        23,
        1,
        0,
        0,
        0,
        131,
        141,
        3,
        38,
        19,
        0,
        132,
        141,
        3,
        34,
        17,
        0,
        133,
        141,
        3,
        36,
        18,
        0,
        134,
        141,
        3,
        28,
        14,
        0,
        135,
        141,
        3,
        40,
        20,
        0,
        136,
        137,
        5,
        29,
        0,
        0,
        137,
        138,
        3,
        6,
        3,
        0,
        138,
        139,
        5,
        30,
        0,
        0,
        139,
        141,
        1,
        0,
        0,
        0,
        140,
        131,
        1,
        0,
        0,
        0,
        140,
        132,
        1,
        0,
        0,
        0,
        140,
        133,
        1,
        0,
        0,
        0,
        140,
        134,
        1,
        0,
        0,
        0,
        140,
        135,
        1,
        0,
        0,
        0,
        140,
        136,
        1,
        0,
        0,
        0,
        141,
        25,
        1,
        0,
        0,
        0,
        142,
        143,
        3,
        6,
        3,
        0,
        143,
        27,
        1,
        0,
        0,
        0,
        144,
        145,
        3,
        30,
        15,
        0,
        145,
        147,
        5,
        29,
        0,
        0,
        146,
        148,
        3,
        32,
        16,
        0,
        147,
        146,
        1,
        0,
        0,
        0,
        147,
        148,
        1,
        0,
        0,
        0,
        148,
        149,
        1,
        0,
        0,
        0,
        149,
        150,
        5,
        30,
        0,
        0,
        150,
        29,
        1,
        0,
        0,
        0,
        151,
        152,
        7,
        6,
        0,
        0,
        152,
        31,
        1,
        0,
        0,
        0,
        153,
        158,
        3,
        6,
        3,
        0,
        154,
        155,
        5,
        33,
        0,
        0,
        155,
        157,
        3,
        6,
        3,
        0,
        156,
        154,
        1,
        0,
        0,
        0,
        157,
        160,
        1,
        0,
        0,
        0,
        158,
        156,
        1,
        0,
        0,
        0,
        158,
        159,
        1,
        0,
        0,
        0,
        159,
        33,
        1,
        0,
        0,
        0,
        160,
        158,
        1,
        0,
        0,
        0,
        161,
        163,
        3,
        36,
        18,
        0,
        162,
        161,
        1,
        0,
        0,
        0,
        162,
        163,
        1,
        0,
        0,
        0,
        163,
        164,
        1,
        0,
        0,
        0,
        164,
        165,
        5,
        36,
        0,
        0,
        165,
        35,
        1,
        0,
        0,
        0,
        166,
        167,
        7,
        7,
        0,
        0,
        167,
        37,
        1,
        0,
        0,
        0,
        168,
        178,
        5,
        34,
        0,
        0,
        169,
        178,
        5,
        37,
        0,
        0,
        170,
        178,
        5,
        6,
        0,
        0,
        171,
        178,
        5,
        7,
        0,
        0,
        172,
        173,
        5,
        8,
        0,
        0,
        173,
        174,
        5,
        29,
        0,
        0,
        174,
        178,
        5,
        30,
        0,
        0,
        175,
        178,
        5,
        4,
        0,
        0,
        176,
        178,
        5,
        5,
        0,
        0,
        177,
        168,
        1,
        0,
        0,
        0,
        177,
        169,
        1,
        0,
        0,
        0,
        177,
        170,
        1,
        0,
        0,
        0,
        177,
        171,
        1,
        0,
        0,
        0,
        177,
        172,
        1,
        0,
        0,
        0,
        177,
        175,
        1,
        0,
        0,
        0,
        177,
        176,
        1,
        0,
        0,
        0,
        178,
        39,
        1,
        0,
        0,
        0,
        179,
        180,
        5,
        31,
        0,
        0,
        180,
        185,
        3,
        42,
        21,
        0,
        181,
        182,
        5,
        33,
        0,
        0,
        182,
        184,
        3,
        42,
        21,
        0,
        183,
        181,
        1,
        0,
        0,
        0,
        184,
        187,
        1,
        0,
        0,
        0,
        185,
        183,
        1,
        0,
        0,
        0,
        185,
        186,
        1,
        0,
        0,
        0,
        186,
        188,
        1,
        0,
        0,
        0,
        187,
        185,
        1,
        0,
        0,
        0,
        188,
        189,
        5,
        32,
        0,
        0,
        189,
        41,
        1,
        0,
        0,
        0,
        190,
        191,
        5,
        29,
        0,
        0,
        191,
        196,
        3,
        6,
        3,
        0,
        192,
        193,
        5,
        33,
        0,
        0,
        193,
        195,
        3,
        6,
        3,
        0,
        194,
        192,
        1,
        0,
        0,
        0,
        195,
        198,
        1,
        0,
        0,
        0,
        196,
        194,
        1,
        0,
        0,
        0,
        196,
        197,
        1,
        0,
        0,
        0,
        197,
        199,
        1,
        0,
        0,
        0,
        198,
        196,
        1,
        0,
        0,
        0,
        199,
        200,
        5,
        30,
        0,
        0,
        200,
        203,
        1,
        0,
        0,
        0,
        201,
        203,
        3,
        6,
        3,
        0,
        202,
        190,
        1,
        0,
        0,
        0,
        202,
        201,
        1,
        0,
        0,
        0,
        203,
        43,
        1,
        0,
        0,
        0,
        20,
        47,
        58,
        63,
        67,
        76,
        83,
        91,
        99,
        107,
        115,
        123,
        129,
        140,
        147,
        158,
        162,
        177,
        185,
        196,
        202,
    ]


class DaxParser(Parser):
    grammarFileName = "Dax.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "'EVALUATE'",
        "'ORDER'",
        "'BY'",
        "'ASC'",
        "'DESC'",
        "'TRUE'",
        "'FALSE'",
        "'BLANK'",
        "'VAR'",
        "'RETURN'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'&&'",
        "'||'",
        "'!'",
        "<INVALID>",
        "'<>'",
        "'<'",
        "'<='",
        "'>'",
        "'>='",
        "'IN'",
        "'+'",
        "'-'",
        "'*'",
        "'/'",
        "'&'",
        "'('",
        "')'",
        "'{'",
        "'}'",
        "','",
    ]

    symbolicNames = [
        "<INVALID>",
        "EVALUATE",
        "ORDER",
        "BY",
        "ASC",
        "DESC",
        "TRUE",
        "FALSE",
        "BLANK",
        "VAR",
        "RETURN",
        "AND_KW",
        "OR_KW",
        "NOT_KW",
        "AND_OP",
        "OR_OP",
        "NOT_OP",
        "EQ",
        "NEQ",
        "LT",
        "LTE",
        "GT",
        "GTE",
        "IN",
        "PLUS",
        "MINUS",
        "ASTERISK",
        "SLASH",
        "AMPERSAND",
        "OPEN_PAREN",
        "CLOSE_PAREN",
        "OPEN_CURLY",
        "CLOSE_CURLY",
        "COMMA",
        "STRING_LITERAL",
        "SINGLE_QUOTE_ID",
        "BRACKET_ID",
        "NUMBER",
        "IDENTIFIER",
        "WS",
        "KEYWORD",
    ]

    RULE_query = 0
    RULE_orderClause = 1
    RULE_orderExpression = 2
    RULE_expression = 3
    RULE_varExpression = 4
    RULE_logicalOr = 5
    RULE_logicalAnd = 6
    RULE_equality = 7
    RULE_relational = 8
    RULE_additive = 9
    RULE_multiplicative = 10
    RULE_unary = 11
    RULE_primaryExpression = 12
    RULE_tableExpression = 13
    RULE_functionCall = 14
    RULE_functionName = 15
    RULE_argumentList = 16
    RULE_columnReference = 17
    RULE_tableReference = 18
    RULE_literal = 19
    RULE_constructor = 20
    RULE_constructorRow = 21

    ruleNames = [
        "query",
        "orderClause",
        "orderExpression",
        "expression",
        "varExpression",
        "logicalOr",
        "logicalAnd",
        "equality",
        "relational",
        "additive",
        "multiplicative",
        "unary",
        "primaryExpression",
        "tableExpression",
        "functionCall",
        "functionName",
        "argumentList",
        "columnReference",
        "tableReference",
        "literal",
        "constructor",
        "constructorRow",
    ]

    EOF = Token.EOF
    EVALUATE = 1
    ORDER = 2
    BY = 3
    ASC = 4
    DESC = 5
    TRUE = 6
    FALSE = 7
    BLANK = 8
    VAR = 9
    RETURN = 10
    AND_KW = 11
    OR_KW = 12
    NOT_KW = 13
    AND_OP = 14
    OR_OP = 15
    NOT_OP = 16
    EQ = 17
    NEQ = 18
    LT = 19
    LTE = 20
    GT = 21
    GTE = 22
    IN = 23
    PLUS = 24
    MINUS = 25
    ASTERISK = 26
    SLASH = 27
    AMPERSAND = 28
    OPEN_PAREN = 29
    CLOSE_PAREN = 30
    OPEN_CURLY = 31
    CLOSE_CURLY = 32
    COMMA = 33
    STRING_LITERAL = 34
    SINGLE_QUOTE_ID = 35
    BRACKET_ID = 36
    NUMBER = 37
    IDENTIFIER = 38
    WS = 39
    KEYWORD = 40

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache
        )
        self._predicates = None

    class QueryContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVALUATE(self):
            return self.getToken(DaxParser.EVALUATE, 0)

        def tableExpression(self):
            return self.getTypedRuleContext(DaxParser.TableExpressionContext, 0)

        def EOF(self):
            return self.getToken(DaxParser.EOF, 0)

        def orderClause(self):
            return self.getTypedRuleContext(DaxParser.OrderClauseContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_query

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterQuery"):
                listener.enterQuery(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitQuery"):
                listener.exitQuery(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitQuery"):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)

    def query(self):
        localctx = DaxParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_query)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.match(DaxParser.EVALUATE)
            self.state = 45
            self.tableExpression()
            self.state = 47
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 2:
                self.state = 46
                self.orderClause()

            self.state = 49
            self.match(DaxParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderClauseContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(DaxParser.ORDER, 0)

        def BY(self):
            return self.getToken(DaxParser.BY, 0)

        def orderExpression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.OrderExpressionContext)
            else:
                return self.getTypedRuleContext(DaxParser.OrderExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.COMMA)
            else:
                return self.getToken(DaxParser.COMMA, i)

        def getRuleIndex(self):
            return DaxParser.RULE_orderClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrderClause"):
                listener.enterOrderClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrderClause"):
                listener.exitOrderClause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrderClause"):
                return visitor.visitOrderClause(self)
            else:
                return visitor.visitChildren(self)

    def orderClause(self):
        localctx = DaxParser.OrderClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_orderClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(DaxParser.ORDER)
            self.state = 52
            self.match(DaxParser.BY)
            self.state = 53
            self.orderExpression()
            self.state = 58
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 33:
                self.state = 54
                self.match(DaxParser.COMMA)
                self.state = 55
                self.orderExpression()
                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(DaxParser.ExpressionContext, 0)

        def ASC(self):
            return self.getToken(DaxParser.ASC, 0)

        def DESC(self):
            return self.getToken(DaxParser.DESC, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_orderExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrderExpression"):
                listener.enterOrderExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrderExpression"):
                listener.exitOrderExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrderExpression"):
                return visitor.visitOrderExpression(self)
            else:
                return visitor.visitChildren(self)

    def orderExpression(self):
        localctx = DaxParser.OrderExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_orderExpression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.expression()
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 4 or _la == 5:
                self.state = 62
                _la = self._input.LA(1)
                if not (_la == 4 or _la == 5):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varExpression(self):
            return self.getTypedRuleContext(DaxParser.VarExpressionContext, 0)

        def logicalOr(self):
            return self.getTypedRuleContext(DaxParser.LogicalOrContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_expression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)

    def expression(self):
        localctx = DaxParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_expression)
        try:
            self.state = 67
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 65
                self.varExpression()
                pass
            elif token in [4, 5, 6, 7, 8, 11, 12, 13, 16, 24, 25, 29, 31, 34, 35, 36, 37, 38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 66
                self.logicalOr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(DaxParser.VAR, 0)

        def IDENTIFIER(self):
            return self.getToken(DaxParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(DaxParser.EQ, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(DaxParser.ExpressionContext, i)

        def varExpression(self):
            return self.getTypedRuleContext(DaxParser.VarExpressionContext, 0)

        def RETURN(self):
            return self.getToken(DaxParser.RETURN, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_varExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVarExpression"):
                listener.enterVarExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVarExpression"):
                listener.exitVarExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVarExpression"):
                return visitor.visitVarExpression(self)
            else:
                return visitor.visitChildren(self)

    def varExpression(self):
        localctx = DaxParser.VarExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_varExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(DaxParser.VAR)
            self.state = 70
            self.match(DaxParser.IDENTIFIER)
            self.state = 71
            self.match(DaxParser.EQ)
            self.state = 72
            self.expression()
            self.state = 76
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [9]:
                self.state = 73
                self.varExpression()
                pass
            elif token in [10]:
                self.state = 74
                self.match(DaxParser.RETURN)
                self.state = 75
                self.expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalOrContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalAnd(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.LogicalAndContext)
            else:
                return self.getTypedRuleContext(DaxParser.LogicalAndContext, i)

        def OR_OP(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.OR_OP)
            else:
                return self.getToken(DaxParser.OR_OP, i)

        def getRuleIndex(self):
            return DaxParser.RULE_logicalOr

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLogicalOr"):
                listener.enterLogicalOr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLogicalOr"):
                listener.exitLogicalOr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLogicalOr"):
                return visitor.visitLogicalOr(self)
            else:
                return visitor.visitChildren(self)

    def logicalOr(self):
        localctx = DaxParser.LogicalOrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_logicalOr)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.logicalAnd()
            self.state = 83
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 15:
                self.state = 79
                self.match(DaxParser.OR_OP)
                self.state = 80
                self.logicalAnd()
                self.state = 85
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalAndContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equality(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.EqualityContext)
            else:
                return self.getTypedRuleContext(DaxParser.EqualityContext, i)

        def AND_OP(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.AND_OP)
            else:
                return self.getToken(DaxParser.AND_OP, i)

        def getRuleIndex(self):
            return DaxParser.RULE_logicalAnd

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLogicalAnd"):
                listener.enterLogicalAnd(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLogicalAnd"):
                listener.exitLogicalAnd(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLogicalAnd"):
                return visitor.visitLogicalAnd(self)
            else:
                return visitor.visitChildren(self)

    def logicalAnd(self):
        localctx = DaxParser.LogicalAndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_logicalAnd)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.equality()
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 14:
                self.state = 87
                self.match(DaxParser.AND_OP)
                self.state = 88
                self.equality()
                self.state = 93
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EqualityContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relational(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.RelationalContext)
            else:
                return self.getTypedRuleContext(DaxParser.RelationalContext, i)

        def EQ(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.EQ)
            else:
                return self.getToken(DaxParser.EQ, i)

        def NEQ(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.NEQ)
            else:
                return self.getToken(DaxParser.NEQ, i)

        def getRuleIndex(self):
            return DaxParser.RULE_equality

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEquality"):
                listener.enterEquality(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEquality"):
                listener.exitEquality(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEquality"):
                return visitor.visitEquality(self)
            else:
                return visitor.visitChildren(self)

    def equality(self):
        localctx = DaxParser.EqualityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_equality)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.relational()
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 17 or _la == 18:
                self.state = 95
                _la = self._input.LA(1)
                if not (_la == 17 or _la == 18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 96
                self.relational()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationalContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additive(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.AdditiveContext)
            else:
                return self.getTypedRuleContext(DaxParser.AdditiveContext, i)

        def LT(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.LT)
            else:
                return self.getToken(DaxParser.LT, i)

        def LTE(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.LTE)
            else:
                return self.getToken(DaxParser.LTE, i)

        def GT(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.GT)
            else:
                return self.getToken(DaxParser.GT, i)

        def GTE(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.GTE)
            else:
                return self.getToken(DaxParser.GTE, i)

        def IN(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.IN)
            else:
                return self.getToken(DaxParser.IN, i)

        def getRuleIndex(self):
            return DaxParser.RULE_relational

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRelational"):
                listener.enterRelational(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRelational"):
                listener.exitRelational(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRelational"):
                return visitor.visitRelational(self)
            else:
                return visitor.visitChildren(self)

    def relational(self):
        localctx = DaxParser.RelationalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_relational)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.additive()
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3F) == 0 and ((1 << _la) & 16252928) != 0:
                self.state = 103
                _la = self._input.LA(1)
                if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 16252928) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 104
                self.additive()
                self.state = 109
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AdditiveContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplicative(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.MultiplicativeContext)
            else:
                return self.getTypedRuleContext(DaxParser.MultiplicativeContext, i)

        def PLUS(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.PLUS)
            else:
                return self.getToken(DaxParser.PLUS, i)

        def MINUS(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.MINUS)
            else:
                return self.getToken(DaxParser.MINUS, i)

        def AMPERSAND(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.AMPERSAND)
            else:
                return self.getToken(DaxParser.AMPERSAND, i)

        def getRuleIndex(self):
            return DaxParser.RULE_additive

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAdditive"):
                listener.enterAdditive(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAdditive"):
                listener.exitAdditive(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAdditive"):
                return visitor.visitAdditive(self)
            else:
                return visitor.visitChildren(self)

    def additive(self):
        localctx = DaxParser.AdditiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_additive)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.multiplicative()
            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3F) == 0 and ((1 << _la) & 318767104) != 0:
                self.state = 111
                _la = self._input.LA(1)
                if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 318767104) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 112
                self.multiplicative()
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplicativeContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.UnaryContext)
            else:
                return self.getTypedRuleContext(DaxParser.UnaryContext, i)

        def ASTERISK(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.ASTERISK)
            else:
                return self.getToken(DaxParser.ASTERISK, i)

        def SLASH(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.SLASH)
            else:
                return self.getToken(DaxParser.SLASH, i)

        def getRuleIndex(self):
            return DaxParser.RULE_multiplicative

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMultiplicative"):
                listener.enterMultiplicative(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMultiplicative"):
                listener.exitMultiplicative(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMultiplicative"):
                return visitor.visitMultiplicative(self)
            else:
                return visitor.visitChildren(self)

    def multiplicative(self):
        localctx = DaxParser.MultiplicativeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_multiplicative)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.unary()
            self.state = 123
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 26 or _la == 27:
                self.state = 119
                _la = self._input.LA(1)
                if not (_la == 26 or _la == 27):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 120
                self.unary()
                self.state = 125
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary(self):
            return self.getTypedRuleContext(DaxParser.UnaryContext, 0)

        def PLUS(self):
            return self.getToken(DaxParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(DaxParser.MINUS, 0)

        def NOT_OP(self):
            return self.getToken(DaxParser.NOT_OP, 0)

        def primaryExpression(self):
            return self.getTypedRuleContext(DaxParser.PrimaryExpressionContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_unary

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnary"):
                listener.enterUnary(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnary"):
                listener.exitUnary(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnary"):
                return visitor.visitUnary(self)
            else:
                return visitor.visitChildren(self)

    def unary(self):
        localctx = DaxParser.UnaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_unary)
        self._la = 0  # Token type
        try:
            self.state = 129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16, 24, 25]:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                _la = self._input.LA(1)
                if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 50397184) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 127
                self.unary()
                pass
            elif token in [4, 5, 6, 7, 8, 11, 12, 13, 29, 31, 34, 35, 36, 37, 38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 128
                self.primaryExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(DaxParser.LiteralContext, 0)

        def columnReference(self):
            return self.getTypedRuleContext(DaxParser.ColumnReferenceContext, 0)

        def tableReference(self):
            return self.getTypedRuleContext(DaxParser.TableReferenceContext, 0)

        def functionCall(self):
            return self.getTypedRuleContext(DaxParser.FunctionCallContext, 0)

        def constructor(self):
            return self.getTypedRuleContext(DaxParser.ConstructorContext, 0)

        def OPEN_PAREN(self):
            return self.getToken(DaxParser.OPEN_PAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(DaxParser.ExpressionContext, 0)

        def CLOSE_PAREN(self):
            return self.getToken(DaxParser.CLOSE_PAREN, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_primaryExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimaryExpression"):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimaryExpression"):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimaryExpression"):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)

    def primaryExpression(self):
        localctx = DaxParser.PrimaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_primaryExpression)
        try:
            self.state = 140
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 12, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 131
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 132
                self.columnReference()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 133
                self.tableReference()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 134
                self.functionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 135
                self.constructor()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 136
                self.match(DaxParser.OPEN_PAREN)
                self.state = 137
                self.expression()
                self.state = 138
                self.match(DaxParser.CLOSE_PAREN)
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableExpressionContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(DaxParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_tableExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTableExpression"):
                listener.enterTableExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTableExpression"):
                listener.exitTableExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTableExpression"):
                return visitor.visitTableExpression(self)
            else:
                return visitor.visitChildren(self)

    def tableExpression(self):
        localctx = DaxParser.TableExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_tableExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionCallContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionName(self):
            return self.getTypedRuleContext(DaxParser.FunctionNameContext, 0)

        def OPEN_PAREN(self):
            return self.getToken(DaxParser.OPEN_PAREN, 0)

        def CLOSE_PAREN(self):
            return self.getToken(DaxParser.CLOSE_PAREN, 0)

        def argumentList(self):
            return self.getTypedRuleContext(DaxParser.ArgumentListContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_functionCall

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunctionCall"):
                listener.enterFunctionCall(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunctionCall"):
                listener.exitFunctionCall(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunctionCall"):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)

    def functionCall(self):
        localctx = DaxParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_functionCall)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.functionName()
            self.state = 145
            self.match(DaxParser.OPEN_PAREN)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((_la) & ~0x3F) == 0 and ((1 << _la) & 535310711792) != 0:
                self.state = 146
                self.argumentList()

            self.state = 149
            self.match(DaxParser.CLOSE_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionNameContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(DaxParser.IDENTIFIER, 0)

        def AND_KW(self):
            return self.getToken(DaxParser.AND_KW, 0)

        def OR_KW(self):
            return self.getToken(DaxParser.OR_KW, 0)

        def NOT_KW(self):
            return self.getToken(DaxParser.NOT_KW, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_functionName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunctionName"):
                listener.enterFunctionName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunctionName"):
                listener.exitFunctionName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunctionName"):
                return visitor.visitFunctionName(self)
            else:
                return visitor.visitChildren(self)

    def functionName(self):
        localctx = DaxParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_functionName)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            _la = self._input.LA(1)
            if not (((_la) & ~0x3F) == 0 and ((1 << _la) & 274877921280) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentListContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(DaxParser.ExpressionContext, i)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.COMMA)
            else:
                return self.getToken(DaxParser.COMMA, i)

        def getRuleIndex(self):
            return DaxParser.RULE_argumentList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterArgumentList"):
                listener.enterArgumentList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitArgumentList"):
                listener.exitArgumentList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitArgumentList"):
                return visitor.visitArgumentList(self)
            else:
                return visitor.visitChildren(self)

    def argumentList(self):
        localctx = DaxParser.ArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_argumentList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.expression()
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 33:
                self.state = 154
                self.match(DaxParser.COMMA)
                self.state = 155
                self.expression()
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ColumnReferenceContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BRACKET_ID(self):
            return self.getToken(DaxParser.BRACKET_ID, 0)

        def tableReference(self):
            return self.getTypedRuleContext(DaxParser.TableReferenceContext, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_columnReference

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterColumnReference"):
                listener.enterColumnReference(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitColumnReference"):
                listener.exitColumnReference(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitColumnReference"):
                return visitor.visitColumnReference(self)
            else:
                return visitor.visitChildren(self)

    def columnReference(self):
        localctx = DaxParser.ColumnReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_columnReference)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 35 or _la == 38:
                self.state = 161
                self.tableReference()

            self.state = 164
            self.match(DaxParser.BRACKET_ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableReferenceContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(DaxParser.IDENTIFIER, 0)

        def SINGLE_QUOTE_ID(self):
            return self.getToken(DaxParser.SINGLE_QUOTE_ID, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_tableReference

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTableReference"):
                listener.enterTableReference(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTableReference"):
                listener.exitTableReference(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTableReference"):
                return visitor.visitTableReference(self)
            else:
                return visitor.visitChildren(self)

    def tableReference(self):
        localctx = DaxParser.TableReferenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_tableReference)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            _la = self._input.LA(1)
            if not (_la == 35 or _la == 38):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(DaxParser.STRING_LITERAL, 0)

        def NUMBER(self):
            return self.getToken(DaxParser.NUMBER, 0)

        def TRUE(self):
            return self.getToken(DaxParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(DaxParser.FALSE, 0)

        def BLANK(self):
            return self.getToken(DaxParser.BLANK, 0)

        def OPEN_PAREN(self):
            return self.getToken(DaxParser.OPEN_PAREN, 0)

        def CLOSE_PAREN(self):
            return self.getToken(DaxParser.CLOSE_PAREN, 0)

        def ASC(self):
            return self.getToken(DaxParser.ASC, 0)

        def DESC(self):
            return self.getToken(DaxParser.DESC, 0)

        def getRuleIndex(self):
            return DaxParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):
        localctx = DaxParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_literal)
        try:
            self.state = 177
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 168
                self.match(DaxParser.STRING_LITERAL)
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 169
                self.match(DaxParser.NUMBER)
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 170
                self.match(DaxParser.TRUE)
                pass
            elif token in [7]:
                self.enterOuterAlt(localctx, 4)
                self.state = 171
                self.match(DaxParser.FALSE)
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 5)
                self.state = 172
                self.match(DaxParser.BLANK)
                self.state = 173
                self.match(DaxParser.OPEN_PAREN)
                self.state = 174
                self.match(DaxParser.CLOSE_PAREN)
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 6)
                self.state = 175
                self.match(DaxParser.ASC)
                pass
            elif token in [5]:
                self.enterOuterAlt(localctx, 7)
                self.state = 176
                self.match(DaxParser.DESC)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_CURLY(self):
            return self.getToken(DaxParser.OPEN_CURLY, 0)

        def constructorRow(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.ConstructorRowContext)
            else:
                return self.getTypedRuleContext(DaxParser.ConstructorRowContext, i)

        def CLOSE_CURLY(self):
            return self.getToken(DaxParser.CLOSE_CURLY, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.COMMA)
            else:
                return self.getToken(DaxParser.COMMA, i)

        def getRuleIndex(self):
            return DaxParser.RULE_constructor

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructor"):
                listener.enterConstructor(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructor"):
                listener.exitConstructor(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructor"):
                return visitor.visitConstructor(self)
            else:
                return visitor.visitChildren(self)

    def constructor(self):
        localctx = DaxParser.ConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_constructor)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(DaxParser.OPEN_CURLY)
            self.state = 180
            self.constructorRow()
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 33:
                self.state = 181
                self.match(DaxParser.COMMA)
                self.state = 182
                self.constructorRow()
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 188
            self.match(DaxParser.CLOSE_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorRowContext(ParserRuleContext):
        __slots__ = "parser"

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAREN(self):
            return self.getToken(DaxParser.OPEN_PAREN, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(DaxParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(DaxParser.ExpressionContext, i)

        def CLOSE_PAREN(self):
            return self.getToken(DaxParser.CLOSE_PAREN, 0)

        def COMMA(self, i: int = None):
            if i is None:
                return self.getTokens(DaxParser.COMMA)
            else:
                return self.getToken(DaxParser.COMMA, i)

        def getRuleIndex(self):
            return DaxParser.RULE_constructorRow

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorRow"):
                listener.enterConstructorRow(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorRow"):
                listener.exitConstructorRow(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorRow"):
                return visitor.visitConstructorRow(self)
            else:
                return visitor.visitChildren(self)

    def constructorRow(self):
        localctx = DaxParser.ConstructorRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_constructorRow)
        self._la = 0  # Token type
        try:
            self.state = 202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 19, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 190
                self.match(DaxParser.OPEN_PAREN)
                self.state = 191
                self.expression()
                self.state = 196
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 33:
                    self.state = 192
                    self.match(DaxParser.COMMA)
                    self.state = 193
                    self.expression()
                    self.state = 198
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 199
                self.match(DaxParser.CLOSE_PAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.expression()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
