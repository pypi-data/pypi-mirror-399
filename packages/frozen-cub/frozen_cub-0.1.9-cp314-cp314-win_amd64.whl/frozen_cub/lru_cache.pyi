from collections.abc import Hashable, Iterator

class LRUCache[K: Hashable, V]:
    def __init__(self, capacity: int, thread_safe: bool = False) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: K) -> bool: ...
    def __getitem__(self, key: K) -> V: ...
    def __setitem__(self, key: K, value: V) -> None: ...
    def __delitem__(self, key: K) -> None: ...
    def __iter__(self) -> Iterator[K]: ...
    @property
    def capacity(self) -> int: ...
    @property
    def head(self) -> K | None: ...
    @property
    def tail(self) -> K | None: ...
    def clear(self) -> None: ...
    def length(self) -> int: ...
    # Public API - accepts any hashable key, any value
    def has(self, key: K) -> bool: ...
    def get(self, key: K, default: V | None = None) -> V | None: ...
    def set(self, key: K, value: V) -> None: ...
    def delete(self, key: K) -> None: ...
    def pop(self, key: K, default: V | None = None) -> V: ...
    # Int API - for power users with pre-computed hashes
    def has_int(self, key: int) -> bool: ...
    def get_int(self, key: int, default: V | None = None) -> V: ...
    def set_int(self, key: int, value: V) -> None: ...
    def delete_int(self, key: int) -> None: ...
    def pop_int(self, key: int, default: V | None = None) -> V: ...
    # Iteration (keys are raw hashes, values are stored objects)
    def keys(self) -> list[K]: ...
    def values(self) -> list[V]: ...
    def items(self) -> list[tuple[K, V]]: ...
