from collections.abc import Callable, Hashable
from typing import Any, NoReturn

type NoReturnCall = Callable[..., NoReturn]

class BasicHashable:
    __frozen__: bool = ...
    cacheable: bool = ...

    clear: NoReturnCall = ...
    setdefault: NoReturnCall = ...
    popitem: NoReturnCall = ...
    update: NoReturnCall = ...
    pop: NoReturnCall = ...
    __setitem__: NoReturnCall = ...
    __delitem__: NoReturnCall = ...

    def __getitem__(self, *args) -> Any: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...

class HashableValues(BasicHashable):
    def __init__(
        self,
        values: list[Any] | None = None,
        op: Any | None = None,
        cacheable: bool = False,
    ) -> None: ...
    @classmethod
    def new(
        cls,
        item1: HashableValues,
        item2: HashableValues | None = None,
        cacheable: bool = False,
    ) -> HashableValues: ...
    def combine(self, other: HashableValues, cacheable: bool = False) -> HashableValues: ...

NOT_CACHABLE: HashableValues = ...

class CacheKey(BasicHashable):
    value1: Hashable
    value2: Hashable
    def __init__(self, v1: Hashable, v2: Hashable) -> None: ...

def get_cache_key(v1: Hashable, v2: Hashable) -> CacheKey: ...
def has_nested_dicts[K, V](obj: dict[K, V]) -> bool: ...
def none_to_null[K, V](data: dict[K, V]) -> dict[K, V]: ...
def null_to_none[K, V](data: dict[K, V]) -> dict[K, V]: ...
def filter_out_nones[K, V](data: dict[K, V]) -> dict[K, V]: ...
def check_conditions(conditions: tuple[Callable, ...], arg: object) -> bool: ...
