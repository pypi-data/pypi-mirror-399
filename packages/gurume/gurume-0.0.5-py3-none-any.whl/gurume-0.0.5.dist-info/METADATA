Metadata-Version: 2.4
Name: gurume
Version: 0.0.5
Author-email: narumi <toucans-cutouts0f@icloud.com>
License-File: LICENSE
Requires-Python: >=3.12
Requires-Dist: beautifulsoup4>=4.13.4
Requires-Dist: loguru>=0.7.3
Requires-Dist: lxml>=6.0.2
Requires-Dist: mcp[cli]>=1.13.0
Requires-Dist: openai>=2.14.0
Requires-Dist: tenacity>=9.1.2
Requires-Dist: textual>=6.11.0
Requires-Dist: typer>=0.16.0
Description-Content-Type: text/markdown

# Gurume

A Python library for searching restaurants on Tabelog using web scraping.

## Features

- **Comprehensive Search**: Search by area, keyword, cuisine type, date, time, party size, and more
- **Cuisine Type Filtering**: Accurate filtering by 45+ Japanese cuisine genres (ã™ãç„¼ã, å¯¿å¸, ãƒ©ãƒ¼ãƒ¡ãƒ³, etc.) (æ–°!)
- **Rich Data**: Extract restaurant details including ratings, reviews, prices, and availability
- **Interactive TUI**: Beautiful terminal UI for interactive restaurant search (æ–°!)
  - **Area Suggestion**: Smart area/station suggestions with F2 key (æ–°!)
  - **Intelligent Keyword Suggestion (F3)**: Context-aware suggestions - static cuisine list when empty, dynamic API results when typing (æ–°!)
  - **AI Natural Language Parsing (F4)**: Parse natural language queries with AI (æ–°!)
  - **Auto-Detection**: Automatically detects cuisine types in keyword input (æ–°!)
  - **Accurate Area Filtering**: Prefecture-level filtering for all 47 prefectures (æ–°!)
- **Async Support**: Both synchronous and asynchronous API
- **Type Safe**: Full type hints with type checking
- **Flexible**: Multiple search interfaces from simple to advanced
- **Easy to Use**: Simple and intuitive API


## Usage

### MCP Server (for Claude Desktop / AI Assistants)

The Gurume MCP server provides restaurant search functionality to AI assistants like Claude.

**GitHub (Latest Development Version)**:
```json
{
  "mcpServers": {
    "gurume": {
      "command": "uvx",
      "args": [
        "--from",
        "git+https://github.com/narumiruna/gurume",
        "gurume",
        "mcp"
      ]
    }
  }
}
```

**PyPI (Stable Release)**:
```json
{
  "mcpServers": {
    "gurume": {
      "command": "uvx",
      "args": ["gurume", "mcp"]
    }
  }
}
```

**Local Development**:
```json
{
  "mcpServers": {
    "gurume": {
      "command": "uv",
      "args": [
        "run",
        "--directory",
        "/home/<user>/workspace/gurume",
        "gurume",
        "mcp"
      ]
    }
  }
}
```

**Available Tools** (FastMCP-powered with automatic schema generation):

1. **`tabelog_search_restaurants`** - Search restaurants by area, keyword, or cuisine type
   - Parameters:
     - `area` (optional): Prefecture/city name (e.g., "æ±äº¬", "å¤§é˜ª", "ä¸‰é‡")
     - `keyword` (optional): Search keyword for restaurant names (e.g., "å’Œç”°é‡‘")
     - `cuisine` (optional): Precise cuisine filter (e.g., "ã™ãç„¼ã", "ç„¼è‚‰") - **RECOMMENDED** for cuisine searches
     - `sort` (optional): "ranking" | "review-count" | "new-open" | "standard" (default: "ranking")
     - `limit` (optional): Max results 1-60 (default: 20)
   - Returns: Array of `RestaurantOutput` with name, rating, reviews, area, genres, URL, prices
   - Annotations: `readOnly=true`, `openWorld=true`

2. **`tabelog_list_cuisines`** - Get all 45+ supported Japanese cuisine types
   - Parameters: None
   - Returns: Array of `CuisineOutput` with `{name, code}` for all supported cuisines
   - Annotations: `readOnly=true`, `idempotent=true`

3. **`tabelog_get_area_suggestions`** - Get area/station suggestions from Tabelog API
   - Parameters:
     - `query` (required): Area search query (e.g., "æ±äº¬", "æ¸‹è°·")
   - Returns: Array of `SuggestionOutput` with name, datatype, id, coordinates
   - Annotations: `readOnly=true`, `openWorld=true`

4. **`tabelog_get_keyword_suggestions`** - Get keyword/cuisine/restaurant suggestions from Tabelog API
   - Parameters:
     - `query` (required): Keyword search query (e.g., "ã™ã", "å¯¿å¸")
   - Returns: Array of `SuggestionOutput` with dynamic suggestions (cuisine types, restaurant names, combinations)
   - Annotations: `readOnly=true`, `openWorld=true`

**Recommended Workflow** (for best results):

```
ğŸ¯ STEP-BY-STEP APPROACH:

1. Validate area (if provided)
   â†’ tabelog_get_area_suggestions(query=user_area)
   â†’ Pick best match from suggestions

2. Validate cuisine/keyword (if provided)
   â†’ tabelog_get_keyword_suggestions(query=user_input)
   â†’ Check datatype: Genre2 (cuisine) or Restaurant (name)

3. Search with validated parameters
   â†’ tabelog_search_restaurants(area=validated, cuisine=validated)
```

**Usage Examples** (in Claude Desktop):

```
Example 1: Complete workflow
User: "Find sukiyaki in Tokyo"
Step 1: tabelog_get_area_suggestions(query="Tokyo")
        â†’ Returns [{"name": "æ±äº¬éƒ½", "datatype": "AddressMaster"}, ...]
Step 2: tabelog_get_keyword_suggestions(query="sukiyaki")
        â†’ Returns [{"name": "ã™ãç„¼ã", "datatype": "Genre2"}, ...]
Step 3: tabelog_search_restaurants(area="æ±äº¬éƒ½", cuisine="ã™ãç„¼ã", sort="ranking")
        â†’ Returns top sukiyaki restaurants in Tokyo

Example 2: Quick cuisine check
User: "What cuisine types can I search for?"
Claude: [Uses tabelog_list_cuisines to show all 45+ options]

Example 3: Area validation
User: "I want to search near Shibuya station"
Claude: [Uses tabelog_get_area_suggestions with query="æ¸‹è°·"]
        â†’ Shows options like "æ¸‹è°·åŒº", "æ¸‹è°·é§…" for user to choose
```

**Architecture** (SKILL.md compliant):
- âœ… **FastMCP Framework**: Automatic schema generation from type hints
- âœ… **Pydantic Output Schemas**: Type-safe structured responses
- âœ… **Tool Annotations**: Proper hints for LLM understanding (readOnly, idempotent, openWorld)
- âœ… **Comprehensive Error Handling**: Actionable error messages with next steps
- âœ… **Auto-Serialization**: Returns Pydantic models, framework handles JSON conversion

**Design Principles**:
- âœ… **Zero Configuration**: No API keys required
- âœ… **Type-Safe**: Full type hints with automatic validation
- âœ… **Simple Parameters**: Direct structured inputs (area, keyword, cuisine)
- âœ… **Client-Side NLP**: AI clients handle natural language parsing
- âœ… **Accurate Filtering**: Uses Tabelog genre codes for precise cuisine filtering
- âœ… **Read-Only Operations**: All tools are safe, non-destructive queries

**Testing the MCP Server**:
```bash
# Test if server starts correctly
uv run gurume mcp

# The server should start and wait for MCP protocol messages
# Press Ctrl+C to stop
```


## Installation

```bash
uv add gurume
```

Or with pip:

```bash
pip install gurume
```

## Quick Start

### Command Line Interface (CLI)

ä½¿ç”¨å‘½ä»¤åˆ—å¿«é€Ÿæœå°‹é¤å»³ï¼š

```bash
# åŸºæœ¬æœå°‹
gurume search --area æ±äº¬ --keyword å¯¿å¸

# ä½¿ç”¨æ–™ç†é¡åˆ¥ç²¾ç¢ºéæ¿¾
gurume search -a ä¸‰é‡ -c ã™ãç„¼ã

# æŒ‡å®šæ’åºæ–¹å¼å’Œè¼¸å‡ºæ ¼å¼
gurume search -a å¤§é˜ª -c ãƒ©ãƒ¼ãƒ¡ãƒ³ --sort ranking -o json

# ğŸ†• ä½¿ç”¨è‡ªç„¶èªè¨€æŸ¥è©¢ï¼ˆAI è‡ªå‹•è§£æåœ°å€å’Œé—œéµå­—ï¼‰
gurume search -q ä¸‰é‡ã™ãã‚„ã
gurume search -q "æˆ‘æƒ³åƒæ±äº¬çš„æ‹‰éºµ"
gurume search -q "sushi in Osaka"

# æŸ¥çœ‹æ‰€æœ‰æ”¯æ´çš„æ–™ç†é¡åˆ¥
gurume list-cuisines

# æŸ¥çœ‹å®Œæ•´èªªæ˜
gurume search --help
```

**CLI é¸é …ï¼š**
- `-a, --area`: æœå°‹åœ°å€ï¼ˆä¾‹å¦‚ï¼šæ±äº¬ã€å¤§é˜ªï¼‰
- `-k, --keyword`: é—œéµå­—ï¼ˆä¾‹å¦‚ï¼šå¯¿å¸ã€ãƒ©ãƒ¼ãƒ¡ãƒ³ï¼‰
- `-c, --cuisine`: æ–™ç†é¡åˆ¥ï¼ˆä¾‹å¦‚ï¼šã™ãç„¼ãã€ç„¼è‚‰ï¼‰- è‡ªå‹•ç²¾ç¢ºéæ¿¾
- `-q, --query`: ğŸ†• è‡ªç„¶èªè¨€æŸ¥è©¢ï¼ˆæœƒè‡ªå‹•è§£æåœ°å€å’Œé—œéµå­—ï¼Œæ”¯æ´å¤šèªè¨€ï¼‰
- `-s, --sort`: æ’åºæ–¹å¼ï¼ˆranking, review-count, new-open, standardï¼‰
- `-n, --limit`: é¡¯ç¤ºçµæœæ•¸é‡ï¼ˆé è¨­ï¼š20ï¼‰
- `-o, --output`: è¼¸å‡ºæ ¼å¼ï¼ˆtable, json, simpleï¼‰

**è‡ªç„¶èªè¨€æŸ¥è©¢åŠŸèƒ½ (-q):**
- âœ… æ”¯æ´å¤šèªè¨€è¼¸å…¥ï¼ˆä¸­æ–‡ã€æ—¥æ–‡ã€è‹±æ–‡ç­‰ï¼‰
- âœ… è‡ªå‹•è§£æåœ°å€å’Œæ–™ç†é¡å‹
- âœ… æ™ºæ…§å‹ç¿»è­¯ï¼ˆä¾‹å¦‚ï¼šã€Œå£½å–œç‡’ã€â†’ã€Œã™ãç„¼ãã€ï¼‰
- âš ï¸ éœ€è¦è¨­å®š OpenAI API é‡‘é‘°ï¼ˆ`.env` æª”æ¡ˆä¸­çš„ `OPENAI_API_KEY`ï¼‰

### Interactive TUI (æ¨è–¦!)

å•Ÿå‹•ç¾è§€çš„çµ‚ç«¯ä»‹é¢ä¾†æœå°‹é¤å»³ï¼š

```bash
# ä½¿ç”¨ uv
uv run gurume tui

# æˆ–ç›´æ¥ä½¿ç”¨ Python
python -m gurume.tui
```

TUI ç‰¹è‰²ï¼š
- ğŸ¨ ç°¡æ½”ç¾è§€çš„æ·±è‰²ä¸»é¡Œ
- ğŸ” å³æ™‚æœå°‹çµæœï¼ˆåœ°å€ã€é—œéµå­—ã€æ–™ç†é¡åˆ¥ã€æ’åºï¼‰
- ğŸ“Š é›™æ¬„å¼é¡¯ç¤ºï¼ˆçµæœåˆ—è¡¨ + è©³ç´°è³‡è¨Šï¼‰
- âŒ¨ï¸  å®Œæ•´éµç›¤å°èˆªæ”¯æ´
- ğŸš€ è‡ªå‹•å–æ¶ˆå‰æ¬¡æœå°‹ï¼Œé¿å…å¡ä½
- ğŸ—ºï¸ **æ™ºæ…§å‹åœ°å€å»ºè­°ï¼ˆF2ï¼‰**ï¼šè‡ªå‹•æä¾›éƒ½é“åºœç¸£ã€è»Šç«™ã€åœ°å€é¸é …
- ğŸ½ï¸ **æ™ºæ…§å‹é—œéµå­—å»ºè­°ï¼ˆF3ï¼‰**ï¼ˆæ–°ï¼ï¼‰ï¼š
  - é—œéµå­—ç‚ºç©º â†’ é¡¯ç¤º 45+ ç¨®æ–™ç†é¡åˆ¥åˆ—è¡¨ï¼ˆã™ãç„¼ãã€å¯¿å¸ã€ãƒ©ãƒ¼ãƒ¡ãƒ³ç­‰ï¼‰
  - é—œéµå­—æœ‰å…§å®¹ â†’ å‘¼å« API æä¾›å‹•æ…‹å»ºè­°ï¼ˆæ–™ç†é¡å‹ã€é¤å»³åç¨±ã€çµ„åˆé—œéµå­—ï¼‰
- ğŸ¤– **AI è‡ªç„¶èªè¨€è§£æï¼ˆF4ï¼‰**ï¼šè¼¸å…¥è‡ªç„¶èªè¨€ï¼ˆä¾‹å¦‚ï¼šä¸‰é‡çš„ã™ãç„¼ãï¼‰ï¼Œè‡ªå‹•è§£æä¸¦è§¸ç™¼å»ºè­°
- âœ¨ **æ™ºæ…§è¯å‹•**ï¼šAI è§£æå¾Œè‡ªå‹•è§¸ç™¼åœ°å€å»ºè­°ï¼ˆF2ï¼‰æˆ–æ–™ç†é¸æ“‡ï¼ˆF3ï¼‰
- ğŸ¯ **è‡ªå‹•æ–™ç†è­˜åˆ¥**ï¼šåœ¨é—œéµå­—æ¬„ä½è¼¸å…¥æ–™ç†åç¨±ï¼Œè‡ªå‹•è½‰æ›ç‚ºç²¾ç¢ºéæ¿¾
- âœ… **æº–ç¢ºåœ°å€éæ¿¾**ï¼šæ”¯æ´ 47 å€‹éƒ½é“åºœç¸£çš„åœ°å€é™åˆ¶

è©³ç´°ä½¿ç”¨èªªæ˜è«‹åƒè€ƒ [TUI_USAGE.md](TUI_USAGE.md)

### Basic Search (ç¨‹å¼åº«)

```python
from gurume import query_restaurants, SortType, get_genre_code

# Quick search with keyword
restaurants = query_restaurants(
    area="éŠ€åº§",
    keyword="å¯¿å¸",
    party_size=2,
    sort_type=SortType.RANKING,
)

for restaurant in restaurants:
    print(f"{restaurant.name} - {restaurant.rating}")

# Search with cuisine type filtering (æ›´ç²¾ç¢º!)
from gurume import RestaurantSearchRequest

genre_code = get_genre_code("ã™ãç„¼ã")  # RC0107
request = RestaurantSearchRequest(
    area="ä¸‰é‡",
    genre_code=genre_code,
    sort_type=SortType.RANKING,
)

restaurants = request.search_sync()
for restaurant in restaurants:
    print(f"{restaurant.name} - {restaurant.rating}")
    print(f"  é¡å‹: {', '.join(restaurant.genres)}")
```

### Advanced Search

```python
from gurume import RestaurantSearchRequest, SortType, PriceRange, get_genre_code

# Detailed search with filters
request = RestaurantSearchRequest(
    area="æ¸‹è°·",
    keyword="ç„¼è‚‰",
    genre_code=get_genre_code("ç„¼è‚‰"),  # ç²¾ç¢ºéæ¿¾ç„¼è‚‰å°ˆé–€åº—
    reservation_date="20250715",
    reservation_time="1900",
    party_size=4,
    sort_type=SortType.RANKING,
    price_range=PriceRange.DINNER_4000_5000,
    online_booking_only=True,
    has_private_room=True,
)

restaurants = request.search_sync()

# ç€è¦½æ‰€æœ‰æ”¯æ´çš„æ–™ç†é¡åˆ¥
from gurume import get_all_genres

all_genres = get_all_genres()
print(f"æ”¯æ´ {len(all_genres)} ç¨®æ–™ç†é¡åˆ¥:")
print(all_genres)
# ['ã†ã©ã‚“', 'ã†ãªã', 'ã™ãç„¼ã', 'ãã°', 'ã¨ã‚“ã‹ã¤', ...]
```

### Async Search with Metadata

```python
import asyncio
from gurume import SearchRequest, get_genre_code

async def search_example():
    request = SearchRequest(
        area="æ–°å®¿",
        keyword="å±…é…’å±‹",
        genre_code=get_genre_code("å±…é…’å±‹"),  # ç²¾ç¢ºéæ¿¾å±…é…’å±‹
        max_pages=3,
        include_meta=True,
    )

    response = await request.search()

    print(f"Status: {response.status}")
    print(f"Total results: {response.meta.total_count}")
    print(f"Found {len(response.restaurants)} restaurants")

    for restaurant in response.restaurants:
        print(f"- {restaurant.name} ({restaurant.rating})")
        print(f"  é¡å‹: {', '.join(restaurant.genres)}")

asyncio.run(search_example())
```

## Examples

See the `examples/` directory for more detailed examples:

- `basic_search.py`: Basic usage examples
- `cli_example.py`: Command-line interface example

## Important Notes

Legal Compliance: This library is for educational and research purposes. Make sure to:
- Respect Tabelog's robots.txt and terms of service
- Don't make excessive requests that could overload their servers
- Consider rate limiting in production use
- Use responsibly and ethically

Web Scraping: This library scrapes Tabelog's web interface. The structure may change without notice, which could break functionality.

## License

MIT License

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
