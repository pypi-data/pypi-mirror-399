# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ProjectApplicationsArgs',
    'ProjectApplicationsArgsDict',
    'ProjectApplicationsOidcApplicationArgs',
    'ProjectApplicationsOidcApplicationArgsDict',
    'ProjectApplicationsSamlApplicationArgs',
    'ProjectApplicationsSamlApplicationArgsDict',
    'ProjectApplicationsSamlApplicationAttributeMappingArgs',
    'ProjectApplicationsSamlApplicationAttributeMappingArgsDict',
    'ProjectApplicationsSamlApplicationDynamicConfigurationArgs',
    'ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict',
    'ProjectApplicationsSamlApplicationManualConfigurationArgs',
    'ProjectApplicationsSamlApplicationManualConfigurationArgsDict',
    'ProjectAttributesArgs',
    'ProjectAttributesArgsDict',
    'ProjectAttributesTenantArgs',
    'ProjectAttributesTenantArgsDict',
    'ProjectAttributesTenantAuthorizationArgs',
    'ProjectAttributesTenantAuthorizationArgsDict',
    'ProjectAttributesUserArgs',
    'ProjectAttributesUserArgsDict',
    'ProjectAttributesUserWidgetAuthorizationArgs',
    'ProjectAttributesUserWidgetAuthorizationArgsDict',
    'ProjectAuthenticationArgs',
    'ProjectAuthenticationArgsDict',
    'ProjectAuthenticationEmbeddedLinkArgs',
    'ProjectAuthenticationEmbeddedLinkArgsDict',
    'ProjectAuthenticationEnchantedLinkArgs',
    'ProjectAuthenticationEnchantedLinkArgsDict',
    'ProjectAuthenticationEnchantedLinkEmailServiceArgs',
    'ProjectAuthenticationEnchantedLinkEmailServiceArgsDict',
    'ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs',
    'ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict',
    'ProjectAuthenticationMagicLinkArgs',
    'ProjectAuthenticationMagicLinkArgsDict',
    'ProjectAuthenticationMagicLinkEmailServiceArgs',
    'ProjectAuthenticationMagicLinkEmailServiceArgsDict',
    'ProjectAuthenticationMagicLinkEmailServiceTemplateArgs',
    'ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict',
    'ProjectAuthenticationMagicLinkTextServiceArgs',
    'ProjectAuthenticationMagicLinkTextServiceArgsDict',
    'ProjectAuthenticationMagicLinkTextServiceTemplateArgs',
    'ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict',
    'ProjectAuthenticationOauthArgs',
    'ProjectAuthenticationOauthArgsDict',
    'ProjectAuthenticationOauthCustomArgs',
    'ProjectAuthenticationOauthCustomArgsDict',
    'ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthCustomAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthCustomProviderTokenManagementArgs',
    'ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemArgs',
    'ProjectAuthenticationOauthSystemArgsDict',
    'ProjectAuthenticationOauthSystemAppleArgs',
    'ProjectAuthenticationOauthSystemAppleArgsDict',
    'ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemDiscordArgs',
    'ProjectAuthenticationOauthSystemDiscordArgsDict',
    'ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemFacebookArgs',
    'ProjectAuthenticationOauthSystemFacebookArgsDict',
    'ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGithubArgs',
    'ProjectAuthenticationOauthSystemGithubArgsDict',
    'ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGitlabArgs',
    'ProjectAuthenticationOauthSystemGitlabArgsDict',
    'ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemGoogleArgs',
    'ProjectAuthenticationOauthSystemGoogleArgsDict',
    'ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinArgs',
    'ProjectAuthenticationOauthSystemLinkedinArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftArgs',
    'ProjectAuthenticationOauthSystemMicrosoftArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict',
    'ProjectAuthenticationOauthSystemSlackArgs',
    'ProjectAuthenticationOauthSystemSlackArgsDict',
    'ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs',
    'ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgsDict',
    'ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs',
    'ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict',
    'ProjectAuthenticationOtpArgs',
    'ProjectAuthenticationOtpArgsDict',
    'ProjectAuthenticationOtpEmailServiceArgs',
    'ProjectAuthenticationOtpEmailServiceArgsDict',
    'ProjectAuthenticationOtpEmailServiceTemplateArgs',
    'ProjectAuthenticationOtpEmailServiceTemplateArgsDict',
    'ProjectAuthenticationOtpTextServiceArgs',
    'ProjectAuthenticationOtpTextServiceArgsDict',
    'ProjectAuthenticationOtpTextServiceTemplateArgs',
    'ProjectAuthenticationOtpTextServiceTemplateArgsDict',
    'ProjectAuthenticationOtpVoiceServiceArgs',
    'ProjectAuthenticationOtpVoiceServiceArgsDict',
    'ProjectAuthenticationOtpVoiceServiceTemplateArgs',
    'ProjectAuthenticationOtpVoiceServiceTemplateArgsDict',
    'ProjectAuthenticationPasskeysArgs',
    'ProjectAuthenticationPasskeysArgsDict',
    'ProjectAuthenticationPasswordArgs',
    'ProjectAuthenticationPasswordArgsDict',
    'ProjectAuthenticationPasswordEmailServiceArgs',
    'ProjectAuthenticationPasswordEmailServiceArgsDict',
    'ProjectAuthenticationPasswordEmailServiceTemplateArgs',
    'ProjectAuthenticationPasswordEmailServiceTemplateArgsDict',
    'ProjectAuthenticationSsoArgs',
    'ProjectAuthenticationSsoArgsDict',
    'ProjectAuthenticationSsoSsoSuiteSettingsArgs',
    'ProjectAuthenticationSsoSsoSuiteSettingsArgsDict',
    'ProjectAuthenticationTotpArgs',
    'ProjectAuthenticationTotpArgsDict',
    'ProjectAuthorizationArgs',
    'ProjectAuthorizationArgsDict',
    'ProjectAuthorizationPermissionArgs',
    'ProjectAuthorizationPermissionArgsDict',
    'ProjectAuthorizationRoleArgs',
    'ProjectAuthorizationRoleArgsDict',
    'ProjectConnectorsArgs',
    'ProjectConnectorsArgsDict',
    'ProjectConnectorsAbuseipdbArgs',
    'ProjectConnectorsAbuseipdbArgsDict',
    'ProjectConnectorsAmplitudeArgs',
    'ProjectConnectorsAmplitudeArgsDict',
    'ProjectConnectorsAuditWebhookArgs',
    'ProjectConnectorsAuditWebhookArgsDict',
    'ProjectConnectorsAuditWebhookAuditFilterArgs',
    'ProjectConnectorsAuditWebhookAuditFilterArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationArgs',
    'ProjectConnectorsAuditWebhookAuthenticationArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs',
    'ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict',
    'ProjectConnectorsAuditWebhookAuthenticationBasicArgs',
    'ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict',
    'ProjectConnectorsAwsS3Args',
    'ProjectConnectorsAwsS3ArgsDict',
    'ProjectConnectorsAwsS3AuditFilterArgs',
    'ProjectConnectorsAwsS3AuditFilterArgsDict',
    'ProjectConnectorsAwsTranslateArgs',
    'ProjectConnectorsAwsTranslateArgsDict',
    'ProjectConnectorsBitsightArgs',
    'ProjectConnectorsBitsightArgsDict',
    'ProjectConnectorsDatadogArgs',
    'ProjectConnectorsDatadogArgsDict',
    'ProjectConnectorsDatadogAuditFilterArgs',
    'ProjectConnectorsDatadogAuditFilterArgsDict',
    'ProjectConnectorsDevrevGrowArgs',
    'ProjectConnectorsDevrevGrowArgsDict',
    'ProjectConnectorsDoceboArgs',
    'ProjectConnectorsDoceboArgsDict',
    'ProjectConnectorsEightByEightViberArgs',
    'ProjectConnectorsEightByEightViberArgsDict',
    'ProjectConnectorsEightByEightWhatsappArgs',
    'ProjectConnectorsEightByEightWhatsappArgsDict',
    'ProjectConnectorsElephantArgs',
    'ProjectConnectorsElephantArgsDict',
    'ProjectConnectorsExternalTokenHttpArgs',
    'ProjectConnectorsExternalTokenHttpArgsDict',
    'ProjectConnectorsExternalTokenHttpAuthenticationArgs',
    'ProjectConnectorsExternalTokenHttpAuthenticationArgsDict',
    'ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs',
    'ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgsDict',
    'ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs',
    'ProjectConnectorsExternalTokenHttpAuthenticationBasicArgsDict',
    'ProjectConnectorsFingerprintArgs',
    'ProjectConnectorsFingerprintArgsDict',
    'ProjectConnectorsFingerprintDescopeArgs',
    'ProjectConnectorsFingerprintDescopeArgsDict',
    'ProjectConnectorsFirebaseAdminArgs',
    'ProjectConnectorsFirebaseAdminArgsDict',
    'ProjectConnectorsForterArgs',
    'ProjectConnectorsForterArgsDict',
    'ProjectConnectorsGenericEmailGatewayArgs',
    'ProjectConnectorsGenericEmailGatewayArgsDict',
    'ProjectConnectorsGenericEmailGatewayAuthenticationArgs',
    'ProjectConnectorsGenericEmailGatewayAuthenticationArgsDict',
    'ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs',
    'ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgsDict',
    'ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs',
    'ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgsDict',
    'ProjectConnectorsGenericSmsGatewayArgs',
    'ProjectConnectorsGenericSmsGatewayArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict',
    'ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs',
    'ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict',
    'ProjectConnectorsGoogleCloudLoggingArgs',
    'ProjectConnectorsGoogleCloudLoggingArgsDict',
    'ProjectConnectorsGoogleCloudLoggingAuditFilterArgs',
    'ProjectConnectorsGoogleCloudLoggingAuditFilterArgsDict',
    'ProjectConnectorsGoogleCloudTranslationArgs',
    'ProjectConnectorsGoogleCloudTranslationArgsDict',
    'ProjectConnectorsGoogleMapsPlaceArgs',
    'ProjectConnectorsGoogleMapsPlaceArgsDict',
    'ProjectConnectorsHibpArgs',
    'ProjectConnectorsHibpArgsDict',
    'ProjectConnectorsHttpArgs',
    'ProjectConnectorsHttpArgsDict',
    'ProjectConnectorsHttpAuthenticationArgs',
    'ProjectConnectorsHttpAuthenticationArgsDict',
    'ProjectConnectorsHttpAuthenticationApiKeyArgs',
    'ProjectConnectorsHttpAuthenticationApiKeyArgsDict',
    'ProjectConnectorsHttpAuthenticationBasicArgs',
    'ProjectConnectorsHttpAuthenticationBasicArgsDict',
    'ProjectConnectorsHubspotArgs',
    'ProjectConnectorsHubspotArgsDict',
    'ProjectConnectorsIncodeArgs',
    'ProjectConnectorsIncodeArgsDict',
    'ProjectConnectorsIntercomArgs',
    'ProjectConnectorsIntercomArgsDict',
    'ProjectConnectorsLokaliseArgs',
    'ProjectConnectorsLokaliseArgsDict',
    'ProjectConnectorsMparticleArgs',
    'ProjectConnectorsMparticleArgsDict',
    'ProjectConnectorsNewrelicArgs',
    'ProjectConnectorsNewrelicArgsDict',
    'ProjectConnectorsNewrelicAuditFilterArgs',
    'ProjectConnectorsNewrelicAuditFilterArgsDict',
    'ProjectConnectorsRadarArgs',
    'ProjectConnectorsRadarArgsDict',
    'ProjectConnectorsRecaptchaArgs',
    'ProjectConnectorsRecaptchaArgsDict',
    'ProjectConnectorsRecaptchaEnterpriseArgs',
    'ProjectConnectorsRecaptchaEnterpriseArgsDict',
    'ProjectConnectorsRekognitionArgs',
    'ProjectConnectorsRekognitionArgsDict',
    'ProjectConnectorsSalesforceArgs',
    'ProjectConnectorsSalesforceArgsDict',
    'ProjectConnectorsSalesforceMarketingCloudArgs',
    'ProjectConnectorsSalesforceMarketingCloudArgsDict',
    'ProjectConnectorsSardineArgs',
    'ProjectConnectorsSardineArgsDict',
    'ProjectConnectorsSeArgs',
    'ProjectConnectorsSeArgsDict',
    'ProjectConnectorsSeSenderArgs',
    'ProjectConnectorsSeSenderArgsDict',
    'ProjectConnectorsSegmentArgs',
    'ProjectConnectorsSegmentArgsDict',
    'ProjectConnectorsSendgridArgs',
    'ProjectConnectorsSendgridArgsDict',
    'ProjectConnectorsSendgridAuthenticationArgs',
    'ProjectConnectorsSendgridAuthenticationArgsDict',
    'ProjectConnectorsSendgridSenderArgs',
    'ProjectConnectorsSendgridSenderArgsDict',
    'ProjectConnectorsSlackArgs',
    'ProjectConnectorsSlackArgsDict',
    'ProjectConnectorsSmartlingArgs',
    'ProjectConnectorsSmartlingArgsDict',
    'ProjectConnectorsSmtpArgs',
    'ProjectConnectorsSmtpArgsDict',
    'ProjectConnectorsSmtpAuthenticationArgs',
    'ProjectConnectorsSmtpAuthenticationArgsDict',
    'ProjectConnectorsSmtpSenderArgs',
    'ProjectConnectorsSmtpSenderArgsDict',
    'ProjectConnectorsSmtpServerArgs',
    'ProjectConnectorsSmtpServerArgsDict',
    'ProjectConnectorsSnArgs',
    'ProjectConnectorsSnArgsDict',
    'ProjectConnectorsSumologicArgs',
    'ProjectConnectorsSumologicArgsDict',
    'ProjectConnectorsSumologicAuditFilterArgs',
    'ProjectConnectorsSumologicAuditFilterArgsDict',
    'ProjectConnectorsSupabaseArgs',
    'ProjectConnectorsSupabaseArgsDict',
    'ProjectConnectorsTelesignArgs',
    'ProjectConnectorsTelesignArgsDict',
    'ProjectConnectorsTraceableArgs',
    'ProjectConnectorsTraceableArgsDict',
    'ProjectConnectorsTurnstileArgs',
    'ProjectConnectorsTurnstileArgsDict',
    'ProjectConnectorsTwilioCoreArgs',
    'ProjectConnectorsTwilioCoreArgsDict',
    'ProjectConnectorsTwilioCoreAuthenticationArgs',
    'ProjectConnectorsTwilioCoreAuthenticationArgsDict',
    'ProjectConnectorsTwilioCoreSendersArgs',
    'ProjectConnectorsTwilioCoreSendersArgsDict',
    'ProjectConnectorsTwilioCoreSendersSmsArgs',
    'ProjectConnectorsTwilioCoreSendersSmsArgsDict',
    'ProjectConnectorsTwilioCoreSendersVoiceArgs',
    'ProjectConnectorsTwilioCoreSendersVoiceArgsDict',
    'ProjectConnectorsTwilioVerifyArgs',
    'ProjectConnectorsTwilioVerifyArgsDict',
    'ProjectConnectorsTwilioVerifyAuthenticationArgs',
    'ProjectConnectorsTwilioVerifyAuthenticationArgsDict',
    'ProjectFlowsArgs',
    'ProjectFlowsArgsDict',
    'ProjectInviteSettingsArgs',
    'ProjectInviteSettingsArgsDict',
    'ProjectInviteSettingsEmailServiceArgs',
    'ProjectInviteSettingsEmailServiceArgsDict',
    'ProjectInviteSettingsEmailServiceTemplateArgs',
    'ProjectInviteSettingsEmailServiceTemplateArgsDict',
    'ProjectJwtTemplatesArgs',
    'ProjectJwtTemplatesArgsDict',
    'ProjectJwtTemplatesAccessKeyTemplateArgs',
    'ProjectJwtTemplatesAccessKeyTemplateArgsDict',
    'ProjectJwtTemplatesUserTemplateArgs',
    'ProjectJwtTemplatesUserTemplateArgsDict',
    'ProjectListArgs',
    'ProjectListArgsDict',
    'ProjectProjectSettingsArgs',
    'ProjectProjectSettingsArgsDict',
    'ProjectProjectSettingsSessionMigrationArgs',
    'ProjectProjectSettingsSessionMigrationArgsDict',
    'ProjectStylesArgs',
    'ProjectStylesArgsDict',
    'ProjectWidgetsArgs',
    'ProjectWidgetsArgsDict',
]

MYPY = False

if not MYPY:
    class ProjectApplicationsArgsDict(TypedDict):
        oidc_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgsDict']]]]
        """
        Applications using OpenID Connect (OIDC) for authentication.
        """
        saml_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgsDict']]]]
        """
        Applications using SAML for authentication.
        """
elif False:
    ProjectApplicationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsArgs:
    def __init__(__self__, *,
                 oidc_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]] = None,
                 saml_applications: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]] oidc_applications: Applications using OpenID Connect (OIDC) for authentication.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]] saml_applications: Applications using SAML for authentication.
        """
        if oidc_applications is not None:
            pulumi.set(__self__, "oidc_applications", oidc_applications)
        if saml_applications is not None:
            pulumi.set(__self__, "saml_applications", saml_applications)

    @_builtins.property
    @pulumi.getter(name="oidcApplications")
    def oidc_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]]:
        """
        Applications using OpenID Connect (OIDC) for authentication.
        """
        return pulumi.get(self, "oidc_applications")

    @oidc_applications.setter
    def oidc_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsOidcApplicationArgs']]]]):
        pulumi.set(self, "oidc_applications", value)

    @_builtins.property
    @pulumi.getter(name="samlApplications")
    def saml_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]]:
        """
        Applications using SAML for authentication.
        """
        return pulumi.get(self, "saml_applications")

    @saml_applications.setter
    def saml_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationArgs']]]]):
        pulumi.set(self, "saml_applications", value)


if not MYPY:
    class ProjectApplicationsOidcApplicationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the OIDC application.
        """
        claims: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of supported claims. e.g. `sub`, `email`, `exp`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the OIDC application.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the application should be enabled or disabled.
        """
        force_authentication: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional identifier for the OIDC application.
        """
        login_page_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        A logo for the OIDC application. Should be a hosted image URL.
        """
elif False:
    ProjectApplicationsOidcApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsOidcApplicationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 claims: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 force_authentication: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 login_page_url: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the OIDC application.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] claims: A list of supported claims. e.g. `sub`, `email`, `exp`.
        :param pulumi.Input[_builtins.str] description: A description for the OIDC application.
        :param pulumi.Input[_builtins.bool] disabled: Whether the application should be enabled or disabled.
        :param pulumi.Input[_builtins.bool] force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param pulumi.Input[_builtins.str] id: An optional identifier for the OIDC application.
        :param pulumi.Input[_builtins.str] login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[_builtins.str] logo: A logo for the OIDC application. Should be a hosted image URL.
        """
        pulumi.set(__self__, "name", name)
        if claims is not None:
            pulumi.set(__self__, "claims", claims)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the OIDC application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of supported claims. e.g. `sub`, `email`, `exp`.
        """
        return pulumi.get(self, "claims")

    @claims.setter
    def claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claims", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the OIDC application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @force_authentication.setter
    def force_authentication(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_authentication", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional identifier for the OIDC application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @login_page_url.setter
    def login_page_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_page_url", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A logo for the OIDC application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the SAML application.
        """
        acs_allowed_callback_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        """
        attribute_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgsDict']]]]
        """
        The `AttributeMapping` object. Read the description below.
        """
        default_relay_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the SAML application.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the application should be enabled or disabled.
        """
        dynamic_configuration: NotRequired[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict']]
        """
        The `DynamicConfiguration` object. Read the description below.
        """
        force_authentication: NotRequired[pulumi.Input[_builtins.bool]]
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional identifier for the SAML application.
        """
        login_page_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        A logo for the SAML application. Should be a hosted image URL.
        """
        manual_configuration: NotRequired[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgsDict']]
        """
        The `ManualConfiguration` object. Read the description below.
        """
        subject_name_id_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        subject_name_id_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
elif False:
    ProjectApplicationsSamlApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 acs_allowed_callback_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]] = None,
                 default_relay_state: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 dynamic_configuration: Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']] = None,
                 force_authentication: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 login_page_url: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manual_configuration: Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']] = None,
                 subject_name_id_format: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_name_id_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the SAML application.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] acs_allowed_callback_urls: A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]] attribute_mappings: The `AttributeMapping` object. Read the description below.
        :param pulumi.Input[_builtins.str] default_relay_state: The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        :param pulumi.Input[_builtins.str] description: A description for the SAML application.
        :param pulumi.Input[_builtins.bool] disabled: Whether the application should be enabled or disabled.
        :param pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs'] dynamic_configuration: The `DynamicConfiguration` object. Read the description below.
        :param pulumi.Input[_builtins.bool] force_authentication: This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        :param pulumi.Input[_builtins.str] id: An optional identifier for the SAML application.
        :param pulumi.Input[_builtins.str] login_page_url: The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[_builtins.str] logo: A logo for the SAML application. Should be a hosted image URL.
        :param pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs'] manual_configuration: The `ManualConfiguration` object. Read the description below.
        :param pulumi.Input[_builtins.str] subject_name_id_format: The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        :param pulumi.Input[_builtins.str] subject_name_id_type: The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        pulumi.set(__self__, "name", name)
        if acs_allowed_callback_urls is not None:
            pulumi.set(__self__, "acs_allowed_callback_urls", acs_allowed_callback_urls)
        if attribute_mappings is not None:
            pulumi.set(__self__, "attribute_mappings", attribute_mappings)
        if default_relay_state is not None:
            pulumi.set(__self__, "default_relay_state", default_relay_state)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic_configuration is not None:
            pulumi.set(__self__, "dynamic_configuration", dynamic_configuration)
        if force_authentication is not None:
            pulumi.set(__self__, "force_authentication", force_authentication)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if login_page_url is not None:
            pulumi.set(__self__, "login_page_url", login_page_url)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manual_configuration is not None:
            pulumi.set(__self__, "manual_configuration", manual_configuration)
        if subject_name_id_format is not None:
            pulumi.set(__self__, "subject_name_id_format", subject_name_id_format)
        if subject_name_id_type is not None:
            pulumi.set(__self__, "subject_name_id_type", subject_name_id_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the SAML application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="acsAllowedCallbackUrls")
    def acs_allowed_callback_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of allowed ACS callback URLS. This configuration is used when the default ACS URL value is unreachable. Supports wildcards.
        """
        return pulumi.get(self, "acs_allowed_callback_urls")

    @acs_allowed_callback_urls.setter
    def acs_allowed_callback_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "acs_allowed_callback_urls", value)

    @_builtins.property
    @pulumi.getter(name="attributeMappings")
    def attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]]:
        """
        The `AttributeMapping` object. Read the description below.
        """
        return pulumi.get(self, "attribute_mappings")

    @attribute_mappings.setter
    def attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectApplicationsSamlApplicationAttributeMappingArgs']]]]):
        pulumi.set(self, "attribute_mappings", value)

    @_builtins.property
    @pulumi.getter(name="defaultRelayState")
    def default_relay_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default relay state. When using IdP-initiated authentication, this value may be used as a URL to a resource in the Service Provider.
        """
        return pulumi.get(self, "default_relay_state")

    @default_relay_state.setter
    def default_relay_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_relay_state", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the SAML application.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the application should be enabled or disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="dynamicConfiguration")
    def dynamic_configuration(self) -> Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']]:
        """
        The `DynamicConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "dynamic_configuration")

    @dynamic_configuration.setter
    def dynamic_configuration(self, value: Optional[pulumi.Input['ProjectApplicationsSamlApplicationDynamicConfigurationArgs']]):
        pulumi.set(self, "dynamic_configuration", value)

    @_builtins.property
    @pulumi.getter(name="forceAuthentication")
    def force_authentication(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        This configuration overrides the default behavior of the SSO application and forces the user to authenticate via the Descope flow, regardless of the SP's request.
        """
        return pulumi.get(self, "force_authentication")

    @force_authentication.setter
    def force_authentication(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_authentication", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional identifier for the SAML application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="loginPageUrl")
    def login_page_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Flow Hosting URL. Read more about using this parameter with custom domain [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "login_page_url")

    @login_page_url.setter
    def login_page_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_page_url", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A logo for the SAML application. Should be a hosted image URL.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manualConfiguration")
    def manual_configuration(self) -> Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']]:
        """
        The `ManualConfiguration` object. Read the description below.
        """
        return pulumi.get(self, "manual_configuration")

    @manual_configuration.setter
    def manual_configuration(self, value: Optional[pulumi.Input['ProjectApplicationsSamlApplicationManualConfigurationArgs']]):
        pulumi.set(self, "manual_configuration", value)

    @_builtins.property
    @pulumi.getter(name="subjectNameIdFormat")
    def subject_name_id_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject name id format. Choose one of "", "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified", "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress", "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent", "urn:oasis:names:tc:SAML:2.0:nameid-format:transient". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_format")

    @subject_name_id_format.setter
    def subject_name_id_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_name_id_format", value)

    @_builtins.property
    @pulumi.getter(name="subjectNameIdType")
    def subject_name_id_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject name id type. Choose one of "", "email", "phone". Read more about this configuration [here](https://docs.descope.com/sso-integrations/applications/saml-apps).
        """
        return pulumi.get(self, "subject_name_id_type")

    @subject_name_id_type.setter
    def subject_name_id_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_name_id_type", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationAttributeMappingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the attribute.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the attribute.
        """
elif False:
    ProjectApplicationsSamlApplicationAttributeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationAttributeMappingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the attribute.
        :param pulumi.Input[_builtins.str] value: The value of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict(TypedDict):
        metadata_url: pulumi.Input[_builtins.str]
        """
        The metadata URL when retrieving the connection details dynamically.
        """
elif False:
    ProjectApplicationsSamlApplicationDynamicConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationDynamicConfigurationArgs:
    def __init__(__self__, *,
                 metadata_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] metadata_url: The metadata URL when retrieving the connection details dynamically.
        """
        pulumi.set(__self__, "metadata_url", metadata_url)

    @_builtins.property
    @pulumi.getter(name="metadataUrl")
    def metadata_url(self) -> pulumi.Input[_builtins.str]:
        """
        The metadata URL when retrieving the connection details dynamically.
        """
        return pulumi.get(self, "metadata_url")

    @metadata_url.setter
    def metadata_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_url", value)


if not MYPY:
    class ProjectApplicationsSamlApplicationManualConfigurationArgsDict(TypedDict):
        acs_url: pulumi.Input[_builtins.str]
        """
        Enter the `ACS URL` from the SP.
        """
        entity_id: pulumi.Input[_builtins.str]
        """
        Enter the `Entity Id` from the SP.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enter the `Certificate` from the SP.
        """
elif False:
    ProjectApplicationsSamlApplicationManualConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApplicationsSamlApplicationManualConfigurationArgs:
    def __init__(__self__, *,
                 acs_url: pulumi.Input[_builtins.str],
                 entity_id: pulumi.Input[_builtins.str],
                 certificate: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] acs_url: Enter the `ACS URL` from the SP.
        :param pulumi.Input[_builtins.str] entity_id: Enter the `Entity Id` from the SP.
        :param pulumi.Input[_builtins.str] certificate: Enter the `Certificate` from the SP.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "entity_id", entity_id)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)

    @_builtins.property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the `ACS URL` from the SP.
        """
        return pulumi.get(self, "acs_url")

    @acs_url.setter
    def acs_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "acs_url", value)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[_builtins.str]:
        """
        Enter the `Entity Id` from the SP.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entity_id", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enter the `Certificate` from the SP.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)


if not MYPY:
    class ProjectAttributesArgsDict(TypedDict):
        tenants: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgsDict']]]]
        """
        A list of `TenantAttribute`. Read the description below.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgsDict']]]]
        """
        A list of `UserAttribute`. Read the description below.
        """
elif False:
    ProjectAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesArgs:
    def __init__(__self__, *,
                 tenants: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]] tenants: A list of `TenantAttribute`. Read the description below.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]] users: A list of `UserAttribute`. Read the description below.
        """
        if tenants is not None:
            pulumi.set(__self__, "tenants", tenants)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def tenants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]]:
        """
        A list of `TenantAttribute`. Read the description below.
        """
        return pulumi.get(self, "tenants")

    @tenants.setter
    def tenants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesTenantArgs']]]]):
        pulumi.set(self, "tenants", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]]:
        """
        A list of `UserAttribute`. Read the description below.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAttributesUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class ProjectAttributesTenantArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        authorization: NotRequired[pulumi.Input['ProjectAttributesTenantAuthorizationArgsDict']]
        """
        Determines the required permissions for this tenant.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        select_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
elif False:
    ProjectAttributesTenantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesTenantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 authorization: Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 select_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the attribute. This value is called `Display Name` in the Descope console.
        :param pulumi.Input[_builtins.str] type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param pulumi.Input['ProjectAttributesTenantAuthorizationArgs'] authorization: Determines the required permissions for this tenant.
        :param pulumi.Input[_builtins.str] id: An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] select_options: When the attribute type is "multiselect". A list of options to choose from.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']]:
        """
        Determines the required permissions for this tenant.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ProjectAttributesTenantAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
        return pulumi.get(self, "select_options")

    @select_options.setter
    def select_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "select_options", value)


if not MYPY:
    class ProjectAttributesTenantAuthorizationArgsDict(TypedDict):
        view_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines the required permissions for this tenant.
        """
elif False:
    ProjectAttributesTenantAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesTenantAuthorizationArgs:
    def __init__(__self__, *,
                 view_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] view_permissions: Determines the required permissions for this tenant.
        """
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @_builtins.property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines the required permissions for this tenant.
        """
        return pulumi.get(self, "view_permissions")

    @view_permissions.setter
    def view_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "view_permissions", value)


if not MYPY:
    class ProjectAttributesUserArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        select_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
        widget_authorization: NotRequired[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgsDict']]
        """
        Determines the permissions users are required to have to access this attribute in the user management widget.
        """
elif False:
    ProjectAttributesUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 select_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 widget_authorization: Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the attribute. This value is called `Display Name` in the Descope console.
        :param pulumi.Input[_builtins.str] type: The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        :param pulumi.Input[_builtins.str] id: An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] select_options: When the attribute type is "multiselect". A list of options to choose from.
        :param pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs'] widget_authorization: Determines the permissions users are required to have to access this attribute in the user management widget.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if select_options is not None:
            pulumi.set(__self__, "select_options", select_options)
        if widget_authorization is not None:
            pulumi.set(__self__, "widget_authorization", widget_authorization)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the attribute. This value is called `Display Name` in the Descope console.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the attribute. Choose one of "string", "number", "boolean", "singleselect", "multiselect", "date".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional identifier for the attribute. This value is called `Machine Name` in the Descope console. If a value is not provided then an appropriate one will be created from the value of `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="selectOptions")
    def select_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        When the attribute type is "multiselect". A list of options to choose from.
        """
        return pulumi.get(self, "select_options")

    @select_options.setter
    def select_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "select_options", value)

    @_builtins.property
    @pulumi.getter(name="widgetAuthorization")
    def widget_authorization(self) -> Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']]:
        """
        Determines the permissions users are required to have to access this attribute in the user management widget.
        """
        return pulumi.get(self, "widget_authorization")

    @widget_authorization.setter
    def widget_authorization(self, value: Optional[pulumi.Input['ProjectAttributesUserWidgetAuthorizationArgs']]):
        pulumi.set(self, "widget_authorization", value)


if not MYPY:
    class ProjectAttributesUserWidgetAuthorizationArgsDict(TypedDict):
        edit_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The permissions users are required to have to edit this attribute in the user management widget.
        """
        view_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The permissions users are required to have to view this attribute in the user management widget.
        """
elif False:
    ProjectAttributesUserWidgetAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAttributesUserWidgetAuthorizationArgs:
    def __init__(__self__, *,
                 edit_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 view_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] edit_permissions: The permissions users are required to have to edit this attribute in the user management widget.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] view_permissions: The permissions users are required to have to view this attribute in the user management widget.
        """
        if edit_permissions is not None:
            pulumi.set(__self__, "edit_permissions", edit_permissions)
        if view_permissions is not None:
            pulumi.set(__self__, "view_permissions", view_permissions)

    @_builtins.property
    @pulumi.getter(name="editPermissions")
    def edit_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The permissions users are required to have to edit this attribute in the user management widget.
        """
        return pulumi.get(self, "edit_permissions")

    @edit_permissions.setter
    def edit_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "edit_permissions", value)

    @_builtins.property
    @pulumi.getter(name="viewPermissions")
    def view_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The permissions users are required to have to view this attribute in the user management widget.
        """
        return pulumi.get(self, "view_permissions")

    @view_permissions.setter
    def view_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "view_permissions", value)


if not MYPY:
    class ProjectAuthenticationArgsDict(TypedDict):
        embedded_link: NotRequired[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgsDict']]
        """
        Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        """
        enchanted_link: NotRequired[pulumi.Input['ProjectAuthenticationEnchantedLinkArgsDict']]
        """
        An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        """
        magic_link: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkArgsDict']]
        """
        An authentication method where a user receives a unique link via email to log in.
        """
        oauth: NotRequired[pulumi.Input['ProjectAuthenticationOauthArgsDict']]
        """
        Authentication using Open Authorization, which allows users to authenticate with various external services.
        """
        otp: NotRequired[pulumi.Input['ProjectAuthenticationOtpArgsDict']]
        """
        A dynamically generated set of numbers, granting the user one-time access.
        """
        passkeys: NotRequired[pulumi.Input['ProjectAuthenticationPasskeysArgsDict']]
        """
        Device-based passwordless authentication, using fingerprint, face scan, and more.
        """
        password: NotRequired[pulumi.Input['ProjectAuthenticationPasswordArgsDict']]
        """
        The classic username and password combination used for authentication.
        """
        sso: NotRequired[pulumi.Input['ProjectAuthenticationSsoArgsDict']]
        """
        Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        """
        totp: NotRequired[pulumi.Input['ProjectAuthenticationTotpArgsDict']]
        """
        A one-time code generated for the user using a shared secret and time.
        """
elif False:
    ProjectAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationArgs:
    def __init__(__self__, *,
                 embedded_link: Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']] = None,
                 enchanted_link: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']] = None,
                 magic_link: Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']] = None,
                 oauth: Optional[pulumi.Input['ProjectAuthenticationOauthArgs']] = None,
                 otp: Optional[pulumi.Input['ProjectAuthenticationOtpArgs']] = None,
                 passkeys: Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']] = None,
                 password: Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']] = None,
                 sso: Optional[pulumi.Input['ProjectAuthenticationSsoArgs']] = None,
                 totp: Optional[pulumi.Input['ProjectAuthenticationTotpArgs']] = None):
        """
        :param pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs'] embedded_link: Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        :param pulumi.Input['ProjectAuthenticationEnchantedLinkArgs'] enchanted_link: An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        :param pulumi.Input['ProjectAuthenticationMagicLinkArgs'] magic_link: An authentication method where a user receives a unique link via email to log in.
        :param pulumi.Input['ProjectAuthenticationOauthArgs'] oauth: Authentication using Open Authorization, which allows users to authenticate with various external services.
        :param pulumi.Input['ProjectAuthenticationOtpArgs'] otp: A dynamically generated set of numbers, granting the user one-time access.
        :param pulumi.Input['ProjectAuthenticationPasskeysArgs'] passkeys: Device-based passwordless authentication, using fingerprint, face scan, and more.
        :param pulumi.Input['ProjectAuthenticationPasswordArgs'] password: The classic username and password combination used for authentication.
        :param pulumi.Input['ProjectAuthenticationSsoArgs'] sso: Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        :param pulumi.Input['ProjectAuthenticationTotpArgs'] totp: A one-time code generated for the user using a shared secret and time.
        """
        if embedded_link is not None:
            pulumi.set(__self__, "embedded_link", embedded_link)
        if enchanted_link is not None:
            pulumi.set(__self__, "enchanted_link", enchanted_link)
        if magic_link is not None:
            pulumi.set(__self__, "magic_link", magic_link)
        if oauth is not None:
            pulumi.set(__self__, "oauth", oauth)
        if otp is not None:
            pulumi.set(__self__, "otp", otp)
        if passkeys is not None:
            pulumi.set(__self__, "passkeys", passkeys)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sso is not None:
            pulumi.set(__self__, "sso", sso)
        if totp is not None:
            pulumi.set(__self__, "totp", totp)

    @_builtins.property
    @pulumi.getter(name="embeddedLink")
    def embedded_link(self) -> Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']]:
        """
        Make the authentication experience smoother for the user by generating their initial token in a way that does not require the end user to initiate the process, requiring only verification.
        """
        return pulumi.get(self, "embedded_link")

    @embedded_link.setter
    def embedded_link(self, value: Optional[pulumi.Input['ProjectAuthenticationEmbeddedLinkArgs']]):
        pulumi.set(self, "embedded_link", value)

    @_builtins.property
    @pulumi.getter(name="enchantedLink")
    def enchanted_link(self) -> Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']]:
        """
        An enhanced and more secure version of Magic Link, enabling users to start the authentication process on one device and execute the verification on another.
        """
        return pulumi.get(self, "enchanted_link")

    @enchanted_link.setter
    def enchanted_link(self, value: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkArgs']]):
        pulumi.set(self, "enchanted_link", value)

    @_builtins.property
    @pulumi.getter(name="magicLink")
    def magic_link(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']]:
        """
        An authentication method where a user receives a unique link via email to log in.
        """
        return pulumi.get(self, "magic_link")

    @magic_link.setter
    def magic_link(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkArgs']]):
        pulumi.set(self, "magic_link", value)

    @_builtins.property
    @pulumi.getter
    def oauth(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthArgs']]:
        """
        Authentication using Open Authorization, which allows users to authenticate with various external services.
        """
        return pulumi.get(self, "oauth")

    @oauth.setter
    def oauth(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthArgs']]):
        pulumi.set(self, "oauth", value)

    @_builtins.property
    @pulumi.getter
    def otp(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpArgs']]:
        """
        A dynamically generated set of numbers, granting the user one-time access.
        """
        return pulumi.get(self, "otp")

    @otp.setter
    def otp(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpArgs']]):
        pulumi.set(self, "otp", value)

    @_builtins.property
    @pulumi.getter
    def passkeys(self) -> Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']]:
        """
        Device-based passwordless authentication, using fingerprint, face scan, and more.
        """
        return pulumi.get(self, "passkeys")

    @passkeys.setter
    def passkeys(self, value: Optional[pulumi.Input['ProjectAuthenticationPasskeysArgs']]):
        pulumi.set(self, "passkeys", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']]:
        """
        The classic username and password combination used for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input['ProjectAuthenticationPasswordArgs']]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def sso(self) -> Optional[pulumi.Input['ProjectAuthenticationSsoArgs']]:
        """
        Single Sign-On (SSO) authentication method that enables users to access multiple applications with a single set of credentials.
        """
        return pulumi.get(self, "sso")

    @sso.setter
    def sso(self, value: Optional[pulumi.Input['ProjectAuthenticationSsoArgs']]):
        pulumi.set(self, "sso", value)

    @_builtins.property
    @pulumi.getter
    def totp(self) -> Optional[pulumi.Input['ProjectAuthenticationTotpArgs']]:
        """
        A one-time code generated for the user using a shared secret and time.
        """
        return pulumi.get(self, "totp")

    @totp.setter
    def totp(self, value: Optional[pulumi.Input['ProjectAuthenticationTotpArgs']]):
        pulumi.set(self, "totp", value)


if not MYPY:
    class ProjectAuthenticationEmbeddedLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        expiration_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long the embedded link remains valid before it expires.
        """
elif False:
    ProjectAuthenticationEmbeddedLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEmbeddedLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] expiration_time: How long the embedded link remains valid before it expires.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long the embedded link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_time", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgsDict']]
        """
        Settings related to sending emails as part of the enchanted link authentication.
        """
        expiration_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long the enchanted link remains valid before it expires.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to redirect users to after they log in using the enchanted link.
        """
elif False:
    ProjectAuthenticationEnchantedLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs'] email_service: Settings related to sending emails as part of the enchanted link authentication.
        :param pulumi.Input[_builtins.str] expiration_time: How long the enchanted link remains valid before it expires.
        :param pulumi.Input[_builtins.str] redirect_url: The URL to redirect users to after they log in using the enchanted link.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']]:
        """
        Settings related to sending emails as part of the enchanted link authentication.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long the enchanted link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to redirect users to after they log in using the enchanted link.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the email connector to use for sending emails.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict']]]]
        """
        A list of email templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationEnchantedLinkEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the email connector to use for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this email template.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject line of the email message.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this email template is currently active and in use.
        """
        html_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        use_plain_text_body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the plain text body instead of HTML for the email.
        """
elif False:
    ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationEnchantedLinkEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[_builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this email template.
        :param pulumi.Input[_builtins.str] subject: Subject line of the email message.
        :param pulumi.Input[_builtins.bool] active: Whether this email template is currently active and in use.
        :param pulumi.Input[_builtins.str] html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param pulumi.Input[_builtins.str] plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param pulumi.Input[_builtins.bool] use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_body", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgsDict']]
        """
        Settings related to sending emails as part of the magic link authentication.
        """
        expiration_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long the magic link remains valid before it expires.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL to redirect users to after they log in using the magic link.
        """
        text_service: NotRequired[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgsDict']]
        """
        Settings related to sending SMS messages as part of the magic link authentication.
        """
elif False:
    ProjectAuthenticationMagicLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 text_service: Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs'] email_service: Settings related to sending emails as part of the magic link authentication.
        :param pulumi.Input[_builtins.str] expiration_time: How long the magic link remains valid before it expires.
        :param pulumi.Input[_builtins.str] redirect_url: The URL to redirect users to after they log in using the magic link.
        :param pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs'] text_service: Settings related to sending SMS messages as part of the magic link authentication.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']]:
        """
        Settings related to sending emails as part of the magic link authentication.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long the magic link remains valid before it expires.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL to redirect users to after they log in using the magic link.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']]:
        """
        Settings related to sending SMS messages as part of the magic link authentication.
        """
        return pulumi.get(self, "text_service")

    @text_service.setter
    def text_service(self, value: Optional[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceArgs']]):
        pulumi.set(self, "text_service", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the email connector to use for sending emails.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict']]]]
        """
        A list of email templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationMagicLinkEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the email connector to use for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this email template.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject line of the email message.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this email template is currently active and in use.
        """
        html_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        use_plain_text_body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the plain text body instead of HTML for the email.
        """
elif False:
    ProjectAuthenticationMagicLinkEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[_builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this email template.
        :param pulumi.Input[_builtins.str] subject: Subject line of the email message.
        :param pulumi.Input[_builtins.bool] active: Whether this email template is currently active and in use.
        :param pulumi.Input[_builtins.str] html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param pulumi.Input[_builtins.str] plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param pulumi.Input[_builtins.bool] use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_body", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkTextServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict']]]]
        """
        A list of text message templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationMagicLinkTextServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkTextServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the SMS/text connector to use for sending text messages.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]] templates: A list of text message templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]]:
        """
        A list of text message templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationMagicLinkTextServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[_builtins.str]
        """
        The content of the text message.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this text template.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this text template is currently active and in use.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectAuthenticationMagicLinkTextServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationMagicLinkTextServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The content of the text message.
        :param pulumi.Input[_builtins.str] name: Unique name for this text template.
        :param pulumi.Input[_builtins.bool] active: Whether this text template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the text message.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this text template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this text template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationOauthArgsDict(TypedDict):
        custom: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgsDict']]]]
        """
        Custom OAuth providers configured for this project.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        system: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemArgsDict']]
        """
        Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
elif False:
    ProjectAuthenticationOauthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthArgs:
    def __init__(__self__, *,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 system: Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]] custom: Custom OAuth providers configured for this project.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationOauthSystemArgs'] system: Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if system is not None:
            pulumi.set(__self__, "system", system)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]]:
        """
        Custom OAuth providers configured for this project.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProjectAuthenticationOauthCustomArgs']]]]):
        pulumi.set(self, "custom", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']]:
        """
        Custom configurations for builtin OAuth providers such as Apple, Google, GitHub, Facebook, etc.
        """
        return pulumi.get(self, "system")

    @system.setter
    def system(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemArgs']]):
        pulumi.set(self, "system", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthCustomAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthCustomProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthCustomAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthCustomProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthCustomProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemArgsDict(TypedDict):
        apple: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgsDict']]
        """
        Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        """
        discord: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgsDict']]
        """
        Discord's OAuth provider, allowing users to authenticate with their Discord account.
        """
        facebook: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgsDict']]
        """
        Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        """
        github: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgsDict']]
        """
        GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        """
        gitlab: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgsDict']]
        """
        GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        """
        google: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgsDict']]
        """
        Google's OAuth provider, allowing users to authenticate with their Google account.
        """
        linkedin: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgsDict']]
        """
        LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        """
        microsoft: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgsDict']]
        """
        Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        """
        slack: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgsDict']]
        """
        Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
elif False:
    ProjectAuthenticationOauthSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']] = None,
                 discord: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']] = None,
                 facebook: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']] = None,
                 github: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']] = None,
                 google: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']] = None,
                 linkedin: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']] = None,
                 microsoft: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']] = None,
                 slack: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']] = None):
        """
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs'] apple: Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs'] discord: Discord's OAuth provider, allowing users to authenticate with their Discord account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs'] facebook: Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs'] github: GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs'] gitlab: GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs'] google: Google's OAuth provider, allowing users to authenticate with their Google account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs'] linkedin: LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs'] microsoft: Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs'] slack: Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if discord is not None:
            pulumi.set(__self__, "discord", discord)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if linkedin is not None:
            pulumi.set(__self__, "linkedin", linkedin)
        if microsoft is not None:
            pulumi.set(__self__, "microsoft", microsoft)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @_builtins.property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']]:
        """
        Apple's OAuth provider, allowing users to authenticate with their Apple Account.
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleArgs']]):
        pulumi.set(self, "apple", value)

    @_builtins.property
    @pulumi.getter
    def discord(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']]:
        """
        Discord's OAuth provider, allowing users to authenticate with their Discord account.
        """
        return pulumi.get(self, "discord")

    @discord.setter
    def discord(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordArgs']]):
        pulumi.set(self, "discord", value)

    @_builtins.property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']]:
        """
        Facebook's OAuth provider, allowing users to authenticate with their Facebook account.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']]:
        """
        GitHub's OAuth provider, allowing users to authenticate with their GitHub account.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']]:
        """
        GitLab's OAuth provider, allowing users to authenticate with their GitLab account.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']]:
        """
        Google's OAuth provider, allowing users to authenticate with their Google account.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleArgs']]):
        pulumi.set(self, "google", value)

    @_builtins.property
    @pulumi.getter
    def linkedin(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']]:
        """
        LinkedIn's OAuth provider, allowing users to authenticate with their LinkedIn account.
        """
        return pulumi.get(self, "linkedin")

    @linkedin.setter
    def linkedin(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinArgs']]):
        pulumi.set(self, "linkedin", value)

    @_builtins.property
    @pulumi.getter
    def microsoft(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']]:
        """
        Microsoft's OAuth provider, allowing users to authenticate with their Microsoft account.
        """
        return pulumi.get(self, "microsoft")

    @microsoft.setter
    def microsoft(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftArgs']]):
        pulumi.set(self, "microsoft", value)

    @_builtins.property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']]:
        """
        Slack's OAuth provider, allowing users to authenticate with their Slack account.
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackArgs']]):
        pulumi.set(self, "slack", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemAppleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemAppleProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemDiscordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemDiscordProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemFacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemFacebookProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGithubProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGitlabProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemGoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemGoogleProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemLinkedinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemLinkedinProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemMicrosoftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemMicrosoftProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackArgsDict(TypedDict):
        allowed_grant_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        callback_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use a custom domain in your OAuth verification screen.
        """
        claim_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A brief description of the OAuth provider.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer identifier for the OAuth provider.
        """
        jwks_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the logo associated with the OAuth provider.
        """
        manage_provider_tokens: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable provider token management for this OAuth provider.
        """
        merge_user_accounts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        native_apple_key_generator: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgsDict']]
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        native_client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        native_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        prompts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        provider_token_management: NotRequired[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict']]
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        use_client_assertion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
elif False:
    ProjectAuthenticationOauthSystemSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackArgs:
    def __init__(__self__, *,
                 allowed_grant_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs']] = None,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 callback_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 claim_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 jwks_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 manage_provider_tokens: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_user_accounts: Optional[pulumi.Input[_builtins.bool]] = None,
                 native_apple_key_generator: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs']] = None,
                 native_client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 native_client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 prompts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 provider_token_management: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 use_client_assertion: Optional[pulumi.Input[_builtins.bool]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_grant_types: The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs'] apple_key_generator: The apple key generator object describing how to create a dynamic apple client secret for applications.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The URL that users are redirected to for authorization with the OAuth provider.
        :param pulumi.Input[_builtins.str] callback_domain: Use a custom domain in your OAuth verification screen.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] claim_mapping: Maps OAuth provider claims to Descope user attributes.
        :param pulumi.Input[_builtins.str] client_id: The client ID for the OAuth provider, used to identify the application to the provider.
        :param pulumi.Input[_builtins.str] client_secret: The client secret for the OAuth provider, used to authenticate the application with the provider.
        :param pulumi.Input[_builtins.str] description: A brief description of the OAuth provider.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] issuer: The issuer identifier for the OAuth provider.
        :param pulumi.Input[_builtins.str] jwks_endpoint: The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        :param pulumi.Input[_builtins.str] logo: The URL of the logo associated with the OAuth provider.
        :param pulumi.Input[_builtins.bool] manage_provider_tokens: Whether to enable provider token management for this OAuth provider.
        :param pulumi.Input[_builtins.bool] merge_user_accounts: Whether to merge existing user accounts with new ones created through OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs'] native_apple_key_generator: The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        :param pulumi.Input[_builtins.str] native_client_id: The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[_builtins.str] native_client_secret: The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] prompts: Custom prompts or consent screens that users may see during OAuth authentication.
        :param pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs'] provider_token_management: This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        :param pulumi.Input[_builtins.str] redirect_url: Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes of access that the application requests from the user's account on the OAuth provider.
        :param pulumi.Input[_builtins.str] token_endpoint: The URL where the application requests an access token from the OAuth provider.
        :param pulumi.Input[_builtins.bool] use_client_assertion: Use private key JWT (client assertion) instead of client secret.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The URL where the application retrieves user information from the OAuth provider.
        """
        if allowed_grant_types is not None:
            pulumi.set(__self__, "allowed_grant_types", allowed_grant_types)
        if apple_key_generator is not None:
            pulumi.set(__self__, "apple_key_generator", apple_key_generator)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if callback_domain is not None:
            pulumi.set(__self__, "callback_domain", callback_domain)
        if claim_mapping is not None:
            pulumi.set(__self__, "claim_mapping", claim_mapping)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_endpoint is not None:
            pulumi.set(__self__, "jwks_endpoint", jwks_endpoint)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if manage_provider_tokens is not None:
            pulumi.set(__self__, "manage_provider_tokens", manage_provider_tokens)
        if merge_user_accounts is not None:
            pulumi.set(__self__, "merge_user_accounts", merge_user_accounts)
        if native_apple_key_generator is not None:
            pulumi.set(__self__, "native_apple_key_generator", native_apple_key_generator)
        if native_client_id is not None:
            pulumi.set(__self__, "native_client_id", native_client_id)
        if native_client_secret is not None:
            pulumi.set(__self__, "native_client_secret", native_client_secret)
        if prompts is not None:
            pulumi.set(__self__, "prompts", prompts)
        if provider_token_management is not None:
            pulumi.set(__self__, "provider_token_management", provider_token_management)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if use_client_assertion is not None:
            pulumi.set(__self__, "use_client_assertion", use_client_assertion)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="allowedGrantTypes")
    def allowed_grant_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of grants (`authorization_code` or `implicit`) to allow when requesting access tokens from the OAuth provider.
        """
        return pulumi.get(self, "allowed_grant_types")

    @allowed_grant_types.setter
    def allowed_grant_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_grant_types", value)

    @_builtins.property
    @pulumi.getter(name="appleKeyGenerator")
    def apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic apple client secret for applications.
        """
        return pulumi.get(self, "apple_key_generator")

    @apple_key_generator.setter
    def apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs']]):
        pulumi.set(self, "apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL that users are redirected to for authorization with the OAuth provider.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="callbackDomain")
    def callback_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use a custom domain in your OAuth verification screen.
        """
        return pulumi.get(self, "callback_domain")

    @callback_domain.setter
    def callback_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "callback_domain", value)

    @_builtins.property
    @pulumi.getter(name="claimMapping")
    def claim_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps OAuth provider claims to Descope user attributes.
        """
        return pulumi.get(self, "claim_mapping")

    @claim_mapping.setter
    def claim_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "claim_mapping", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used to identify the application to the provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used to authenticate the application with the provider.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A brief description of the OAuth provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer identifier for the OAuth provider.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="jwksEndpoint")
    def jwks_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application can retrieve JSON Web Key Sets (JWKS) for the OAuth provider.
        """
        return pulumi.get(self, "jwks_endpoint")

    @jwks_endpoint.setter
    def jwks_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jwks_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the logo associated with the OAuth provider.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="manageProviderTokens")
    def manage_provider_tokens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable provider token management for this OAuth provider.
        """
        return pulumi.get(self, "manage_provider_tokens")

    @manage_provider_tokens.setter
    def manage_provider_tokens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "manage_provider_tokens", value)

    @_builtins.property
    @pulumi.getter(name="mergeUserAccounts")
    def merge_user_accounts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through OAuth authentication.
        """
        return pulumi.get(self, "merge_user_accounts")

    @merge_user_accounts.setter
    def merge_user_accounts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_user_accounts", value)

    @_builtins.property
    @pulumi.getter(name="nativeAppleKeyGenerator")
    def native_apple_key_generator(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs']]:
        """
        The apple key generator object describing how to create a dynamic native apple client secret for mobile apps.
        """
        return pulumi.get(self, "native_apple_key_generator")

    @native_apple_key_generator.setter
    def native_apple_key_generator(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs']]):
        pulumi.set(self, "native_apple_key_generator", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientId")
    def native_client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client ID for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_id")

    @native_client_id.setter
    def native_client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_id", value)

    @_builtins.property
    @pulumi.getter(name="nativeClientSecret")
    def native_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret for the OAuth provider, used for Sign in with Apple in mobile apps.
        """
        return pulumi.get(self, "native_client_secret")

    @native_client_secret.setter
    def native_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "native_client_secret", value)

    @_builtins.property
    @pulumi.getter
    def prompts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom prompts or consent screens that users may see during OAuth authentication.
        """
        return pulumi.get(self, "prompts")

    @prompts.setter
    def prompts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "prompts", value)

    @_builtins.property
    @pulumi.getter(name="providerTokenManagement")
    def provider_token_management(self) -> Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']]:
        """
        This attribute is deprecated, use the `manage_provider_tokens`, `callback_domain`, and `redirect_url` fields instead.
        """
        return pulumi.get(self, "provider_token_management")

    @provider_token_management.setter
    def provider_token_management(self, value: Optional[pulumi.Input['ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs']]):
        pulumi.set(self, "provider_token_management", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Users will be directed to this URL after authentication. If redirect URL is specified in the SDK/API call, it will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes of access that the application requests from the user's account on the OAuth provider.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application requests an access token from the OAuth provider.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="useClientAssertion")
    def use_client_assertion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use private key JWT (client assertion) instead of client secret.
        """
        return pulumi.get(self, "use_client_assertion")

    @use_client_assertion.setter
    def use_client_assertion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_client_assertion", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL where the application retrieves user information from the OAuth provider.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
        """
        The apple generator key id produced by Apple.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The apple generator private key produced by Apple.
        """
        team_id: pulumi.Input[_builtins.str]
        """
        The apple generator team id assigned to the key by Apple.
        """
elif False:
    ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackNativeAppleKeyGeneratorArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 team_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_id: The apple generator key id produced by Apple.
        :param pulumi.Input[_builtins.str] private_key: The apple generator private key produced by Apple.
        :param pulumi.Input[_builtins.str] team_id: The apple generator team id assigned to the key by Apple.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator key id produced by Apple.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator private key produced by Apple.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[_builtins.str]:
        """
        The apple generator team id assigned to the key by Apple.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict(TypedDict):
        pass
elif False:
    ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOauthSystemSlackProviderTokenManagementArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ProjectAuthenticationOtpArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain to embed in OTP messages.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgsDict']]
        """
        Settings related to sending emails with OTP codes.
        """
        expiration_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time that an OTP code will be valid for.
        """
        text_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpTextServiceArgsDict']]
        """
        Settings related to sending SMS messages with OTP codes.
        """
        voice_service: NotRequired[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgsDict']]
        """
        Settings related to voice calls with OTP codes.
        """
elif False:
    ProjectAuthenticationOtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']] = None,
                 expiration_time: Optional[pulumi.Input[_builtins.str]] = None,
                 text_service: Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']] = None,
                 voice_service: Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] domain: The domain to embed in OTP messages.
        :param pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs'] email_service: Settings related to sending emails with OTP codes.
        :param pulumi.Input[_builtins.str] expiration_time: The amount of time that an OTP code will be valid for.
        :param pulumi.Input['ProjectAuthenticationOtpTextServiceArgs'] text_service: Settings related to sending SMS messages with OTP codes.
        :param pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs'] voice_service: Settings related to voice calls with OTP codes.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if text_service is not None:
            pulumi.set(__self__, "text_service", text_service)
        if voice_service is not None:
            pulumi.set(__self__, "voice_service", voice_service)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain to embed in OTP messages.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']]:
        """
        Settings related to sending emails with OTP codes.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time that an OTP code will be valid for.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_time", value)

    @_builtins.property
    @pulumi.getter(name="textService")
    def text_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']]:
        """
        Settings related to sending SMS messages with OTP codes.
        """
        return pulumi.get(self, "text_service")

    @text_service.setter
    def text_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpTextServiceArgs']]):
        pulumi.set(self, "text_service", value)

    @_builtins.property
    @pulumi.getter(name="voiceService")
    def voice_service(self) -> Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']]:
        """
        Settings related to voice calls with OTP codes.
        """
        return pulumi.get(self, "voice_service")

    @voice_service.setter
    def voice_service(self, value: Optional[pulumi.Input['ProjectAuthenticationOtpVoiceServiceArgs']]):
        pulumi.set(self, "voice_service", value)


if not MYPY:
    class ProjectAuthenticationOtpEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the email connector to use for sending emails.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgsDict']]]]
        """
        A list of email templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationOtpEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the email connector to use for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this email template.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject line of the email message.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this email template is currently active and in use.
        """
        html_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        use_plain_text_body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the plain text body instead of HTML for the email.
        """
elif False:
    ProjectAuthenticationOtpEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[_builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this email template.
        :param pulumi.Input[_builtins.str] subject: Subject line of the email message.
        :param pulumi.Input[_builtins.bool] active: Whether this email template is currently active and in use.
        :param pulumi.Input[_builtins.str] html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param pulumi.Input[_builtins.str] plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param pulumi.Input[_builtins.bool] use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_body", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationOtpTextServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgsDict']]]]
        """
        A list of text message templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationOtpTextServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpTextServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the SMS/text connector to use for sending text messages.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]] templates: A list of text message templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SMS/text connector to use for sending text messages.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]]:
        """
        A list of text message templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpTextServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpTextServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[_builtins.str]
        """
        The content of the text message.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this text template.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this text template is currently active and in use.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectAuthenticationOtpTextServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpTextServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The content of the text message.
        :param pulumi.Input[_builtins.str] name: Unique name for this text template.
        :param pulumi.Input[_builtins.bool] active: Whether this text template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the text message.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this text template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this text template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationOtpVoiceServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the voice connector to use for making voice calls.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgsDict']]]]
        """
        A list of voice message templates for different purposes.
        """
elif False:
    ProjectAuthenticationOtpVoiceServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpVoiceServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the voice connector to use for making voice calls.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]] templates: A list of voice message templates for different purposes.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the voice connector to use for making voice calls.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]]:
        """
        A list of voice message templates for different purposes.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationOtpVoiceServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationOtpVoiceServiceTemplateArgsDict(TypedDict):
        body: pulumi.Input[_builtins.str]
        """
        The content of the voice message that will be spoken.
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this voice template.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this voice template is currently active and in use.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectAuthenticationOtpVoiceServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationOtpVoiceServiceTemplateArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] body: The content of the voice message that will be spoken.
        :param pulumi.Input[_builtins.str] name: Unique name for this voice template.
        :param pulumi.Input[_builtins.bool] active: Whether this voice template is currently active and in use.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the voice message that will be spoken.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this voice template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this voice template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthenticationPasskeysArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        top_level_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passkeys will be usable in the following domain and all its subdomains.
        """
elif False:
    ProjectAuthenticationPasskeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasskeysArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 top_level_domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] top_level_domain: Passkeys will be usable in the following domain and all its subdomains.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if top_level_domain is not None:
            pulumi.set(__self__, "top_level_domain", top_level_domain)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="topLevelDomain")
    def top_level_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passkeys will be usable in the following domain and all its subdomains.
        """
        return pulumi.get(self, "top_level_domain")

    @top_level_domain.setter
    def top_level_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "top_level_domain", value)


if not MYPY:
    class ProjectAuthenticationPasswordArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        email_service: NotRequired[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgsDict']]
        """
        Settings related to sending password reset emails as part of the password feature.
        """
        expiration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether users are required to change their password periodically.
        """
        expiration_weeks: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of weeks after which a user's password expires and they need to replace it.
        """
        lock: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the user account should be locked after a specified number of failed login attempts.
        """
        lock_attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of failed login attempts allowed before an account is locked.
        """
        lowercase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether passwords must contain at least one lowercase letter.
        """
        mask_errors: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
        """
        min_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum length of the password that users are required to use. The maximum length is always `64`.
        """
        non_alphanumeric: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        """
        number: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether passwords must contain at least one number.
        """
        reuse: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to forbid password reuse when users change their password.
        """
        reuse_amount: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
        """
        temporary_lock: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the user account should be temporarily locked after a specified number of failed login attempts.
        """
        temporary_lock_attempts: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of failed login attempts allowed before an account is temporarily locked.
        """
        temporary_lock_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time before the user can sign in again after the account is temporarily locked.
        """
        uppercase: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether passwords must contain at least one uppercase letter.
        """
elif False:
    ProjectAuthenticationPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']] = None,
                 expiration: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiration_weeks: Optional[pulumi.Input[_builtins.int]] = None,
                 lock: Optional[pulumi.Input[_builtins.bool]] = None,
                 lock_attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 lowercase: Optional[pulumi.Input[_builtins.bool]] = None,
                 mask_errors: Optional[pulumi.Input[_builtins.bool]] = None,
                 min_length: Optional[pulumi.Input[_builtins.int]] = None,
                 non_alphanumeric: Optional[pulumi.Input[_builtins.bool]] = None,
                 number: Optional[pulumi.Input[_builtins.bool]] = None,
                 reuse: Optional[pulumi.Input[_builtins.bool]] = None,
                 reuse_amount: Optional[pulumi.Input[_builtins.int]] = None,
                 temporary_lock: Optional[pulumi.Input[_builtins.bool]] = None,
                 temporary_lock_attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 temporary_lock_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 uppercase: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs'] email_service: Settings related to sending password reset emails as part of the password feature.
        :param pulumi.Input[_builtins.bool] expiration: Whether users are required to change their password periodically.
        :param pulumi.Input[_builtins.int] expiration_weeks: The number of weeks after which a user's password expires and they need to replace it.
        :param pulumi.Input[_builtins.bool] lock: Whether the user account should be locked after a specified number of failed login attempts.
        :param pulumi.Input[_builtins.int] lock_attempts: The number of failed login attempts allowed before an account is locked.
        :param pulumi.Input[_builtins.bool] lowercase: Whether passwords must contain at least one lowercase letter.
        :param pulumi.Input[_builtins.bool] mask_errors: Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
        :param pulumi.Input[_builtins.int] min_length: The minimum length of the password that users are required to use. The maximum length is always `64`.
        :param pulumi.Input[_builtins.bool] non_alphanumeric: Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        :param pulumi.Input[_builtins.bool] number: Whether passwords must contain at least one number.
        :param pulumi.Input[_builtins.bool] reuse: Whether to forbid password reuse when users change their password.
        :param pulumi.Input[_builtins.int] reuse_amount: The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
        :param pulumi.Input[_builtins.bool] temporary_lock: Whether the user account should be temporarily locked after a specified number of failed login attempts.
        :param pulumi.Input[_builtins.int] temporary_lock_attempts: The number of failed login attempts allowed before an account is temporarily locked.
        :param pulumi.Input[_builtins.str] temporary_lock_duration: The amount of time before the user can sign in again after the account is temporarily locked.
        :param pulumi.Input[_builtins.bool] uppercase: Whether passwords must contain at least one uppercase letter.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if expiration_weeks is not None:
            pulumi.set(__self__, "expiration_weeks", expiration_weeks)
        if lock is not None:
            pulumi.set(__self__, "lock", lock)
        if lock_attempts is not None:
            pulumi.set(__self__, "lock_attempts", lock_attempts)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if mask_errors is not None:
            pulumi.set(__self__, "mask_errors", mask_errors)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if non_alphanumeric is not None:
            pulumi.set(__self__, "non_alphanumeric", non_alphanumeric)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if reuse is not None:
            pulumi.set(__self__, "reuse", reuse)
        if reuse_amount is not None:
            pulumi.set(__self__, "reuse_amount", reuse_amount)
        if temporary_lock is not None:
            pulumi.set(__self__, "temporary_lock", temporary_lock)
        if temporary_lock_attempts is not None:
            pulumi.set(__self__, "temporary_lock_attempts", temporary_lock_attempts)
        if temporary_lock_duration is not None:
            pulumi.set(__self__, "temporary_lock_duration", temporary_lock_duration)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']]:
        """
        Settings related to sending password reset emails as part of the password feature.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectAuthenticationPasswordEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether users are required to change their password periodically.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter(name="expirationWeeks")
    def expiration_weeks(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of weeks after which a user's password expires and they need to replace it.
        """
        return pulumi.get(self, "expiration_weeks")

    @expiration_weeks.setter
    def expiration_weeks(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expiration_weeks", value)

    @_builtins.property
    @pulumi.getter
    def lock(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the user account should be locked after a specified number of failed login attempts.
        """
        return pulumi.get(self, "lock")

    @lock.setter
    def lock(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lock", value)

    @_builtins.property
    @pulumi.getter(name="lockAttempts")
    def lock_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of failed login attempts allowed before an account is locked.
        """
        return pulumi.get(self, "lock_attempts")

    @lock_attempts.setter
    def lock_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lock_attempts", value)

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether passwords must contain at least one lowercase letter.
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "lowercase", value)

    @_builtins.property
    @pulumi.getter(name="maskErrors")
    def mask_errors(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Prevents information about user accounts from being revealed in error messages, e.g., whether a user already exists.
        """
        return pulumi.get(self, "mask_errors")

    @mask_errors.setter
    def mask_errors(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mask_errors", value)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum length of the password that users are required to use. The maximum length is always `64`.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_length", value)

    @_builtins.property
    @pulumi.getter(name="nonAlphanumeric")
    def non_alphanumeric(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether passwords must contain at least one non-alphanumeric character (e.g. `!`, `@`, `#`).
        """
        return pulumi.get(self, "non_alphanumeric")

    @non_alphanumeric.setter
    def non_alphanumeric(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "non_alphanumeric", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether passwords must contain at least one number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def reuse(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to forbid password reuse when users change their password.
        """
        return pulumi.get(self, "reuse")

    @reuse.setter
    def reuse(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reuse", value)

    @_builtins.property
    @pulumi.getter(name="reuseAmount")
    def reuse_amount(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of previous passwords whose hashes are kept to prevent users from reusing old passwords.
        """
        return pulumi.get(self, "reuse_amount")

    @reuse_amount.setter
    def reuse_amount(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "reuse_amount", value)

    @_builtins.property
    @pulumi.getter(name="temporaryLock")
    def temporary_lock(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the user account should be temporarily locked after a specified number of failed login attempts.
        """
        return pulumi.get(self, "temporary_lock")

    @temporary_lock.setter
    def temporary_lock(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "temporary_lock", value)

    @_builtins.property
    @pulumi.getter(name="temporaryLockAttempts")
    def temporary_lock_attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of failed login attempts allowed before an account is temporarily locked.
        """
        return pulumi.get(self, "temporary_lock_attempts")

    @temporary_lock_attempts.setter
    def temporary_lock_attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "temporary_lock_attempts", value)

    @_builtins.property
    @pulumi.getter(name="temporaryLockDuration")
    def temporary_lock_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time before the user can sign in again after the account is temporarily locked.
        """
        return pulumi.get(self, "temporary_lock_duration")

    @temporary_lock_duration.setter
    def temporary_lock_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "temporary_lock_duration", value)

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether passwords must contain at least one uppercase letter.
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "uppercase", value)


if not MYPY:
    class ProjectAuthenticationPasswordEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the email connector to use for sending emails.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgsDict']]]]
        """
        A list of email templates for different authentication flows.
        """
elif False:
    ProjectAuthenticationPasswordEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the email connector to use for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthenticationPasswordEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectAuthenticationPasswordEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this email template.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject line of the email message.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this email template is currently active and in use.
        """
        html_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        use_plain_text_body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the plain text body instead of HTML for the email.
        """
elif False:
    ProjectAuthenticationPasswordEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationPasswordEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[_builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this email template.
        :param pulumi.Input[_builtins.str] subject: Subject line of the email message.
        :param pulumi.Input[_builtins.bool] active: Whether this email template is currently active and in use.
        :param pulumi.Input[_builtins.str] html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param pulumi.Input[_builtins.str] plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param pulumi.Input[_builtins.bool] use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_body", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectAuthenticationSsoArgsDict(TypedDict):
        allow_duplicate_domains: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow duplicate SSO domains across tenants.
        """
        allow_override_roles: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to allow overriding user's roles with SSO related roles.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        merge_users: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to merge existing user accounts with new ones created through SSO authentication.
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
        """
        sso_suite_settings: NotRequired[pulumi.Input['ProjectAuthenticationSsoSsoSuiteSettingsArgsDict']]
        """
        Configuration block for the SSO Suite.
        """
elif False:
    ProjectAuthenticationSsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationSsoArgs:
    def __init__(__self__, *,
                 allow_duplicate_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_override_roles: Optional[pulumi.Input[_builtins.bool]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 merge_users: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 sso_suite_settings: Optional[pulumi.Input['ProjectAuthenticationSsoSsoSuiteSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_duplicate_domains: Whether to allow duplicate SSO domains across tenants.
        :param pulumi.Input[_builtins.bool] allow_override_roles: Whether to allow overriding user's roles with SSO related roles.
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.bool] merge_users: Whether to merge existing user accounts with new ones created through SSO authentication.
        :param pulumi.Input[_builtins.str] redirect_url: The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
        :param pulumi.Input['ProjectAuthenticationSsoSsoSuiteSettingsArgs'] sso_suite_settings: Configuration block for the SSO Suite.
        """
        if allow_duplicate_domains is not None:
            pulumi.set(__self__, "allow_duplicate_domains", allow_duplicate_domains)
        if allow_override_roles is not None:
            pulumi.set(__self__, "allow_override_roles", allow_override_roles)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if merge_users is not None:
            pulumi.set(__self__, "merge_users", merge_users)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if sso_suite_settings is not None:
            pulumi.set(__self__, "sso_suite_settings", sso_suite_settings)

    @_builtins.property
    @pulumi.getter(name="allowDuplicateDomains")
    def allow_duplicate_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow duplicate SSO domains across tenants.
        """
        return pulumi.get(self, "allow_duplicate_domains")

    @allow_duplicate_domains.setter
    def allow_duplicate_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_duplicate_domains", value)

    @_builtins.property
    @pulumi.getter(name="allowOverrideRoles")
    def allow_override_roles(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to allow overriding user's roles with SSO related roles.
        """
        return pulumi.get(self, "allow_override_roles")

    @allow_override_roles.setter
    def allow_override_roles(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_override_roles", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="mergeUsers")
    def merge_users(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to merge existing user accounts with new ones created through SSO authentication.
        """
        return pulumi.get(self, "merge_users")

    @merge_users.setter
    def merge_users(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "merge_users", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL the end user is redirected to after a successful authentication. If one is specified in tenant level settings or SDK/API call, they will override this value.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="ssoSuiteSettings")
    def sso_suite_settings(self) -> Optional[pulumi.Input['ProjectAuthenticationSsoSsoSuiteSettingsArgs']]:
        """
        Configuration block for the SSO Suite.
        """
        return pulumi.get(self, "sso_suite_settings")

    @sso_suite_settings.setter
    def sso_suite_settings(self, value: Optional[pulumi.Input['ProjectAuthenticationSsoSsoSuiteSettingsArgs']]):
        pulumi.set(self, "sso_suite_settings", value)


if not MYPY:
    class ProjectAuthenticationSsoSsoSuiteSettingsArgsDict(TypedDict):
        force_domain_verification: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will allow only verified domains to be used.
        """
        hide_domains: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
        """
        hide_groups_mapping: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
        """
        hide_oidc: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will hide the OIDC configuration option.
        """
        hide_saml: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will hide the SAML configuration option.
        """
        hide_scim: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
        """
        style_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
        """
elif False:
    ProjectAuthenticationSsoSsoSuiteSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationSsoSsoSuiteSettingsArgs:
    def __init__(__self__, *,
                 force_domain_verification: Optional[pulumi.Input[_builtins.bool]] = None,
                 hide_domains: Optional[pulumi.Input[_builtins.bool]] = None,
                 hide_groups_mapping: Optional[pulumi.Input[_builtins.bool]] = None,
                 hide_oidc: Optional[pulumi.Input[_builtins.bool]] = None,
                 hide_saml: Optional[pulumi.Input[_builtins.bool]] = None,
                 hide_scim: Optional[pulumi.Input[_builtins.bool]] = None,
                 style_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] force_domain_verification: Setting this to `true` will allow only verified domains to be used.
        :param pulumi.Input[_builtins.bool] hide_domains: Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
        :param pulumi.Input[_builtins.bool] hide_groups_mapping: Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
        :param pulumi.Input[_builtins.bool] hide_oidc: Setting this to `true` will hide the OIDC configuration option.
        :param pulumi.Input[_builtins.bool] hide_saml: Setting this to `true` will hide the SAML configuration option.
        :param pulumi.Input[_builtins.bool] hide_scim: Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
        :param pulumi.Input[_builtins.str] style_id: Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
        """
        if force_domain_verification is not None:
            pulumi.set(__self__, "force_domain_verification", force_domain_verification)
        if hide_domains is not None:
            pulumi.set(__self__, "hide_domains", hide_domains)
        if hide_groups_mapping is not None:
            pulumi.set(__self__, "hide_groups_mapping", hide_groups_mapping)
        if hide_oidc is not None:
            pulumi.set(__self__, "hide_oidc", hide_oidc)
        if hide_saml is not None:
            pulumi.set(__self__, "hide_saml", hide_saml)
        if hide_scim is not None:
            pulumi.set(__self__, "hide_scim", hide_scim)
        if style_id is not None:
            pulumi.set(__self__, "style_id", style_id)

    @_builtins.property
    @pulumi.getter(name="forceDomainVerification")
    def force_domain_verification(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will allow only verified domains to be used.
        """
        return pulumi.get(self, "force_domain_verification")

    @force_domain_verification.setter
    def force_domain_verification(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_domain_verification", value)

    @_builtins.property
    @pulumi.getter(name="hideDomains")
    def hide_domains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will hide the domains configuration section in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_domains")

    @hide_domains.setter
    def hide_domains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_domains", value)

    @_builtins.property
    @pulumi.getter(name="hideGroupsMapping")
    def hide_groups_mapping(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will hide the groups mapping configuration section in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_groups_mapping")

    @hide_groups_mapping.setter
    def hide_groups_mapping(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_groups_mapping", value)

    @_builtins.property
    @pulumi.getter(name="hideOidc")
    def hide_oidc(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will hide the OIDC configuration option.
        """
        return pulumi.get(self, "hide_oidc")

    @hide_oidc.setter
    def hide_oidc(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_oidc", value)

    @_builtins.property
    @pulumi.getter(name="hideSaml")
    def hide_saml(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will hide the SAML configuration option.
        """
        return pulumi.get(self, "hide_saml")

    @hide_saml.setter
    def hide_saml(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_saml", value)

    @_builtins.property
    @pulumi.getter(name="hideScim")
    def hide_scim(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will hide the SCIM configuration in the SSO Suite interface.
        """
        return pulumi.get(self, "hide_scim")

    @hide_scim.setter
    def hide_scim(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hide_scim", value)

    @_builtins.property
    @pulumi.getter(name="styleId")
    def style_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the style ID to apply in the SSO Suite. Ensure a style with this ID exists in the console for it to be used.
        """
        return pulumi.get(self, "style_id")

    @style_id.setter
    def style_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "style_id", value)


if not MYPY:
    class ProjectAuthenticationTotpArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        service_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        The template for the service issuer label (issuer) shown in the authenticator app.
        """
elif False:
    ProjectAuthenticationTotpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthenticationTotpArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 service_label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        :param pulumi.Input[_builtins.str] service_label: The template for the service issuer label (issuer) shown in the authenticator app.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if service_label is not None:
            pulumi.set(__self__, "service_label", service_label)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Setting this to `true` will disallow using this authentication method directly via API and SDK calls. Note that this does not affect authentication flows that are configured to use this authentication method.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="serviceLabel")
    def service_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The template for the service issuer label (issuer) shown in the authenticator app.
        """
        return pulumi.get(self, "service_label")

    @service_label.setter
    def service_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_label", value)


if not MYPY:
    class ProjectAuthorizationArgsDict(TypedDict):
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgsDict']]]]
        """
        A list of `Permission` objects.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgsDict']]]]
        """
        A list of `Role` objects.
        """
elif False:
    ProjectAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationArgs:
    def __init__(__self__, *,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]] permissions: A list of `Permission` objects.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]] roles: A list of `Role` objects.
        """
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]]:
        """
        A list of `Permission` objects.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationPermissionArgs']]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]]:
        """
        A list of `Role` objects.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAuthorizationRoleArgs']]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class ProjectAuthorizationPermissionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the permission.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the permission.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectAuthorizationPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationPermissionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the permission.
        :param pulumi.Input[_builtins.str] description: A description for the permission.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the permission.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectAuthorizationRoleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the role.
        """
        default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this role should automatically be assigned to users that are created without any roles.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the role.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of permissions by name to be included in the role.
        """
        private: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this role should not be displayed to tenant admins.
        """
elif False:
    ProjectAuthorizationRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAuthorizationRoleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 default: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 permissions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the role.
        :param pulumi.Input[_builtins.bool] default: Whether this role should automatically be assigned to users that are created without any roles.
        :param pulumi.Input[_builtins.str] description: A description for the role.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: A list of permissions by name to be included in the role.
        :param pulumi.Input[_builtins.bool] private: Whether this role should not be displayed to tenant admins.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if private is not None:
            pulumi.set(__self__, "private", private)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this role should automatically be assigned to users that are created without any roles.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the role.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of permissions by name to be included in the role.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this role should not be displayed to tenant admins.
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "private", value)


if not MYPY:
    class ProjectConnectorsArgsDict(TypedDict):
        abuseipdbs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgsDict']]]]
        """
        Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
        """
        amplitudes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgsDict']]]]
        """
        Track user activity and traits at any point in your user journey with the Amplitude connector.
        """
        audit_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgsDict']]]]
        """
        Send audit events to a custom webhook.
        """
        aws_s3s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3ArgsDict']]]]
        """
        Stream authentication audit logs with the Amazon S3 connector.
        """
        aws_translates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Amazon Translate connector.
        """
        bitsights: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsBitsightArgsDict']]]]
        """
        Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
        """
        datadogs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgsDict']]]]
        """
        Stream authentication audit logs with the Datadog connector.
        """
        devrev_grows: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgsDict']]]]
        """
        DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
        """
        docebos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgsDict']]]]
        """
        Get user information from Docebo in your Descope user journeys with the Docebo connector.
        """
        eight_by_eight_vibers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightViberArgsDict']]]]
        """
        Send Viber messages to the user.
        """
        eight_by_eight_whatsapps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightWhatsappArgsDict']]]]
        """
        Send WhatsApp messages to the user.
        """
        elephants: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsElephantArgsDict']]]]
        """
        Use this connector to obtain an identity trust score.
        """
        external_token_https: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsExternalTokenHttpArgsDict']]]]
        """
        A generic HTTP token connector.
        """
        fingerprint_descopes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgsDict']]]]
        """
        Descope Fingerprint capabilities for fraud detection and risk assessment.
        """
        fingerprints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgsDict']]]]
        """
        Prevent fraud by adding device intelligence with the Fingerprint connector.
        """
        firebase_admins: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFirebaseAdminArgsDict']]]]
        """
        Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
        """
        forters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgsDict']]]]
        """
        Leverage ML-based risk scores for fraud prevention with the Forter connector.
        """
        generic_email_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericEmailGatewayArgsDict']]]]
        """
        Send emails using a generic Email gateway.
        """
        generic_sms_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgsDict']]]]
        """
        Send messages using a generic SMS gateway.
        """
        google_cloud_loggings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingArgsDict']]]]
        """
        Stream logs and audit events with the Google Cloud Logging connector.
        """
        google_cloud_translations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Google Cloud Translation connector.
        """
        google_maps_places: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleMapsPlaceArgsDict']]]]
        """
        Get address autocompletions from Place Autocomplete Data API.
        """
        hibps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgsDict']]]]
        """
        Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
        """
        https: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgsDict']]]]
        """
        A general purpose HTTP client
        """
        hubspots: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgsDict']]]]
        """
        Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
        """
        incodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgsDict']]]]
        """
        Use the Incode connection to run identity verification processes like document checks or facial recognition.
        """
        intercoms: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgsDict']]]]
        """
        Orchestrate customer identity information from your Descope user journey with the Intercom connector.
        """
        lokalises: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Lokalise connector.
        """
        mparticles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgsDict']]]]
        """
        Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        """
        newrelics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgsDict']]]]
        """
        Stream authentication audit logs with the New Relic connector.
        """
        radars: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRadarArgsDict']]]]
        """
        Get address autocompletions from Radar Autocomplete API.
        """
        recaptcha_enterprises: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgsDict']]]]
        """
        Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
        """
        recaptchas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgsDict']]]]
        """
        Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
        """
        rekognitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgsDict']]]]
        """
        Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
        """
        salesforce_marketing_clouds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgsDict']]]]
        """
        Send transactional messages with the Salesforce Marketing Cloud connector.
        """
        salesforces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgsDict']]]]
        """
        Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
        """
        sardines: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSardineArgsDict']]]]
        """
        Evaluate customer risk using Sardine
        """
        segments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgsDict']]]]
        """
        Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
        """
        sendgrids: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgsDict']]]]
        """
        SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
        """
        ses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgsDict']]]]
        """
        Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
        """
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgsDict']]]]
        """
        Send updates to your team on Slack.
        """
        smartlings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgsDict']]]]
        """
        Localize the language of your login and user journey screens with the Smartling connector.
        """
        smtps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgsDict']]]]
        """
        Simple Mail Transfer Protocol (SMTP) server for sending emails.
        """
        sns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgsDict']]]]
        """
        Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
        """
        sumologics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgsDict']]]]
        """
        Stream logs and audit events with the Sumo Logic connector.
        """
        supabases: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSupabaseArgsDict']]]]
        """
        Generate external tokens for user authentication in Supabase projects.
        """
        telesigns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgsDict']]]]
        """
        Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
        """
        traceables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgsDict']]]]
        """
        Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
        """
        turnstiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTurnstileArgsDict']]]]
        """
        Prevent bot attacks on your login pages with the Turnstile connector.
        """
        twilio_cores: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgsDict']]]]
        """
        Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
        """
        twilio_verifies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgsDict']]]]
        """
        Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
        """
elif False:
    ProjectConnectorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsArgs:
    def __init__(__self__, *,
                 abuseipdbs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]] = None,
                 amplitudes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]] = None,
                 audit_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]] = None,
                 aws_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]] = None,
                 aws_translates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]] = None,
                 bitsights: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsBitsightArgs']]]] = None,
                 datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]] = None,
                 devrev_grows: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]] = None,
                 docebos: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]] = None,
                 eight_by_eight_vibers: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightViberArgs']]]] = None,
                 eight_by_eight_whatsapps: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightWhatsappArgs']]]] = None,
                 elephants: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsElephantArgs']]]] = None,
                 external_token_https: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsExternalTokenHttpArgs']]]] = None,
                 fingerprint_descopes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]] = None,
                 fingerprints: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]] = None,
                 firebase_admins: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFirebaseAdminArgs']]]] = None,
                 forters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]] = None,
                 generic_email_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericEmailGatewayArgs']]]] = None,
                 generic_sms_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]] = None,
                 google_cloud_loggings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingArgs']]]] = None,
                 google_cloud_translations: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]] = None,
                 google_maps_places: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleMapsPlaceArgs']]]] = None,
                 hibps: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]] = None,
                 https: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]] = None,
                 hubspots: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]] = None,
                 incodes: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]] = None,
                 intercoms: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]] = None,
                 lokalises: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]] = None,
                 mparticles: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]] = None,
                 newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]] = None,
                 radars: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRadarArgs']]]] = None,
                 recaptcha_enterprises: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]] = None,
                 recaptchas: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]] = None,
                 rekognitions: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]] = None,
                 salesforce_marketing_clouds: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]] = None,
                 salesforces: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]] = None,
                 sardines: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSardineArgs']]]] = None,
                 segments: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]] = None,
                 sendgrids: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]] = None,
                 ses: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]] = None,
                 smartlings: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]] = None,
                 smtps: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]] = None,
                 sns: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]] = None,
                 sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]] = None,
                 supabases: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSupabaseArgs']]]] = None,
                 telesigns: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]] = None,
                 traceables: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]] = None,
                 turnstiles: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTurnstileArgs']]]] = None,
                 twilio_cores: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]] = None,
                 twilio_verifies: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]] abuseipdbs: Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]] amplitudes: Track user activity and traits at any point in your user journey with the Amplitude connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]] audit_webhooks: Send audit events to a custom webhook.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]] aws_s3s: Stream authentication audit logs with the Amazon S3 connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]] aws_translates: Localize the language of your login and user journey screens with the Amazon Translate connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsBitsightArgs']]] bitsights: Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]] datadogs: Stream authentication audit logs with the Datadog connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]] devrev_grows: DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]] docebos: Get user information from Docebo in your Descope user journeys with the Docebo connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightViberArgs']]] eight_by_eight_vibers: Send Viber messages to the user.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightWhatsappArgs']]] eight_by_eight_whatsapps: Send WhatsApp messages to the user.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsElephantArgs']]] elephants: Use this connector to obtain an identity trust score.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsExternalTokenHttpArgs']]] external_token_https: A generic HTTP token connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]] fingerprint_descopes: Descope Fingerprint capabilities for fraud detection and risk assessment.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]] fingerprints: Prevent fraud by adding device intelligence with the Fingerprint connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFirebaseAdminArgs']]] firebase_admins: Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]] forters: Leverage ML-based risk scores for fraud prevention with the Forter connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericEmailGatewayArgs']]] generic_email_gateways: Send emails using a generic Email gateway.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]] generic_sms_gateways: Send messages using a generic SMS gateway.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingArgs']]] google_cloud_loggings: Stream logs and audit events with the Google Cloud Logging connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]] google_cloud_translations: Localize the language of your login and user journey screens with the Google Cloud Translation connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleMapsPlaceArgs']]] google_maps_places: Get address autocompletions from Place Autocomplete Data API.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]] hibps: Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]] https: A general purpose HTTP client
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]] hubspots: Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]] incodes: Use the Incode connection to run identity verification processes like document checks or facial recognition.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]] intercoms: Orchestrate customer identity information from your Descope user journey with the Intercom connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]] lokalises: Localize the language of your login and user journey screens with the Lokalise connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]] mparticles: Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]] newrelics: Stream authentication audit logs with the New Relic connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRadarArgs']]] radars: Get address autocompletions from Radar Autocomplete API.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]] recaptcha_enterprises: Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]] recaptchas: Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]] rekognitions: Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]] salesforce_marketing_clouds: Send transactional messages with the Salesforce Marketing Cloud connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]] salesforces: Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSardineArgs']]] sardines: Evaluate customer risk using Sardine
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]] segments: Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]] sendgrids: SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]] ses: Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]] slacks: Send updates to your team on Slack.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]] smartlings: Localize the language of your login and user journey screens with the Smartling connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]] smtps: Simple Mail Transfer Protocol (SMTP) server for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]] sns: Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]] sumologics: Stream logs and audit events with the Sumo Logic connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSupabaseArgs']]] supabases: Generate external tokens for user authentication in Supabase projects.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]] telesigns: Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]] traceables: Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTurnstileArgs']]] turnstiles: Prevent bot attacks on your login pages with the Turnstile connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]] twilio_cores: Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]] twilio_verifies: Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
        """
        if abuseipdbs is not None:
            pulumi.set(__self__, "abuseipdbs", abuseipdbs)
        if amplitudes is not None:
            pulumi.set(__self__, "amplitudes", amplitudes)
        if audit_webhooks is not None:
            pulumi.set(__self__, "audit_webhooks", audit_webhooks)
        if aws_s3s is not None:
            pulumi.set(__self__, "aws_s3s", aws_s3s)
        if aws_translates is not None:
            pulumi.set(__self__, "aws_translates", aws_translates)
        if bitsights is not None:
            pulumi.set(__self__, "bitsights", bitsights)
        if datadogs is not None:
            pulumi.set(__self__, "datadogs", datadogs)
        if devrev_grows is not None:
            pulumi.set(__self__, "devrev_grows", devrev_grows)
        if docebos is not None:
            pulumi.set(__self__, "docebos", docebos)
        if eight_by_eight_vibers is not None:
            pulumi.set(__self__, "eight_by_eight_vibers", eight_by_eight_vibers)
        if eight_by_eight_whatsapps is not None:
            pulumi.set(__self__, "eight_by_eight_whatsapps", eight_by_eight_whatsapps)
        if elephants is not None:
            pulumi.set(__self__, "elephants", elephants)
        if external_token_https is not None:
            pulumi.set(__self__, "external_token_https", external_token_https)
        if fingerprint_descopes is not None:
            pulumi.set(__self__, "fingerprint_descopes", fingerprint_descopes)
        if fingerprints is not None:
            pulumi.set(__self__, "fingerprints", fingerprints)
        if firebase_admins is not None:
            pulumi.set(__self__, "firebase_admins", firebase_admins)
        if forters is not None:
            pulumi.set(__self__, "forters", forters)
        if generic_email_gateways is not None:
            pulumi.set(__self__, "generic_email_gateways", generic_email_gateways)
        if generic_sms_gateways is not None:
            pulumi.set(__self__, "generic_sms_gateways", generic_sms_gateways)
        if google_cloud_loggings is not None:
            pulumi.set(__self__, "google_cloud_loggings", google_cloud_loggings)
        if google_cloud_translations is not None:
            pulumi.set(__self__, "google_cloud_translations", google_cloud_translations)
        if google_maps_places is not None:
            pulumi.set(__self__, "google_maps_places", google_maps_places)
        if hibps is not None:
            pulumi.set(__self__, "hibps", hibps)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if hubspots is not None:
            pulumi.set(__self__, "hubspots", hubspots)
        if incodes is not None:
            pulumi.set(__self__, "incodes", incodes)
        if intercoms is not None:
            pulumi.set(__self__, "intercoms", intercoms)
        if lokalises is not None:
            pulumi.set(__self__, "lokalises", lokalises)
        if mparticles is not None:
            pulumi.set(__self__, "mparticles", mparticles)
        if newrelics is not None:
            pulumi.set(__self__, "newrelics", newrelics)
        if radars is not None:
            pulumi.set(__self__, "radars", radars)
        if recaptcha_enterprises is not None:
            pulumi.set(__self__, "recaptcha_enterprises", recaptcha_enterprises)
        if recaptchas is not None:
            pulumi.set(__self__, "recaptchas", recaptchas)
        if rekognitions is not None:
            pulumi.set(__self__, "rekognitions", rekognitions)
        if salesforce_marketing_clouds is not None:
            pulumi.set(__self__, "salesforce_marketing_clouds", salesforce_marketing_clouds)
        if salesforces is not None:
            pulumi.set(__self__, "salesforces", salesforces)
        if sardines is not None:
            pulumi.set(__self__, "sardines", sardines)
        if segments is not None:
            pulumi.set(__self__, "segments", segments)
        if sendgrids is not None:
            pulumi.set(__self__, "sendgrids", sendgrids)
        if ses is not None:
            pulumi.set(__self__, "ses", ses)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)
        if smartlings is not None:
            pulumi.set(__self__, "smartlings", smartlings)
        if smtps is not None:
            pulumi.set(__self__, "smtps", smtps)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sumologics is not None:
            pulumi.set(__self__, "sumologics", sumologics)
        if supabases is not None:
            pulumi.set(__self__, "supabases", supabases)
        if telesigns is not None:
            pulumi.set(__self__, "telesigns", telesigns)
        if traceables is not None:
            pulumi.set(__self__, "traceables", traceables)
        if turnstiles is not None:
            pulumi.set(__self__, "turnstiles", turnstiles)
        if twilio_cores is not None:
            pulumi.set(__self__, "twilio_cores", twilio_cores)
        if twilio_verifies is not None:
            pulumi.set(__self__, "twilio_verifies", twilio_verifies)

    @_builtins.property
    @pulumi.getter
    def abuseipdbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]]:
        """
        Utilize IP threat intelligence to block malicious login attempts with the AbuseIPDB connector.
        """
        return pulumi.get(self, "abuseipdbs")

    @abuseipdbs.setter
    def abuseipdbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAbuseipdbArgs']]]]):
        pulumi.set(self, "abuseipdbs", value)

    @_builtins.property
    @pulumi.getter
    def amplitudes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]]:
        """
        Track user activity and traits at any point in your user journey with the Amplitude connector.
        """
        return pulumi.get(self, "amplitudes")

    @amplitudes.setter
    def amplitudes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAmplitudeArgs']]]]):
        pulumi.set(self, "amplitudes", value)

    @_builtins.property
    @pulumi.getter(name="auditWebhooks")
    def audit_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]]:
        """
        Send audit events to a custom webhook.
        """
        return pulumi.get(self, "audit_webhooks")

    @audit_webhooks.setter
    def audit_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookArgs']]]]):
        pulumi.set(self, "audit_webhooks", value)

    @_builtins.property
    @pulumi.getter(name="awsS3s")
    def aws_s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]]:
        """
        Stream authentication audit logs with the Amazon S3 connector.
        """
        return pulumi.get(self, "aws_s3s")

    @aws_s3s.setter
    def aws_s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3Args']]]]):
        pulumi.set(self, "aws_s3s", value)

    @_builtins.property
    @pulumi.getter(name="awsTranslates")
    def aws_translates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Amazon Translate connector.
        """
        return pulumi.get(self, "aws_translates")

    @aws_translates.setter
    def aws_translates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsTranslateArgs']]]]):
        pulumi.set(self, "aws_translates", value)

    @_builtins.property
    @pulumi.getter
    def bitsights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsBitsightArgs']]]]:
        """
        Utilize threat intelligence to block malicious login attempts or check leaks with the Bitsight Threat Intelligence connector.
        """
        return pulumi.get(self, "bitsights")

    @bitsights.setter
    def bitsights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsBitsightArgs']]]]):
        pulumi.set(self, "bitsights", value)

    @_builtins.property
    @pulumi.getter
    def datadogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]]:
        """
        Stream authentication audit logs with the Datadog connector.
        """
        return pulumi.get(self, "datadogs")

    @datadogs.setter
    def datadogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogArgs']]]]):
        pulumi.set(self, "datadogs", value)

    @_builtins.property
    @pulumi.getter(name="devrevGrows")
    def devrev_grows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]]:
        """
        DevRev Grow is a Growth CRM that brings salespeople, product marketers, and PMs onto an AI-native platform to follow the journey of a visitor to a lead, to a contact, and then to a user - to create a champion, not a churned user.
        """
        return pulumi.get(self, "devrev_grows")

    @devrev_grows.setter
    def devrev_grows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDevrevGrowArgs']]]]):
        pulumi.set(self, "devrev_grows", value)

    @_builtins.property
    @pulumi.getter
    def docebos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]]:
        """
        Get user information from Docebo in your Descope user journeys with the Docebo connector.
        """
        return pulumi.get(self, "docebos")

    @docebos.setter
    def docebos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDoceboArgs']]]]):
        pulumi.set(self, "docebos", value)

    @_builtins.property
    @pulumi.getter(name="eightByEightVibers")
    def eight_by_eight_vibers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightViberArgs']]]]:
        """
        Send Viber messages to the user.
        """
        return pulumi.get(self, "eight_by_eight_vibers")

    @eight_by_eight_vibers.setter
    def eight_by_eight_vibers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightViberArgs']]]]):
        pulumi.set(self, "eight_by_eight_vibers", value)

    @_builtins.property
    @pulumi.getter(name="eightByEightWhatsapps")
    def eight_by_eight_whatsapps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightWhatsappArgs']]]]:
        """
        Send WhatsApp messages to the user.
        """
        return pulumi.get(self, "eight_by_eight_whatsapps")

    @eight_by_eight_whatsapps.setter
    def eight_by_eight_whatsapps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsEightByEightWhatsappArgs']]]]):
        pulumi.set(self, "eight_by_eight_whatsapps", value)

    @_builtins.property
    @pulumi.getter
    def elephants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsElephantArgs']]]]:
        """
        Use this connector to obtain an identity trust score.
        """
        return pulumi.get(self, "elephants")

    @elephants.setter
    def elephants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsElephantArgs']]]]):
        pulumi.set(self, "elephants", value)

    @_builtins.property
    @pulumi.getter(name="externalTokenHttps")
    def external_token_https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsExternalTokenHttpArgs']]]]:
        """
        A generic HTTP token connector.
        """
        return pulumi.get(self, "external_token_https")

    @external_token_https.setter
    def external_token_https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsExternalTokenHttpArgs']]]]):
        pulumi.set(self, "external_token_https", value)

    @_builtins.property
    @pulumi.getter(name="fingerprintDescopes")
    def fingerprint_descopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]]:
        """
        Descope Fingerprint capabilities for fraud detection and risk assessment.
        """
        return pulumi.get(self, "fingerprint_descopes")

    @fingerprint_descopes.setter
    def fingerprint_descopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintDescopeArgs']]]]):
        pulumi.set(self, "fingerprint_descopes", value)

    @_builtins.property
    @pulumi.getter
    def fingerprints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]]:
        """
        Prevent fraud by adding device intelligence with the Fingerprint connector.
        """
        return pulumi.get(self, "fingerprints")

    @fingerprints.setter
    def fingerprints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFingerprintArgs']]]]):
        pulumi.set(self, "fingerprints", value)

    @_builtins.property
    @pulumi.getter(name="firebaseAdmins")
    def firebase_admins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFirebaseAdminArgs']]]]:
        """
        Firebase connector enables you to utilize Firebase's APIs to generate a Firebase user token for a given Descope user.
        """
        return pulumi.get(self, "firebase_admins")

    @firebase_admins.setter
    def firebase_admins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsFirebaseAdminArgs']]]]):
        pulumi.set(self, "firebase_admins", value)

    @_builtins.property
    @pulumi.getter
    def forters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]]:
        """
        Leverage ML-based risk scores for fraud prevention with the Forter connector.
        """
        return pulumi.get(self, "forters")

    @forters.setter
    def forters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsForterArgs']]]]):
        pulumi.set(self, "forters", value)

    @_builtins.property
    @pulumi.getter(name="genericEmailGateways")
    def generic_email_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericEmailGatewayArgs']]]]:
        """
        Send emails using a generic Email gateway.
        """
        return pulumi.get(self, "generic_email_gateways")

    @generic_email_gateways.setter
    def generic_email_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericEmailGatewayArgs']]]]):
        pulumi.set(self, "generic_email_gateways", value)

    @_builtins.property
    @pulumi.getter(name="genericSmsGateways")
    def generic_sms_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]]:
        """
        Send messages using a generic SMS gateway.
        """
        return pulumi.get(self, "generic_sms_gateways")

    @generic_sms_gateways.setter
    def generic_sms_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGenericSmsGatewayArgs']]]]):
        pulumi.set(self, "generic_sms_gateways", value)

    @_builtins.property
    @pulumi.getter(name="googleCloudLoggings")
    def google_cloud_loggings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingArgs']]]]:
        """
        Stream logs and audit events with the Google Cloud Logging connector.
        """
        return pulumi.get(self, "google_cloud_loggings")

    @google_cloud_loggings.setter
    def google_cloud_loggings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingArgs']]]]):
        pulumi.set(self, "google_cloud_loggings", value)

    @_builtins.property
    @pulumi.getter(name="googleCloudTranslations")
    def google_cloud_translations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Google Cloud Translation connector.
        """
        return pulumi.get(self, "google_cloud_translations")

    @google_cloud_translations.setter
    def google_cloud_translations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudTranslationArgs']]]]):
        pulumi.set(self, "google_cloud_translations", value)

    @_builtins.property
    @pulumi.getter(name="googleMapsPlaces")
    def google_maps_places(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleMapsPlaceArgs']]]]:
        """
        Get address autocompletions from Place Autocomplete Data API.
        """
        return pulumi.get(self, "google_maps_places")

    @google_maps_places.setter
    def google_maps_places(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleMapsPlaceArgs']]]]):
        pulumi.set(self, "google_maps_places", value)

    @_builtins.property
    @pulumi.getter
    def hibps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]]:
        """
        Check if passwords have been previously exposed in data breaches with the Have I Been Pwned connector.
        """
        return pulumi.get(self, "hibps")

    @hibps.setter
    def hibps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHibpArgs']]]]):
        pulumi.set(self, "hibps", value)

    @_builtins.property
    @pulumi.getter
    def https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]]:
        """
        A general purpose HTTP client
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHttpArgs']]]]):
        pulumi.set(self, "https", value)

    @_builtins.property
    @pulumi.getter
    def hubspots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]]:
        """
        Orchestrate customer identity information from your Descope user journey with the HubSpot connector.
        """
        return pulumi.get(self, "hubspots")

    @hubspots.setter
    def hubspots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsHubspotArgs']]]]):
        pulumi.set(self, "hubspots", value)

    @_builtins.property
    @pulumi.getter
    def incodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]]:
        """
        Use the Incode connection to run identity verification processes like document checks or facial recognition.
        """
        return pulumi.get(self, "incodes")

    @incodes.setter
    def incodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIncodeArgs']]]]):
        pulumi.set(self, "incodes", value)

    @_builtins.property
    @pulumi.getter
    def intercoms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]]:
        """
        Orchestrate customer identity information from your Descope user journey with the Intercom connector.
        """
        return pulumi.get(self, "intercoms")

    @intercoms.setter
    def intercoms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsIntercomArgs']]]]):
        pulumi.set(self, "intercoms", value)

    @_builtins.property
    @pulumi.getter
    def lokalises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Lokalise connector.
        """
        return pulumi.get(self, "lokalises")

    @lokalises.setter
    def lokalises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsLokaliseArgs']]]]):
        pulumi.set(self, "lokalises", value)

    @_builtins.property
    @pulumi.getter
    def mparticles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]]:
        """
        Track and send user event data (e.g. page views, purchases, etc.) across connected tools using the mParticle connector.
        """
        return pulumi.get(self, "mparticles")

    @mparticles.setter
    def mparticles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsMparticleArgs']]]]):
        pulumi.set(self, "mparticles", value)

    @_builtins.property
    @pulumi.getter
    def newrelics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]]:
        """
        Stream authentication audit logs with the New Relic connector.
        """
        return pulumi.get(self, "newrelics")

    @newrelics.setter
    def newrelics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicArgs']]]]):
        pulumi.set(self, "newrelics", value)

    @_builtins.property
    @pulumi.getter
    def radars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRadarArgs']]]]:
        """
        Get address autocompletions from Radar Autocomplete API.
        """
        return pulumi.get(self, "radars")

    @radars.setter
    def radars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRadarArgs']]]]):
        pulumi.set(self, "radars", value)

    @_builtins.property
    @pulumi.getter(name="recaptchaEnterprises")
    def recaptcha_enterprises(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]]:
        """
        Mitigate fraud using advanced risk analysis and add adaptive MFA with the reCAPTCHA Enterprise connector.
        """
        return pulumi.get(self, "recaptcha_enterprises")

    @recaptcha_enterprises.setter
    def recaptcha_enterprises(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaEnterpriseArgs']]]]):
        pulumi.set(self, "recaptcha_enterprises", value)

    @_builtins.property
    @pulumi.getter
    def recaptchas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]]:
        """
        Prevent bot attacks on your login pages with the reCAPTCHA v3 connector.
        """
        return pulumi.get(self, "recaptchas")

    @recaptchas.setter
    def recaptchas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRecaptchaArgs']]]]):
        pulumi.set(self, "recaptchas", value)

    @_builtins.property
    @pulumi.getter
    def rekognitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]]:
        """
        Add image recognition capabilities for identity verification and fraud prevention with the Amazon Rekognition connector.
        """
        return pulumi.get(self, "rekognitions")

    @rekognitions.setter
    def rekognitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsRekognitionArgs']]]]):
        pulumi.set(self, "rekognitions", value)

    @_builtins.property
    @pulumi.getter(name="salesforceMarketingClouds")
    def salesforce_marketing_clouds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]]:
        """
        Send transactional messages with the Salesforce Marketing Cloud connector.
        """
        return pulumi.get(self, "salesforce_marketing_clouds")

    @salesforce_marketing_clouds.setter
    def salesforce_marketing_clouds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceMarketingCloudArgs']]]]):
        pulumi.set(self, "salesforce_marketing_clouds", value)

    @_builtins.property
    @pulumi.getter
    def salesforces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]]:
        """
        Run SQL queries to retrieve user roles, profiles, account status, and more with the Salesforce connector.
        """
        return pulumi.get(self, "salesforces")

    @salesforces.setter
    def salesforces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSalesforceArgs']]]]):
        pulumi.set(self, "salesforces", value)

    @_builtins.property
    @pulumi.getter
    def sardines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSardineArgs']]]]:
        """
        Evaluate customer risk using Sardine
        """
        return pulumi.get(self, "sardines")

    @sardines.setter
    def sardines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSardineArgs']]]]):
        pulumi.set(self, "sardines", value)

    @_builtins.property
    @pulumi.getter
    def segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]]:
        """
        Orchestrate customer identity traits and signals from your Descope user journey with the Segment connector.
        """
        return pulumi.get(self, "segments")

    @segments.setter
    def segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSegmentArgs']]]]):
        pulumi.set(self, "segments", value)

    @_builtins.property
    @pulumi.getter
    def sendgrids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]]:
        """
        SendGrid is a cloud-based SMTP provider that allows you to send emails without having to maintain email servers.
        """
        return pulumi.get(self, "sendgrids")

    @sendgrids.setter
    def sendgrids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSendgridArgs']]]]):
        pulumi.set(self, "sendgrids", value)

    @_builtins.property
    @pulumi.getter
    def ses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]]:
        """
        Amazon Simple Email Service (SES) for sending emails through AWS infrastructure.
        """
        return pulumi.get(self, "ses")

    @ses.setter
    def ses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSeArgs']]]]):
        pulumi.set(self, "ses", value)

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]]:
        """
        Send updates to your team on Slack.
        """
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSlackArgs']]]]):
        pulumi.set(self, "slacks", value)

    @_builtins.property
    @pulumi.getter
    def smartlings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]]:
        """
        Localize the language of your login and user journey screens with the Smartling connector.
        """
        return pulumi.get(self, "smartlings")

    @smartlings.setter
    def smartlings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmartlingArgs']]]]):
        pulumi.set(self, "smartlings", value)

    @_builtins.property
    @pulumi.getter
    def smtps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]]:
        """
        Simple Mail Transfer Protocol (SMTP) server for sending emails.
        """
        return pulumi.get(self, "smtps")

    @smtps.setter
    def smtps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSmtpArgs']]]]):
        pulumi.set(self, "smtps", value)

    @_builtins.property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]]:
        """
        Amazon Simple Notification Service (SNS) for sending SMS messages through AWS.
        """
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSnArgs']]]]):
        pulumi.set(self, "sns", value)

    @_builtins.property
    @pulumi.getter
    def sumologics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]]:
        """
        Stream logs and audit events with the Sumo Logic connector.
        """
        return pulumi.get(self, "sumologics")

    @sumologics.setter
    def sumologics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicArgs']]]]):
        pulumi.set(self, "sumologics", value)

    @_builtins.property
    @pulumi.getter
    def supabases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSupabaseArgs']]]]:
        """
        Generate external tokens for user authentication in Supabase projects.
        """
        return pulumi.get(self, "supabases")

    @supabases.setter
    def supabases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSupabaseArgs']]]]):
        pulumi.set(self, "supabases", value)

    @_builtins.property
    @pulumi.getter
    def telesigns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]]:
        """
        Verify phone numbers and leverage granular risk scores for adaptive MFA with the Telesign Intelligence connector.
        """
        return pulumi.get(self, "telesigns")

    @telesigns.setter
    def telesigns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTelesignArgs']]]]):
        pulumi.set(self, "telesigns", value)

    @_builtins.property
    @pulumi.getter
    def traceables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]]:
        """
        Identify and respond to fraudulent login activity with the Traceable Digital Fraud Prevention connector.
        """
        return pulumi.get(self, "traceables")

    @traceables.setter
    def traceables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTraceableArgs']]]]):
        pulumi.set(self, "traceables", value)

    @_builtins.property
    @pulumi.getter
    def turnstiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTurnstileArgs']]]]:
        """
        Prevent bot attacks on your login pages with the Turnstile connector.
        """
        return pulumi.get(self, "turnstiles")

    @turnstiles.setter
    def turnstiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTurnstileArgs']]]]):
        pulumi.set(self, "turnstiles", value)

    @_builtins.property
    @pulumi.getter(name="twilioCores")
    def twilio_cores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]]:
        """
        Twilio is a cloud-based communication provider of communication tools for making and receiving phone calls, sending and receiving text messages, and performing other communication functions.
        """
        return pulumi.get(self, "twilio_cores")

    @twilio_cores.setter
    def twilio_cores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioCoreArgs']]]]):
        pulumi.set(self, "twilio_cores", value)

    @_builtins.property
    @pulumi.getter(name="twilioVerifies")
    def twilio_verifies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]]:
        """
        Twilio Verify is an OTP service that can be used via text messages, instant messaging platforms, voice and e-mail. Choose this connector only if you are a Twilio Verify customer.
        """
        return pulumi.get(self, "twilio_verifies")

    @twilio_verifies.setter
    def twilio_verifies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsTwilioVerifyArgs']]]]):
        pulumi.set(self, "twilio_verifies", value)


if not MYPY:
    class ProjectConnectorsAbuseipdbArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The unique AbuseIPDB API key.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsAbuseipdbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAbuseipdbArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The unique AbuseIPDB API key.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The unique AbuseIPDB API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsAmplitudeArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The Amplitude API Key generated for the Descope service.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        server_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        """
        server_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
elif False:
    ProjectConnectorsAmplitudeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAmplitudeArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_url: Optional[pulumi.Input[_builtins.str]] = None,
                 server_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The Amplitude API Key generated for the Descope service.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] server_url: The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        :param pulumi.Input[_builtins.str] server_zone: `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if server_zone is not None:
            pulumi.set(__self__, "server_zone", server_zone)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Amplitude API Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The server URL of the Amplitude API, when using different api or a custom domain in Amplitude.
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_url", value)

    @_builtins.property
    @pulumi.getter(name="serverZone")
    def server_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        `EU` or `US`. Sets the Amplitude server zone. Set this to `EU` for Amplitude projects created in `EU` data center. Default is `US`.
        """
        return pulumi.get(self, "server_zone")

    @server_zone.setter
    def server_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_zone", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookArgsDict(TypedDict):
        base_url: pulumi.Input[_builtins.str]
        """
        The base URL to fetch
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
elif False:
    ProjectConnectorsAuditWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]] = None,
                 authentication: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The base URL to fetch
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[_builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[_builtins.bool] insecure: Will ignore certificate errors raised by the client
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[_builtins.str]:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAuditWebhookAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsAuditWebhookAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict']]
        """
        API key authentication configuration.
        """
        basic: NotRequired[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict']]
        """
        Basic authentication credentials (username and password).
        """
        bearer_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bearer token for HTTP authentication.
        """
elif False:
    ProjectConnectorsAuditWebhookAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs'] api_key: API key authentication configuration.
        :param pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs'] basic: Basic authentication credentials (username and password).
        :param pulumi.Input[_builtins.str] bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']]:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']]:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsAuditWebhookAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The API key.
        """
        token: pulumi.Input[_builtins.str]
        """
        The API secret.
        """
elif False:
    ProjectConnectorsAuditWebhookAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The API key.
        :param pulumi.Input[_builtins.str] token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API secret.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for basic HTTP authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for basic HTTP authentication.
        """
elif False:
    ProjectConnectorsAuditWebhookAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAuditWebhookAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic HTTP authentication.
        :param pulumi.Input[_builtins.str] username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsAwsS3ArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The AWS S3 bucket. This bucket should already exist for the connector to work.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS S3 region, e.g. `us-east-1`.
        """
        access_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique AWS access key ID.
        """
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable streaming of audit events.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication type to use.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to use when assuming the role.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        secret_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret AWS access key.
        """
        troubleshoot_log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send troubleshooting events.
        """
elif False:
    ProjectConnectorsAwsS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsS3Args:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 access_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The AWS S3 bucket. This bucket should already exist for the connector to work.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] region: The AWS S3 region, e.g. `us-east-1`.
        :param pulumi.Input[_builtins.str] access_key_id: The unique AWS access key ID.
        :param pulumi.Input[_builtins.bool] audit_enabled: Whether to enable streaming of audit events.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input[_builtins.str] auth_type: The authentication type to use.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of the role to assume.
        :param pulumi.Input[_builtins.str] secret_access_key: The secret AWS access key.
        :param pulumi.Input[_builtins.bool] troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS S3 bucket. This bucket should already exist for the connector to work.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS S3 region, e.g. `us-east-1`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsAwsS3AuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret AWS access key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsAwsS3AuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsAwsS3AuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsS3AuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsAwsTranslateArgsDict(TypedDict):
        access_key_id: pulumi.Input[_builtins.str]
        """
        AWS access key ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[_builtins.str]
        """
        The AWS region to which this client will send requests. (e.g. us-east-1.)
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        AWS secret access key.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        session_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
elif False:
    ProjectConnectorsAwsTranslateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsAwsTranslateArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_id: AWS access key ID.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] region: The AWS region to which this client will send requests. (e.g. us-east-1.)
        :param pulumi.Input[_builtins.str] secret_access_key: AWS secret access key.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] session_token: (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        AWS access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS region to which this client will send requests. (e.g. us-east-1.)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        AWS secret access key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) A security or session token to use with these credentials. Usually present for temporary credentials.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_token", value)


if not MYPY:
    class ProjectConnectorsBitsightArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        Client secret issued when you create the credentials in Bitsight Threat Intelligence.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsBitsightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsBitsightArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
        :param pulumi.Input[_builtins.str] client_secret: Client secret issued when you create the credentials in Bitsight Threat Intelligence.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        API Client ID issued when you create the credentials in Bitsight Threat Intelligence.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        Client secret issued when you create the credentials in Bitsight Threat Intelligence.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The unique Datadog organization key.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable streaming of audit events.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        site: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        troubleshoot_log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send troubleshooting events.
        """
elif False:
    ProjectConnectorsDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 site: Optional[pulumi.Input[_builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The unique Datadog organization key.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.bool] audit_enabled: Whether to enable streaming of audit events.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] site: The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        :param pulumi.Input[_builtins.bool] troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Datadog organization key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsDatadogAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Datadog site to send logs to. Default is `datadoghq.com`. European, free tier and other customers should set their site accordingly.
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site", value)

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsDatadogAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsDatadogAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDatadogAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsDevrevGrowArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Authentication to DevRev APIs requires a personal access token (PAT).
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsDevrevGrowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDevrevGrowArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Authentication to DevRev APIs requires a personal access token (PAT).
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Authentication to DevRev APIs requires a personal access token (PAT).
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsDoceboArgsDict(TypedDict):
        base_url: pulumi.Input[_builtins.str]
        """
        The Docebo api base url.
        """
        client_id: pulumi.Input[_builtins.str]
        """
        The Docebo OAuth 2.0 app client ID.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        The Docebo OAuth 2.0 app client secret.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        password: pulumi.Input[_builtins.str]
        """
        The Docebo user's password.
        """
        username: pulumi.Input[_builtins.str]
        """
        The Docebo username.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsDoceboArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsDoceboArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[_builtins.str],
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The Docebo api base url.
        :param pulumi.Input[_builtins.str] client_id: The Docebo OAuth 2.0 app client ID.
        :param pulumi.Input[_builtins.str] client_secret: The Docebo OAuth 2.0 app client secret.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] password: The Docebo user's password.
        :param pulumi.Input[_builtins.str] username: The Docebo username.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Docebo api base url.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Docebo OAuth 2.0 app client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Docebo OAuth 2.0 app client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The Docebo user's password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        The Docebo username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsEightByEightViberArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The 8x8 API key for authentication.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        sub_account_id: pulumi.Input[_builtins.str]
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        The country code or region where your Viber messaging service is configured.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsEightByEightViberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsEightByEightViberArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 sub_account_id: pulumi.Input[_builtins.str],
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The 8x8 API key for authentication.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] sub_account_id: The 8x8 sub-account ID is required for the Messaging API.
        :param pulumi.Input[_builtins.str] country: The country code or region where your Viber messaging service is configured.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sub_account_id", sub_account_id)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The 8x8 API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subAccountId")
    def sub_account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        return pulumi.get(self, "sub_account_id")

    @sub_account_id.setter
    def sub_account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sub_account_id", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The country code or region where your Viber messaging service is configured.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsEightByEightWhatsappArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The 8x8 API key for authentication.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        sub_account_id: pulumi.Input[_builtins.str]
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        template_id: pulumi.Input[_builtins.str]
        """
        The ID of a WhatsApp message template.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        The country code or region where your Viber messaging service is configured.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsEightByEightWhatsappArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsEightByEightWhatsappArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 sub_account_id: pulumi.Input[_builtins.str],
                 template_id: pulumi.Input[_builtins.str],
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The 8x8 API key for authentication.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] sub_account_id: The 8x8 sub-account ID is required for the Messaging API.
        :param pulumi.Input[_builtins.str] template_id: The ID of a WhatsApp message template.
        :param pulumi.Input[_builtins.str] country: The country code or region where your Viber messaging service is configured.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sub_account_id", sub_account_id)
        pulumi.set(__self__, "template_id", template_id)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The 8x8 API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subAccountId")
    def sub_account_id(self) -> pulumi.Input[_builtins.str]:
        """
        The 8x8 sub-account ID is required for the Messaging API.
        """
        return pulumi.get(self, "sub_account_id")

    @sub_account_id.setter
    def sub_account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sub_account_id", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of a WhatsApp message template.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The country code or region where your Viber messaging service is configured.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsElephantArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        The Elephant access key.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsElephantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsElephantArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: The Elephant access key.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Elephant access key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsExternalTokenHttpArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsExternalTokenHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsExternalTokenHttpArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[_builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[_builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint to get the token from (Using POST method). Descope will send the user information in the body of the request, and should return a JSON response with a 'token' string field.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsExternalTokenHttpAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgsDict']]
        """
        API key authentication configuration.
        """
        basic: NotRequired[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationBasicArgsDict']]
        """
        Basic authentication credentials (username and password).
        """
        bearer_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bearer token for HTTP authentication.
        """
elif False:
    ProjectConnectorsExternalTokenHttpAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsExternalTokenHttpAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs'] api_key: API key authentication configuration.
        :param pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs'] basic: Basic authentication credentials (username and password).
        :param pulumi.Input[_builtins.str] bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs']]:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs']]:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The API key.
        """
        token: pulumi.Input[_builtins.str]
        """
        The API secret.
        """
elif False:
    ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsExternalTokenHttpAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The API key.
        :param pulumi.Input[_builtins.str] token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API secret.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsExternalTokenHttpAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for basic HTTP authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for basic HTTP authentication.
        """
elif False:
    ProjectConnectorsExternalTokenHttpAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsExternalTokenHttpAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic HTTP authentication.
        :param pulumi.Input[_builtins.str] username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsFingerprintArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        public_api_key: pulumi.Input[_builtins.str]
        """
        The Fingerprint public API key.
        """
        secret_api_key: pulumi.Input[_builtins.str]
        """
        The Fingerprint secret API key.
        """
        cloudflare_endpoint_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloudflare integration Endpoint URL.
        """
        cloudflare_script_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloudflare integration Script URL.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_cloudflare_integration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
elif False:
    ProjectConnectorsFingerprintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsFingerprintArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 public_api_key: pulumi.Input[_builtins.str],
                 secret_api_key: pulumi.Input[_builtins.str],
                 cloudflare_endpoint_url: Optional[pulumi.Input[_builtins.str]] = None,
                 cloudflare_script_url: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_cloudflare_integration: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] public_api_key: The Fingerprint public API key.
        :param pulumi.Input[_builtins.str] secret_api_key: The Fingerprint secret API key.
        :param pulumi.Input[_builtins.str] cloudflare_endpoint_url: The Cloudflare integration Endpoint URL.
        :param pulumi.Input[_builtins.str] cloudflare_script_url: The Cloudflare integration Script URL.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_cloudflare_integration: Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        pulumi.set(__self__, "secret_api_key", secret_api_key)
        if cloudflare_endpoint_url is not None:
            pulumi.set(__self__, "cloudflare_endpoint_url", cloudflare_endpoint_url)
        if cloudflare_script_url is not None:
            pulumi.set(__self__, "cloudflare_script_url", cloudflare_script_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_cloudflare_integration is not None:
            pulumi.set(__self__, "use_cloudflare_integration", use_cloudflare_integration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Fingerprint public API key.
        """
        return pulumi.get(self, "public_api_key")

    @public_api_key.setter
    def public_api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_api_key", value)

    @_builtins.property
    @pulumi.getter(name="secretApiKey")
    def secret_api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Fingerprint secret API key.
        """
        return pulumi.get(self, "secret_api_key")

    @secret_api_key.setter
    def secret_api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_api_key", value)

    @_builtins.property
    @pulumi.getter(name="cloudflareEndpointUrl")
    def cloudflare_endpoint_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloudflare integration Endpoint URL.
        """
        return pulumi.get(self, "cloudflare_endpoint_url")

    @cloudflare_endpoint_url.setter
    def cloudflare_endpoint_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloudflare_endpoint_url", value)

    @_builtins.property
    @pulumi.getter(name="cloudflareScriptUrl")
    def cloudflare_script_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloudflare integration Script URL.
        """
        return pulumi.get(self, "cloudflare_script_url")

    @cloudflare_script_url.setter
    def cloudflare_script_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloudflare_script_url", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useCloudflareIntegration")
    def use_cloudflare_integration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to configure the relevant Cloudflare integration parameters if Cloudflare integration is set in your Fingerprint account.
        """
        return pulumi.get(self, "use_cloudflare_integration")

    @use_cloudflare_integration.setter
    def use_cloudflare_integration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cloudflare_integration", value)


if not MYPY:
    class ProjectConnectorsFingerprintDescopeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        custom_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom domain to fetch
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsFingerprintDescopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsFingerprintDescopeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 custom_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] custom_domain: The custom domain to fetch
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom domain to fetch
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_domain", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsFirebaseAdminArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        service_account: pulumi.Input[_builtins.str]
        """
        The Firebase service account JSON.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsFirebaseAdminArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsFirebaseAdminArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 service_account: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] service_account: The Firebase service account JSON.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_account", service_account)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[_builtins.str]:
        """
        The Firebase service account JSON.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsForterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The Forter secret key.
        """
        site_id: pulumi.Input[_builtins.str]
        """
        The Forter site ID.
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Forter API version.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        override_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override the user IP address.
        """
        override_user_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override the user email.
        """
        overrides: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
elif False:
    ProjectConnectorsForterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsForterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 site_id: pulumi.Input[_builtins.str],
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 override_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 override_user_email: Optional[pulumi.Input[_builtins.str]] = None,
                 overrides: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] secret_key: The Forter secret key.
        :param pulumi.Input[_builtins.str] site_id: The Forter site ID.
        :param pulumi.Input[_builtins.str] api_version: The Forter API version.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] override_ip_address: Override the user IP address.
        :param pulumi.Input[_builtins.str] override_user_email: Override the user email.
        :param pulumi.Input[_builtins.bool] overrides: Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_id", site_id)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_ip_address is not None:
            pulumi.set(__self__, "override_ip_address", override_ip_address)
        if override_user_email is not None:
            pulumi.set(__self__, "override_user_email", override_user_email)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Forter secret key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Forter site ID.
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_id", value)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Forter API version.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="overrideIpAddress")
    def override_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override the user IP address.
        """
        return pulumi.get(self, "override_ip_address")

    @override_ip_address.setter
    def override_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="overrideUserEmail")
    def override_user_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override the user email.
        """
        return pulumi.get(self, "override_user_email")

    @override_user_email.setter
    def override_user_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_user_email", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override the user's IP address or email so that Forter can provide a specific decision or recommendation. Contact the Forter team for further details. Note: Overriding the user IP address or email is intended for testing purpose and should not be utilized in production environments.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overrides", value)


if not MYPY:
    class ProjectConnectorsGenericEmailGatewayArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        post_url: pulumi.Input[_builtins.str]
        """
        The URL of the post email request
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        sender: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sender address
        """
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsGenericEmailGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericEmailGatewayArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 post_url: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure: Optional[pulumi.Input[_builtins.bool]] = None,
                 sender: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] post_url: The URL of the post email request
        :param pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[_builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[_builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[_builtins.str] sender: The sender address
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "post_url", post_url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="postUrl")
    def post_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the post email request
        """
        return pulumi.get(self, "post_url")

    @post_url.setter
    def post_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "post_url", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sender address
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsGenericEmailGatewayAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgsDict']]
        """
        API key authentication configuration.
        """
        basic: NotRequired[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgsDict']]
        """
        Basic authentication credentials (username and password).
        """
        bearer_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bearer token for HTTP authentication.
        """
elif False:
    ProjectConnectorsGenericEmailGatewayAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericEmailGatewayAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs'] api_key: API key authentication configuration.
        :param pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs'] basic: Basic authentication credentials (username and password).
        :param pulumi.Input[_builtins.str] bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs']]:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs']]:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The API key.
        """
        token: pulumi.Input[_builtins.str]
        """
        The API secret.
        """
elif False:
    ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericEmailGatewayAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The API key.
        :param pulumi.Input[_builtins.str] token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API secret.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for basic HTTP authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for basic HTTP authentication.
        """
elif False:
    ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericEmailGatewayAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic HTTP authentication.
        :param pulumi.Input[_builtins.str] username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        post_url: pulumi.Input[_builtins.str]
        """
        The URL of the post message request
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        sender: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sender number
        """
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsGenericSmsGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 post_url: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure: Optional[pulumi.Input[_builtins.bool]] = None,
                 sender: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] post_url: The URL of the post message request
        :param pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[_builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[_builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[_builtins.str] sender: The sender number
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "post_url", post_url)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="postUrl")
    def post_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the post message request
        """
        return pulumi.get(self, "post_url")

    @post_url.setter
    def post_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "post_url", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sender number
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict']]
        """
        API key authentication configuration.
        """
        basic: NotRequired[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict']]
        """
        Basic authentication credentials (username and password).
        """
        bearer_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bearer token for HTTP authentication.
        """
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs'] api_key: API key authentication configuration.
        :param pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs'] basic: Basic authentication credentials (username and password).
        :param pulumi.Input[_builtins.str] bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']]:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']]:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The API key.
        """
        token: pulumi.Input[_builtins.str]
        """
        The API secret.
        """
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The API key.
        :param pulumi.Input[_builtins.str] token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API secret.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for basic HTTP authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for basic HTTP authentication.
        """
elif False:
    ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGenericSmsGatewayAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic HTTP authentication.
        :param pulumi.Input[_builtins.str] username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsGoogleCloudLoggingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        service_account_key: pulumi.Input[_builtins.str]
        """
        A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
        """
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable streaming of audit events.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        troubleshoot_log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send troubleshooting events.
        """
elif False:
    ProjectConnectorsGoogleCloudLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGoogleCloudLoggingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 service_account_key: pulumi.Input[_builtins.str],
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingAuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] service_account_key: A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
        :param pulumi.Input[_builtins.bool] audit_enabled: Whether to enable streaming of audit events.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_account_key", service_account_key)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> pulumi.Input[_builtins.str]:
        """
        A Service Account Key JSON file created from a service account on your Google Cloud project. This file is used to authenticate and authorize the connector to access Google Cloud Logging. The service account this key belongs to must have the appropriate permissions to write logs.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account_key", value)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsGoogleCloudLoggingAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsGoogleCloudLoggingAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsGoogleCloudLoggingAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGoogleCloudLoggingAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsGoogleCloudTranslationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The Google Cloud project ID where the Google Cloud Translation is managed.
        """
        service_account_json: pulumi.Input[_builtins.str]
        """
        Service Account JSON associated with the current project.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsGoogleCloudTranslationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGoogleCloudTranslationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 service_account_json: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] project_id: The Google Cloud project ID where the Google Cloud Translation is managed.
        :param pulumi.Input[_builtins.str] service_account_json: Service Account JSON associated with the current project.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account_json", service_account_json)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Cloud project ID where the Google Cloud Translation is managed.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountJson")
    def service_account_json(self) -> pulumi.Input[_builtins.str]:
        """
        Service Account JSON associated with the current project.
        """
        return pulumi.get(self, "service_account_json")

    @service_account_json.setter
    def service_account_json(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account_json", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsGoogleMapsPlaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        public_api_key: pulumi.Input[_builtins.str]
        """
        The Google Maps Places public API key.
        """
        address_types: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address types to return.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        language: NotRequired[pulumi.Input[_builtins.str]]
        """
        The language in which to return results.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region code, specified as a CLDR two-character region code.
        """
elif False:
    ProjectConnectorsGoogleMapsPlaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsGoogleMapsPlaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 public_api_key: pulumi.Input[_builtins.str],
                 address_types: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 language: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] public_api_key: The Google Maps Places public API key.
        :param pulumi.Input[_builtins.str] address_types: The address types to return.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] language: The language in which to return results.
        :param pulumi.Input[_builtins.str] region: The region code, specified as a CLDR two-character region code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        if address_types is not None:
            pulumi.set(__self__, "address_types", address_types)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Maps Places public API key.
        """
        return pulumi.get(self, "public_api_key")

    @public_api_key.setter
    def public_api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_api_key", value)

    @_builtins.property
    @pulumi.getter(name="addressTypes")
    def address_types(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address types to return.
        """
        return pulumi.get(self, "address_types")

    @address_types.setter
    def address_types(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_types", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The language in which to return results.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region code, specified as a CLDR two-character region code.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ProjectConnectorsHibpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsHibpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHibpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsHttpArgsDict(TypedDict):
        base_url: pulumi.Input[_builtins.str]
        """
        The base URL to fetch
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        authentication: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationArgsDict']]
        """
        Authentication Information
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The headers to send with the request
        """
        hmac_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        include_headers_in_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        """
        insecure: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Will ignore certificate errors raised by the client
        """
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hmac_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 include_headers_in_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 insecure: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The base URL to fetch
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsHttpAuthenticationArgs'] authentication: Authentication Information
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: The headers to send with the request
        :param pulumi.Input[_builtins.str] hmac_secret: HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        :param pulumi.Input[_builtins.bool] include_headers_in_context: The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        :param pulumi.Input[_builtins.bool] insecure: Will ignore certificate errors raised by the client
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "name", name)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if hmac_secret is not None:
            pulumi.set(__self__, "hmac_secret", hmac_secret)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_headers_in_context is not None:
            pulumi.set(__self__, "include_headers_in_context", include_headers_in_context)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[_builtins.str]:
        """
        The base URL to fetch
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']]:
        """
        Authentication Information
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The headers to send with the request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecret")
    def hmac_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HMAC is a method for message signing with a symmetrical key. This secret will be used to sign the base64 encoded payload, and the resulting signature will be sent in the `x-descope-webhook-s256` header. The receiving service should use this secret to verify the integrity and authenticity of the payload by checking the provided signature
        """
        return pulumi.get(self, "hmac_secret")

    @hmac_secret.setter
    def hmac_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hmac_secret", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="includeHeadersInContext")
    def include_headers_in_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The connector response context will also include the headers. The context will have a "body" attribute and a "headers" attribute. See more details in the help guide
        """
        return pulumi.get(self, "include_headers_in_context")

    @include_headers_in_context.setter
    def include_headers_in_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_headers_in_context", value)

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Will ignore certificate errors raised by the client
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgsDict']]
        """
        API key authentication configuration.
        """
        basic: NotRequired[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgsDict']]
        """
        Basic authentication credentials (username and password).
        """
        bearer_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bearer token for HTTP authentication.
        """
elif False:
    ProjectConnectorsHttpAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']] = None,
                 basic: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']] = None,
                 bearer_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs'] api_key: API key authentication configuration.
        :param pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs'] basic: Basic authentication credentials (username and password).
        :param pulumi.Input[_builtins.str] bearer_token: Bearer token for HTTP authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']]:
        """
        API key authentication configuration.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']]:
        """
        Basic authentication credentials (username and password).
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input['ProjectConnectorsHttpAuthenticationBasicArgs']]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bearer token for HTTP authentication.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bearer_token", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationApiKeyArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The API key.
        """
        token: pulumi.Input[_builtins.str]
        """
        The API secret.
        """
elif False:
    ProjectConnectorsHttpAuthenticationApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationApiKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The API key.
        :param pulumi.Input[_builtins.str] token: The API secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The API key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API secret.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ProjectConnectorsHttpAuthenticationBasicArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for basic HTTP authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for basic HTTP authentication.
        """
elif False:
    ProjectConnectorsHttpAuthenticationBasicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHttpAuthenticationBasicArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic HTTP authentication.
        :param pulumi.Input[_builtins.str] username: Username for basic HTTP authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for basic HTTP authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for basic HTTP authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectConnectorsHubspotArgsDict(TypedDict):
        access_token: pulumi.Input[_builtins.str]
        """
        The HubSpot private API access token generated for the Descope service.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsHubspotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsHubspotArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] access_token: The HubSpot private API access token generated for the Descope service.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] base_url: The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[_builtins.str]:
        """
        The HubSpot private API access token generated for the Descope service.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of the HubSpot API, when using a custom domain in HubSpot, default value is https://api.hubapi.com .
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsIncodeArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Your InCode API key.
        """
        api_url: pulumi.Input[_builtins.str]
        """
        The base URL of the Incode API
        """
        flow_id: pulumi.Input[_builtins.str]
        """
        Your wanted InCode's flow ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsIncodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsIncodeArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 api_url: pulumi.Input[_builtins.str],
                 flow_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Your InCode API key.
        :param pulumi.Input[_builtins.str] api_url: The base URL of the Incode API
        :param pulumi.Input[_builtins.str] flow_id: Your wanted InCode's flow ID.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "flow_id", flow_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your InCode API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> pulumi.Input[_builtins.str]:
        """
        The base URL of the Incode API
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_url", value)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> pulumi.Input[_builtins.str]:
        """
        Your wanted InCode's flow ID.
        """
        return pulumi.get(self, "flow_id")

    @flow_id.setter
    def flow_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flow_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsIntercomArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        token: pulumi.Input[_builtins.str]
        """
        The Intercom access token.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regional Hosting - US, EU, or AU. default: US
        """
elif False:
    ProjectConnectorsIntercomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsIntercomArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] token: The Intercom access token.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] region: Regional Hosting - US, EU, or AU. default: US
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Intercom access token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regional Hosting - US, EU, or AU. default: US
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ProjectConnectorsLokaliseArgsDict(TypedDict):
        api_token: pulumi.Input[_builtins.str]
        """
        Lokalise API token.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        Lokalise project ID.
        """
        card_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        team_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Lokalise team ID. If not provided, the oldest available team will be used.
        """
        translation_provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
elif False:
    ProjectConnectorsLokaliseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsLokaliseArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 card_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 team_id: Optional[pulumi.Input[_builtins.str]] = None,
                 translation_provider: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_token: Lokalise API token.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] project_id: Lokalise project ID.
        :param pulumi.Input[_builtins.str] card_id: (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] team_id: Lokalise team ID. If not provided, the oldest available team will be used.
        :param pulumi.Input[_builtins.str] translation_provider: The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if card_id is not None:
            pulumi.set(__self__, "card_id", card_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if translation_provider is not None:
            pulumi.set(__self__, "translation_provider", translation_provider)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[_builtins.str]:
        """
        Lokalise API token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_token", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Lokalise project ID.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="cardId")
    def card_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional) The ID of the payment card to use for translation orders. If not provided, the team credit will be used.
        """
        return pulumi.get(self, "card_id")

    @card_id.setter
    def card_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "card_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Lokalise team ID. If not provided, the oldest available team will be used.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team_id", value)

    @_builtins.property
    @pulumi.getter(name="translationProvider")
    def translation_provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The translation provider to use ('gengo', 'google', 'lokalise', 'deepl'), default is 'deepl'.
        """
        return pulumi.get(self, "translation_provider")

    @translation_provider.setter
    def translation_provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "translation_provider", value)


if not MYPY:
    class ProjectConnectorsMparticleArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The mParticle Server to Server Key generated for the Descope service.
        """
        api_secret: pulumi.Input[_builtins.str]
        """
        The mParticle Server to Server Secret generated for the Descope service.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        """
        default_environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsMparticleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsMparticleArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 api_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 default_environment: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The mParticle Server to Server Key generated for the Descope service.
        :param pulumi.Input[_builtins.str] api_secret: The mParticle Server to Server Secret generated for the Descope service.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] base_url: The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        :param pulumi.Input[_builtins.str] default_environment: The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "name", name)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if default_environment is not None:
            pulumi.set(__self__, "default_environment", default_environment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The mParticle Server to Server Key generated for the Descope service.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The mParticle Server to Server Secret generated for the Descope service.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of the mParticle API, when using a custom domain in mParticle. default value is https://s2s.mparticle.com/
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="defaultEnvironment")
    def default_environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default environment of which connector send data to, either production or development. default value: production. This field can be overridden per event (see at flows).
        """
        return pulumi.get(self, "default_environment")

    @default_environment.setter
    def default_environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_environment", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsNewrelicArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Ingest License Key of the account you want to report data to.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable streaming of audit events.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        data_center: NotRequired[pulumi.Input[_builtins.str]]
        """
        The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        logs_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify a custom prefix for all log fields. The default prefix is `descope.`.
        """
        override_logs_prefix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable this option to use a custom prefix for log fields.
        """
        troubleshoot_log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send troubleshooting events.
        """
elif False:
    ProjectConnectorsNewrelicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsNewrelicArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]] = None,
                 data_center: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 logs_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 override_logs_prefix: Optional[pulumi.Input[_builtins.bool]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Ingest License Key of the account you want to report data to.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.bool] audit_enabled: Whether to enable streaming of audit events.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input[_builtins.str] data_center: The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] logs_prefix: Specify a custom prefix for all log fields. The default prefix is `descope.`.
        :param pulumi.Input[_builtins.bool] override_logs_prefix: Enable this option to use a custom prefix for log fields.
        :param pulumi.Input[_builtins.bool] troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if data_center is not None:
            pulumi.set(__self__, "data_center", data_center)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logs_prefix is not None:
            pulumi.set(__self__, "logs_prefix", logs_prefix)
        if override_logs_prefix is not None:
            pulumi.set(__self__, "override_logs_prefix", override_logs_prefix)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Ingest License Key of the account you want to report data to.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsNewrelicAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The New Relic data center the account belongs to. Possible values are: `US`, `EU`, `FedRAMP`. Default is `US`.
        """
        return pulumi.get(self, "data_center")

    @data_center.setter
    def data_center(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_center", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="logsPrefix")
    def logs_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify a custom prefix for all log fields. The default prefix is `descope.`.
        """
        return pulumi.get(self, "logs_prefix")

    @logs_prefix.setter
    def logs_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logs_prefix", value)

    @_builtins.property
    @pulumi.getter(name="overrideLogsPrefix")
    def override_logs_prefix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable this option to use a custom prefix for log fields.
        """
        return pulumi.get(self, "override_logs_prefix")

    @override_logs_prefix.setter
    def override_logs_prefix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_logs_prefix", value)

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsNewrelicAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsNewrelicAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsNewrelicAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsRadarArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        public_api_key: pulumi.Input[_builtins.str]
        """
        The Radar publishable API key.
        """
        address_types: NotRequired[pulumi.Input[_builtins.str]]
        """
        The address types to return.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        language: NotRequired[pulumi.Input[_builtins.str]]
        """
        The language in which to return results.
        """
        limit: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum number of results to return.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region code, specified as a two-letter ISO 3166 code.
        """
elif False:
    ProjectConnectorsRadarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRadarArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 public_api_key: pulumi.Input[_builtins.str],
                 address_types: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 language: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input[_builtins.float]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] public_api_key: The Radar publishable API key.
        :param pulumi.Input[_builtins.str] address_types: The address types to return.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] language: The language in which to return results.
        :param pulumi.Input[_builtins.float] limit: The maximum number of results to return.
        :param pulumi.Input[_builtins.str] region: The region code, specified as a two-letter ISO 3166 code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_api_key", public_api_key)
        if address_types is not None:
            pulumi.set(__self__, "address_types", address_types)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicApiKey")
    def public_api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Radar publishable API key.
        """
        return pulumi.get(self, "public_api_key")

    @public_api_key.setter
    def public_api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_api_key", value)

    @_builtins.property
    @pulumi.getter(name="addressTypes")
    def address_types(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The address types to return.
        """
        return pulumi.get(self, "address_types")

    @address_types.setter
    def address_types(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address_types", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The language in which to return results.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum number of results to return.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region code, specified as a two-letter ISO 3166 code.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ProjectConnectorsRecaptchaArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        """
        site_key: pulumi.Input[_builtins.str]
        """
        The site key is used to invoke reCAPTCHA service on your site or mobile application.
        """
        assessment_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        override_assessment: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
elif False:
    ProjectConnectorsRecaptchaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRecaptchaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 site_key: pulumi.Input[_builtins.str],
                 assessment_score: Optional[pulumi.Input[_builtins.float]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 override_assessment: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] secret_key: The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        :param pulumi.Input[_builtins.str] site_key: The site key is used to invoke reCAPTCHA service on your site or mobile application.
        :param pulumi.Input[_builtins.float] assessment_score: When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] override_assessment: Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_key", site_key)
        if assessment_score is not None:
            pulumi.set(__self__, "assessment_score", assessment_score)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_assessment is not None:
            pulumi.set(__self__, "override_assessment", override_assessment)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key authorizes communication between Descope backend and the reCAPTCHA server to verify the user's response.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> pulumi.Input[_builtins.str]:
        """
        The site key is used to invoke reCAPTCHA service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_key", value)

    @_builtins.property
    @pulumi.getter(name="assessmentScore")
    def assessment_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        return pulumi.get(self, "assessment_score")

    @assessment_score.setter
    def assessment_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "assessment_score", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="overrideAssessment")
    def override_assessment(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        return pulumi.get(self, "override_assessment")

    @override_assessment.setter
    def override_assessment(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_assessment", value)


if not MYPY:
    class ProjectConnectorsRecaptchaEnterpriseArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        API key associated with the current project.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        """
        site_key: pulumi.Input[_builtins.str]
        """
        The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        """
        assessment_score: NotRequired[pulumi.Input[_builtins.float]]
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
        """
        bot_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        override_assessment: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
elif False:
    ProjectConnectorsRecaptchaEnterpriseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRecaptchaEnterpriseArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 site_key: pulumi.Input[_builtins.str],
                 assessment_score: Optional[pulumi.Input[_builtins.float]] = None,
                 base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 bot_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 override_assessment: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: API key associated with the current project.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] project_id: The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        :param pulumi.Input[_builtins.str] site_key: The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        :param pulumi.Input[_builtins.float] assessment_score: When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        :param pulumi.Input[_builtins.str] base_url: Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
        :param pulumi.Input[_builtins.float] bot_threshold: The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] override_assessment: Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "site_key", site_key)
        if assessment_score is not None:
            pulumi.set(__self__, "assessment_score", assessment_score)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if bot_threshold is not None:
            pulumi.set(__self__, "bot_threshold", bot_threshold)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_assessment is not None:
            pulumi.set(__self__, "override_assessment", override_assessment)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        API key associated with the current project.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Cloud project ID where the reCAPTCHA Enterprise is managed.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> pulumi.Input[_builtins.str]:
        """
        The site key is used to invoke reCAPTCHA Enterprise service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_key", value)

    @_builtins.property
    @pulumi.getter(name="assessmentScore")
    def assessment_score(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        When configured, the Recaptcha action will return the score without assessing the request. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot.
        """
        return pulumi.get(self, "assessment_score")

    @assessment_score.setter
    def assessment_score(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "assessment_score", value)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apply a custom url to the reCAPTCHA Enterprise scripts. This is useful when attempting to use reCAPTCHA globally. Defaults to https://www.google.com
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="botThreshold")
    def bot_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The bot threshold is used to determine whether the request is a bot or a human. The score ranges between 0 and 1, where 1 is a human interaction and 0 is a bot. If the score is below this threshold, the request is considered a bot.
        """
        return pulumi.get(self, "bot_threshold")

    @bot_threshold.setter
    def bot_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "bot_threshold", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="overrideAssessment")
    def override_assessment(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Override the default assessment model. Note: Overriding assessment is intended for automated testing and should not be utilized in production environments.
        """
        return pulumi.get(self, "override_assessment")

    @override_assessment.setter
    def override_assessment(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "override_assessment", value)


if not MYPY:
    class ProjectConnectorsRekognitionArgsDict(TypedDict):
        access_key_id: pulumi.Input[_builtins.str]
        """
        The AWS access key ID
        """
        collection_id: pulumi.Input[_builtins.str]
        """
        The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        The AWS secret access key
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsRekognitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsRekognitionArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[_builtins.str],
                 collection_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_id: The AWS access key ID
        :param pulumi.Input[_builtins.str] collection_id: The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] secret_access_key: The AWS secret access key
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "collection_id", collection_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS access key ID
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> pulumi.Input[_builtins.str]:
        """
        The collection to store registered users in. Should match `[a-zA-Z0-9_.-]+` pattern. Changing this will cause losing existing users.
        """
        return pulumi.get(self, "collection_id")

    @collection_id.setter
    def collection_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS secret access key
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSalesforceArgsDict(TypedDict):
        base_url: pulumi.Input[_builtins.str]
        """
        The Salesforce API base URL.
        """
        client_id: pulumi.Input[_builtins.str]
        """
        The consumer key of the connected app.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        The consumer secret of the connected app.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        version: pulumi.Input[_builtins.str]
        """
        REST API Version.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSalesforceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSalesforceArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[_builtins.str],
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The Salesforce API base URL.
        :param pulumi.Input[_builtins.str] client_id: The consumer key of the connected app.
        :param pulumi.Input[_builtins.str] client_secret: The consumer secret of the connected app.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] version: REST API Version.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce API base URL.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The consumer key of the connected app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The consumer secret of the connected app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        REST API Version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSalesforceMarketingCloudArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        Client ID issued when you create the API integration in Installed Packages.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        Client secret issued when you create the API integration in Installed Packages.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        subdomain: pulumi.Input[_builtins.str]
        """
        The Salesforce Marketing Cloud endpoint subdomain.
        """
        account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account identifier, or MID, of the target business unit.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Space-separated list of data-access permissions for your connector.
        """
elif False:
    ProjectConnectorsSalesforceMarketingCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSalesforceMarketingCloudArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subdomain: pulumi.Input[_builtins.str],
                 account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: Client ID issued when you create the API integration in Installed Packages.
        :param pulumi.Input[_builtins.str] client_secret: Client secret issued when you create the API integration in Installed Packages.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] subdomain: The Salesforce Marketing Cloud endpoint subdomain.
        :param pulumi.Input[_builtins.str] account_id: Account identifier, or MID, of the target business unit.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] scope: Space-separated list of data-access permissions for your connector.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subdomain", subdomain)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        Client ID issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        Client secret issued when you create the API integration in Installed Packages.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce Marketing Cloud endpoint subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subdomain", value)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account identifier, or MID, of the target business unit.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Space-separated list of data-access permissions for your connector.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ProjectConnectorsSardineArgsDict(TypedDict):
        base_url: pulumi.Input[_builtins.str]
        """
        The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
        """
        client_id: pulumi.Input[_builtins.str]
        """
        The Sardine Client ID.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        The Sardine Client Secret.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSardineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSardineArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[_builtins.str],
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
        :param pulumi.Input[_builtins.str] client_id: The Sardine Client ID.
        :param pulumi.Input[_builtins.str] client_secret: The Sardine Client Secret.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[_builtins.str]:
        """
        The base URL for the Sardine API, e.g.: https://api.sandbox.sardine.ai, https://api.sardine.ai, https://api.eu.sardine.ai.
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The Sardine Client ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The Sardine Client Secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        sender: pulumi.Input['ProjectConnectorsSeSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        access_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Access key ID.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication type to use.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The external ID to use when assuming the role.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Secret Access Key.
        """
elif False:
    ProjectConnectorsSeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSeSenderArgs'],
                 access_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] region: AWS region to send requests to (e.g. `us-west-2`).
        :param pulumi.Input['ProjectConnectorsSeSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input[_builtins.str] access_key_id: AWS Access key ID.
        :param pulumi.Input[_builtins.str] auth_type: The authentication type to use.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        :param pulumi.Input[_builtins.str] external_id: The external ID to use when assuming the role.
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of the role to assume.
        :param pulumi.Input[_builtins.str] secret: AWS Secret Access Key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "sender", sender)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSeSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSeSenderArgs']):
        pulumi.set(self, "sender", value)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The external ID to use when assuming the role.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ProjectConnectorsSeSenderArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email address that will appear as the sender of the email.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name that will appear as the sender of the email.
        """
elif False:
    ProjectConnectorsSeSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSeSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The email address that will appear as the sender of the email.
        :param pulumi.Input[_builtins.str] name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSegmentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        write_key: pulumi.Input[_builtins.str]
        """
        The Segment Write Key generated for the Descope service.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL of the Segment API, when using a custom domain in Segment.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSegmentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 write_key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] write_key: The Segment Write Key generated for the Descope service.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] host: The base URL of the Segment API, when using a custom domain in Segment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "write_key", write_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="writeKey")
    def write_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Segment Write Key generated for the Descope service.
        """
        return pulumi.get(self, "write_key")

    @write_key.setter
    def write_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "write_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL of the Segment API, when using a custom domain in Segment.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSendgridArgsDict(TypedDict):
        authentication: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgsDict']
        """
        SendGrid API authentication configuration.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        sender: pulumi.Input['ProjectConnectorsSendgridSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSendgridArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs'],
                 name: pulumi.Input[_builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSendgridSenderArgs'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs'] authentication: SendGrid API authentication configuration.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsSendgridSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs']:
        """
        SendGrid API authentication configuration.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsSendgridAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSendgridSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSendgridSenderArgs']):
        pulumi.set(self, "sender", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSendgridAuthenticationArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        SendGrid API key for authentication.
        """
elif False:
    ProjectConnectorsSendgridAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key: SendGrid API key for authentication.
        """
        pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        SendGrid API key for authentication.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class ProjectConnectorsSendgridSenderArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email address that will appear as the sender of the email.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name that will appear as the sender of the email.
        """
elif False:
    ProjectConnectorsSendgridSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSendgridSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The email address that will appear as the sender of the email.
        :param pulumi.Input[_builtins.str] name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSlackArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        token: pulumi.Input[_builtins.str]
        """
        The OAuth token for Slack's Bot User, used to authenticate API requests.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSlackArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] token: The OAuth token for Slack's Bot User, used to authenticate API requests.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The OAuth token for Slack's Bot User, used to authenticate API requests.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSmartlingArgsDict(TypedDict):
        account_uid: pulumi.Input[_builtins.str]
        """
        The account UID for the Smartling account.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        user_identifier: pulumi.Input[_builtins.str]
        """
        The user identifier for the Smartling account.
        """
        user_secret: pulumi.Input[_builtins.str]
        """
        The user secret for the Smartling account.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsSmartlingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmartlingArgs:
    def __init__(__self__, *,
                 account_uid: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 user_identifier: pulumi.Input[_builtins.str],
                 user_secret: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_uid: The account UID for the Smartling account.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] user_identifier: The user identifier for the Smartling account.
        :param pulumi.Input[_builtins.str] user_secret: The user secret for the Smartling account.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_uid", account_uid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user_identifier", user_identifier)
        pulumi.set(__self__, "user_secret", user_secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accountUid")
    def account_uid(self) -> pulumi.Input[_builtins.str]:
        """
        The account UID for the Smartling account.
        """
        return pulumi.get(self, "account_uid")

    @account_uid.setter
    def account_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_uid", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="userIdentifier")
    def user_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The user identifier for the Smartling account.
        """
        return pulumi.get(self, "user_identifier")

    @user_identifier.setter
    def user_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_identifier", value)

    @_builtins.property
    @pulumi.getter(name="userSecret")
    def user_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The user secret for the Smartling account.
        """
        return pulumi.get(self, "user_secret")

    @user_secret.setter
    def user_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsSmtpArgsDict(TypedDict):
        authentication: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgsDict']
        """
        SMTP server authentication credentials and method.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        sender: pulumi.Input['ProjectConnectorsSmtpSenderArgsDict']
        """
        The sender details that should be displayed in the email message.
        """
        server: pulumi.Input['ProjectConnectorsSmtpServerArgsDict']
        """
        SMTP server connection details including hostname and port.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        use_static_ips: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the connector should send all requests from specific static IPs.
        """
elif False:
    ProjectConnectorsSmtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs'],
                 name: pulumi.Input[_builtins.str],
                 sender: pulumi.Input['ProjectConnectorsSmtpSenderArgs'],
                 server: pulumi.Input['ProjectConnectorsSmtpServerArgs'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 use_static_ips: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs'] authentication: SMTP server authentication credentials and method.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsSmtpSenderArgs'] sender: The sender details that should be displayed in the email message.
        :param pulumi.Input['ProjectConnectorsSmtpServerArgs'] server: SMTP server connection details including hostname and port.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] use_static_ips: Whether the connector should send all requests from specific static IPs.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sender", sender)
        pulumi.set(__self__, "server", server)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if use_static_ips is not None:
            pulumi.set(__self__, "use_static_ips", use_static_ips)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs']:
        """
        SMTP server authentication credentials and method.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsSmtpAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> pulumi.Input['ProjectConnectorsSmtpSenderArgs']:
        """
        The sender details that should be displayed in the email message.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: pulumi.Input['ProjectConnectorsSmtpSenderArgs']):
        pulumi.set(self, "sender", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> pulumi.Input['ProjectConnectorsSmtpServerArgs']:
        """
        SMTP server connection details including hostname and port.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input['ProjectConnectorsSmtpServerArgs']):
        pulumi.set(self, "server", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="useStaticIps")
    def use_static_ips(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the connector should send all requests from specific static IPs.
        """
        return pulumi.get(self, "use_static_ips")

    @use_static_ips.setter
    def use_static_ips(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_static_ips", value)


if not MYPY:
    class ProjectConnectorsSmtpAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password for SMTP server authentication.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username for SMTP server authentication.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        SMTP authentication method (`plain` or `login`).
        """
elif False:
    ProjectConnectorsSmtpAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 method: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for SMTP server authentication.
        :param pulumi.Input[_builtins.str] username: Username for SMTP server authentication.
        :param pulumi.Input[_builtins.str] method: SMTP authentication method (`plain` or `login`).
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password for SMTP server authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username for SMTP server authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SMTP authentication method (`plain` or `login`).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)


if not MYPY:
    class ProjectConnectorsSmtpSenderArgsDict(TypedDict):
        email: pulumi.Input[_builtins.str]
        """
        The email address that will appear as the sender of the email.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name that will appear as the sender of the email.
        """
elif False:
    ProjectConnectorsSmtpSenderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpSenderArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] email: The email address that will appear as the sender of the email.
        :param pulumi.Input[_builtins.str] name: The display name that will appear as the sender of the email.
        """
        pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email address that will appear as the sender of the email.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name that will appear as the sender of the email.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectConnectorsSmtpServerArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The hostname or IP address of the SMTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number to connect to on the SMTP server.
        """
elif False:
    ProjectConnectorsSmtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSmtpServerArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The hostname or IP address of the SMTP server.
        :param pulumi.Input[_builtins.int] port: The port number to connect to on the SMTP server.
        """
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname or IP address of the SMTP server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number to connect to on the SMTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ProjectConnectorsSnArgsDict(TypedDict):
        access_key_id: pulumi.Input[_builtins.str]
        """
        AWS Access key ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        secret: pulumi.Input[_builtins.str]
        """
        AWS Secret Access Key.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        entity_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        organization_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use the `origination_number` attribute instead.
        """
        origination_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        """
        sender_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        """
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
elif False:
    ProjectConnectorsSnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSnArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 entity_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 organization_number: Optional[pulumi.Input[_builtins.str]] = None,
                 origination_number: Optional[pulumi.Input[_builtins.str]] = None,
                 sender_id: Optional[pulumi.Input[_builtins.str]] = None,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_id: AWS Access key ID.
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] region: AWS region to send requests to (e.g. `us-west-2`).
        :param pulumi.Input[_builtins.str] secret: AWS Secret Access Key.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] endpoint: An optional endpoint URL (hostname only or fully qualified URI).
        :param pulumi.Input[_builtins.str] entity_id: The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        :param pulumi.Input[_builtins.str] organization_number: Use the `origination_number` attribute instead.
        :param pulumi.Input[_builtins.str] origination_number: An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        :param pulumi.Input[_builtins.str] sender_id: The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        :param pulumi.Input[_builtins.str] template_id: The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "secret", secret)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if organization_number is not None:
            warnings.warn("""The organization_number attribute has been renamed, set the origination_number attribute instead. This attribute will be removed in a future version of the provider.""", DeprecationWarning)
            pulumi.log.warn("""organization_number is deprecated: The organization_number attribute has been renamed, set the origination_number attribute instead. This attribute will be removed in a future version of the provider.""")
        if organization_number is not None:
            pulumi.set(__self__, "organization_number", organization_number)
        if origination_number is not None:
            pulumi.set(__self__, "origination_number", origination_number)
        if sender_id is not None:
            pulumi.set(__self__, "sender_id", sender_id)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        AWS Access key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region to send requests to (e.g. `us-west-2`).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional endpoint URL (hostname only or fully qualified URI).
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity ID or principal entity (PE) ID for sending text messages to recipients in India.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="organizationNumber")
    @_utilities.deprecated("""The organization_number attribute has been renamed, set the origination_number attribute instead. This attribute will be removed in a future version of the provider.""")
    def organization_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use the `origination_number` attribute instead.
        """
        return pulumi.get(self, "organization_number")

    @organization_number.setter
    def organization_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "organization_number", value)

    @_builtins.property
    @pulumi.getter(name="originationNumber")
    def origination_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional phone number from which the text messages are going to be sent. Make sure it is registered properly in your server.
        """
        return pulumi.get(self, "origination_number")

    @origination_number.setter
    def origination_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origination_number", value)

    @_builtins.property
    @pulumi.getter(name="senderId")
    def sender_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the sender from which the text message is going to be sent (see SNS documentation regarding acceptable IDs and supported regions/countries).
        """
        return pulumi.get(self, "sender_id")

    @sender_id.setter
    def sender_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender_id", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The template for sending text messages to recipients in India. The template ID must be associated with the sender ID.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class ProjectConnectorsSumologicArgsDict(TypedDict):
        http_source_url: pulumi.Input[_builtins.str]
        """
        The URL associated with an HTTP Hosted collector
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable streaming of audit events.
        """
        audit_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgsDict']]]]
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        troubleshoot_log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send troubleshooting events.
        """
elif False:
    ProjectConnectorsSumologicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSumologicArgs:
    def __init__(__self__, *,
                 http_source_url: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 audit_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 troubleshoot_log_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] http_source_url: The URL associated with an HTTP Hosted collector
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.bool] audit_enabled: Whether to enable streaming of audit events.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]] audit_filters: Specify which events will be sent to the external audit service (including tenant selection).
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] troubleshoot_log_enabled: Whether to send troubleshooting events.
        """
        pulumi.set(__self__, "http_source_url", http_source_url)
        pulumi.set(__self__, "name", name)
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if audit_filters is not None:
            pulumi.set(__self__, "audit_filters", audit_filters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if troubleshoot_log_enabled is not None:
            pulumi.set(__self__, "troubleshoot_log_enabled", troubleshoot_log_enabled)

    @_builtins.property
    @pulumi.getter(name="httpSourceUrl")
    def http_source_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL associated with an HTTP Hosted collector
        """
        return pulumi.get(self, "http_source_url")

    @http_source_url.setter
    def http_source_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_source_url", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable streaming of audit events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter(name="auditFilters")
    def audit_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]]:
        """
        Specify which events will be sent to the external audit service (including tenant selection).
        """
        return pulumi.get(self, "audit_filters")

    @audit_filters.setter
    def audit_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectConnectorsSumologicAuditFilterArgs']]]]):
        pulumi.set(self, "audit_filters", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="troubleshootLogEnabled")
    def troubleshoot_log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send troubleshooting events.
        """
        return pulumi.get(self, "troubleshoot_log_enabled")

    @troubleshoot_log_enabled.setter
    def troubleshoot_log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "troubleshoot_log_enabled", value)


if not MYPY:
    class ProjectConnectorsSumologicAuditFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        operator: pulumi.Input[_builtins.str]
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of values to match against for the filter.
        """
elif False:
    ProjectConnectorsSumologicAuditFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSumologicAuditFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The field name to filter on (either 'actions' or 'tenants').
        :param pulumi.Input[_builtins.str] operator: The filter operation to apply ('includes' or 'excludes').
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The list of values to match against for the filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The field name to filter on (either 'actions' or 'tenants').
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The filter operation to apply ('includes' or 'excludes').
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of values to match against for the filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectConnectorsSupabaseArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        auth_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication type to use.
        """
        create_users: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
        """
        custom_claims_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A mapping of Descope user fields or JWT claims to Supabase custom claims
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        expiration_time: NotRequired[pulumi.Input[_builtins.float]]
        """
        The duration in minutes for which the token is valid.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
        """
        project_base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your Supabase Project's API base URL, e.g.: https://\\n\\n.supabase.co.
        """
        service_role_api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service role API key for your Supabase project, required to create users.
        """
        signing_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signing secret for your Supabase project.
        """
elif False:
    ProjectConnectorsSupabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsSupabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 auth_type: Optional[pulumi.Input[_builtins.str]] = None,
                 create_users: Optional[pulumi.Input[_builtins.bool]] = None,
                 custom_claims_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_time: Optional[pulumi.Input[_builtins.float]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 service_role_api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 signing_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] auth_type: The authentication type to use.
        :param pulumi.Input[_builtins.bool] create_users: Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_claims_mapping: A mapping of Descope user fields or JWT claims to Supabase custom claims
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.float] expiration_time: The duration in minutes for which the token is valid.
        :param pulumi.Input[_builtins.str] private_key: The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
        :param pulumi.Input[_builtins.str] project_base_url: Your Supabase Project's API base URL, e.g.: https://\\n\\n.supabase.co.
        :param pulumi.Input[_builtins.str] service_role_api_key: The service role API key for your Supabase project, required to create users.
        :param pulumi.Input[_builtins.str] signing_secret: The signing secret for your Supabase project.
        """
        pulumi.set(__self__, "name", name)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if create_users is not None:
            pulumi.set(__self__, "create_users", create_users)
        if custom_claims_mapping is not None:
            pulumi.set(__self__, "custom_claims_mapping", custom_claims_mapping)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if project_base_url is not None:
            pulumi.set(__self__, "project_base_url", project_base_url)
        if service_role_api_key is not None:
            pulumi.set(__self__, "service_role_api_key", service_role_api_key)
        if signing_secret is not None:
            pulumi.set(__self__, "signing_secret", signing_secret)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication type to use.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="createUsers")
    def create_users(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable to automatically create users in Supabase when generating tokens. Will only create a new user if one does not already exist. When disabled, only JWT tokens will be generated, WITHOUT user creation.
        """
        return pulumi.get(self, "create_users")

    @create_users.setter
    def create_users(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_users", value)

    @_builtins.property
    @pulumi.getter(name="customClaimsMapping")
    def custom_claims_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A mapping of Descope user fields or JWT claims to Supabase custom claims
        """
        return pulumi.get(self, "custom_claims_mapping")

    @custom_claims_mapping.setter
    def custom_claims_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_claims_mapping", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The duration in minutes for which the token is valid.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "expiration_time", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private key in JWK format used to sign the JWT. You can generate a key using tools like `npx supabase gen signing-key --algorithm ES256`. Make sure to use the ES256 algorithm.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="projectBaseUrl")
    def project_base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your Supabase Project's API base URL, e.g.: https://\\n\\n.supabase.co.
        """
        return pulumi.get(self, "project_base_url")

    @project_base_url.setter
    def project_base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_base_url", value)

    @_builtins.property
    @pulumi.getter(name="serviceRoleApiKey")
    def service_role_api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service role API key for your Supabase project, required to create users.
        """
        return pulumi.get(self, "service_role_api_key")

    @service_role_api_key.setter
    def service_role_api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_role_api_key", value)

    @_builtins.property
    @pulumi.getter(name="signingSecret")
    def signing_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signing secret for your Supabase project.
        """
        return pulumi.get(self, "signing_secret")

    @signing_secret.setter
    def signing_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signing_secret", value)


if not MYPY:
    class ProjectConnectorsTelesignArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        The unique Telesign API key
        """
        customer_id: pulumi.Input[_builtins.str]
        """
        The unique Telesign account Customer ID
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsTelesignArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTelesignArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 customer_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: The unique Telesign API key
        :param pulumi.Input[_builtins.str] customer_id: The unique Telesign account Customer ID
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Telesign API key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Telesign account Customer ID
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "customer_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTraceableArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The Traceable secret key.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        eu_region: NotRequired[pulumi.Input[_builtins.bool]]
        """
        EU(Europe) Region deployment of Traceable platform.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsTraceableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTraceableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 eu_region: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] secret_key: The Traceable secret key.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.bool] eu_region: EU(Europe) Region deployment of Traceable platform.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if eu_region is not None:
            pulumi.set(__self__, "eu_region", eu_region)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The Traceable secret key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="euRegion")
    def eu_region(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        EU(Europe) Region deployment of Traceable platform.
        """
        return pulumi.get(self, "eu_region")

    @eu_region.setter
    def eu_region(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "eu_region", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTurnstileArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
        """
        site_key: pulumi.Input[_builtins.str]
        """
        The site key is used to invoke Turnstile service on your site or mobile application.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsTurnstileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTurnstileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 site_key: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] secret_key: The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
        :param pulumi.Input[_builtins.str] site_key: The site key is used to invoke Turnstile service on your site or mobile application.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "site_key", site_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key authorizes communication between Descope backend and the Turnstile server to verify the user's response.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="siteKey")
    def site_key(self) -> pulumi.Input[_builtins.str]:
        """
        The site key is used to invoke Turnstile service on your site or mobile application.
        """
        return pulumi.get(self, "site_key")

    @site_key.setter
    def site_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "site_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreArgsDict(TypedDict):
        account_sid: pulumi.Input[_builtins.str]
        """
        Twilio Account SID from your Twilio Console.
        """
        authentication: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgsDict']
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        senders: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgsDict']
        """
        Configuration for SMS and voice message senders.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectConnectorsTwilioCoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[_builtins.str],
                 authentication: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs'],
                 name: pulumi.Input[_builtins.str],
                 senders: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_sid: Twilio Account SID from your Twilio Console.
        :param pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs'] authentication: Twilio authentication credentials (either auth token or API key/secret).
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs'] senders: Configuration for SMS and voice message senders.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "senders", senders)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[_builtins.str]:
        """
        Twilio Account SID from your Twilio Console.
        """
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_sid", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs']:
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsTwilioCoreAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def senders(self) -> pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs']:
        """
        Configuration for SMS and voice message senders.
        """
        return pulumi.get(self, "senders")

    @senders.setter
    def senders(self, value: pulumi.Input['ProjectConnectorsTwilioCoreSendersArgs']):
        pulumi.set(self, "senders", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio API Key for authentication (used with API Secret).
        """
        api_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio API Secret for authentication (used with API Key).
        """
        auth_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio Auth Token for authentication.
        """
elif False:
    ProjectConnectorsTwilioCoreAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 api_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Twilio API Key for authentication (used with API Secret).
        :param pulumi.Input[_builtins.str] api_secret: Twilio API Secret for authentication (used with API Key).
        :param pulumi.Input[_builtins.str] auth_token: Twilio Auth Token for authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio API Key for authentication (used with API Secret).
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio API Secret for authentication (used with API Key).
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_secret", value)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio Auth Token for authentication.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_token", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersArgsDict(TypedDict):
        sms: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgsDict']
        """
        SMS sender configuration using either a phone number or messaging service.
        """
        voice: NotRequired[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgsDict']]
        """
        Voice call sender configuration.
        """
elif False:
    ProjectConnectorsTwilioCoreSendersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersArgs:
    def __init__(__self__, *,
                 sms: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs'],
                 voice: Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']] = None):
        """
        :param pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs'] sms: SMS sender configuration using either a phone number or messaging service.
        :param pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs'] voice: Voice call sender configuration.
        """
        pulumi.set(__self__, "sms", sms)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter
    def sms(self) -> pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs']:
        """
        SMS sender configuration using either a phone number or messaging service.
        """
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: pulumi.Input['ProjectConnectorsTwilioCoreSendersSmsArgs']):
        pulumi.set(self, "sms", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']]:
        """
        Voice call sender configuration.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input['ProjectConnectorsTwilioCoreSendersVoiceArgs']]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersSmsArgsDict(TypedDict):
        messaging_service_sid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio Messaging Service SID for sending SMS messages.
        """
        phone_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio phone number for sending SMS messages.
        """
elif False:
    ProjectConnectorsTwilioCoreSendersSmsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersSmsArgs:
    def __init__(__self__, *,
                 messaging_service_sid: Optional[pulumi.Input[_builtins.str]] = None,
                 phone_number: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] messaging_service_sid: Twilio Messaging Service SID for sending SMS messages.
        :param pulumi.Input[_builtins.str] phone_number: Twilio phone number for sending SMS messages.
        """
        if messaging_service_sid is not None:
            pulumi.set(__self__, "messaging_service_sid", messaging_service_sid)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="messagingServiceSid")
    def messaging_service_sid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio Messaging Service SID for sending SMS messages.
        """
        return pulumi.get(self, "messaging_service_sid")

    @messaging_service_sid.setter
    def messaging_service_sid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "messaging_service_sid", value)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio phone number for sending SMS messages.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ProjectConnectorsTwilioCoreSendersVoiceArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Twilio phone number for making voice calls.
        """
elif False:
    ProjectConnectorsTwilioCoreSendersVoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioCoreSendersVoiceArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Twilio phone number for making voice calls.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Twilio phone number for making voice calls.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class ProjectConnectorsTwilioVerifyArgsDict(TypedDict):
        account_sid: pulumi.Input[_builtins.str]
        """
        Twilio Account SID from your Twilio Console.
        """
        authentication: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgsDict']
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        name: pulumi.Input[_builtins.str]
        """
        A custom name for your connector.
        """
        service_sid: pulumi.Input[_builtins.str]
        """
        Twilio Verify Service SID for verification services.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of what your connector is used for.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        sender: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional sender identifier for verification messages.
        """
elif False:
    ProjectConnectorsTwilioVerifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioVerifyArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[_builtins.str],
                 authentication: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs'],
                 name: pulumi.Input[_builtins.str],
                 service_sid: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 sender: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_sid: Twilio Account SID from your Twilio Console.
        :param pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs'] authentication: Twilio authentication credentials (either auth token or API key/secret).
        :param pulumi.Input[_builtins.str] name: A custom name for your connector.
        :param pulumi.Input[_builtins.str] service_sid: Twilio Verify Service SID for verification services.
        :param pulumi.Input[_builtins.str] description: A description of what your connector is used for.
        :param pulumi.Input[_builtins.str] sender: Optional sender identifier for verification messages.
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_sid", service_sid)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sender is not None:
            pulumi.set(__self__, "sender", sender)

    @_builtins.property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[_builtins.str]:
        """
        Twilio Account SID from your Twilio Console.
        """
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_sid", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs']:
        """
        Twilio authentication credentials (either auth token or API key/secret).
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['ProjectConnectorsTwilioVerifyAuthenticationArgs']):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A custom name for your connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serviceSid")
    def service_sid(self) -> pulumi.Input[_builtins.str]:
        """
        Twilio Verify Service SID for verification services.
        """
        return pulumi.get(self, "service_sid")

    @service_sid.setter
    def service_sid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_sid", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of what your connector is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def sender(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional sender identifier for verification messages.
        """
        return pulumi.get(self, "sender")

    @sender.setter
    def sender(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender", value)


if not MYPY:
    class ProjectConnectorsTwilioVerifyAuthenticationArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio API Key for authentication (used with API Secret).
        """
        api_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio API Secret for authentication (used with API Key).
        """
        auth_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Twilio Auth Token for authentication.
        """
elif False:
    ProjectConnectorsTwilioVerifyAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectConnectorsTwilioVerifyAuthenticationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 api_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Twilio API Key for authentication (used with API Secret).
        :param pulumi.Input[_builtins.str] api_secret: Twilio API Secret for authentication (used with API Key).
        :param pulumi.Input[_builtins.str] auth_token: Twilio Auth Token for authentication.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio API Key for authentication (used with API Secret).
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio API Secret for authentication (used with API Key).
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_secret", value)

    @_builtins.property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Twilio Auth Token for authentication.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_token", value)


if not MYPY:
    class ProjectFlowsArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
        """
elif False:
    ProjectFlowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectFlowsArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        The JSON data defining the authentication flow configuration, including metadata, screens, contents, and references.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)


if not MYPY:
    class ProjectInviteSettingsArgsDict(TypedDict):
        add_magiclink_token: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to include a magic link token in invitation messages.
        """
        email_service: NotRequired[pulumi.Input['ProjectInviteSettingsEmailServiceArgsDict']]
        """
        Settings related to sending invitation emails.
        """
        expire_invited_users: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Expire the user account if the invitation is not accepted within the expiration time.
        """
        invite_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time for the invitation, meant to be used together with `expire_invited_users` and/or `add_magiclink_token`. Use values such as "2 weeks", "4 days", etc. The minimum value is "1 hour".
        """
        invite_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom URL to include in the message sent to invited users.
        """
        require_invitation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether users must be invited before they can sign up to the project.
        """
        send_email: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send invitation emails to users.
        """
        send_text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to send invitation SMS messages to users.
        """
elif False:
    ProjectInviteSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectInviteSettingsArgs:
    def __init__(__self__, *,
                 add_magiclink_token: Optional[pulumi.Input[_builtins.bool]] = None,
                 email_service: Optional[pulumi.Input['ProjectInviteSettingsEmailServiceArgs']] = None,
                 expire_invited_users: Optional[pulumi.Input[_builtins.bool]] = None,
                 invite_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 invite_url: Optional[pulumi.Input[_builtins.str]] = None,
                 require_invitation: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_email: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] add_magiclink_token: Whether to include a magic link token in invitation messages.
        :param pulumi.Input['ProjectInviteSettingsEmailServiceArgs'] email_service: Settings related to sending invitation emails.
        :param pulumi.Input[_builtins.bool] expire_invited_users: Expire the user account if the invitation is not accepted within the expiration time.
        :param pulumi.Input[_builtins.str] invite_expiration: The expiry time for the invitation, meant to be used together with `expire_invited_users` and/or `add_magiclink_token`. Use values such as "2 weeks", "4 days", etc. The minimum value is "1 hour".
        :param pulumi.Input[_builtins.str] invite_url: Custom URL to include in the message sent to invited users.
        :param pulumi.Input[_builtins.bool] require_invitation: Whether users must be invited before they can sign up to the project.
        :param pulumi.Input[_builtins.bool] send_email: Whether to send invitation emails to users.
        :param pulumi.Input[_builtins.bool] send_text: Whether to send invitation SMS messages to users.
        """
        if add_magiclink_token is not None:
            pulumi.set(__self__, "add_magiclink_token", add_magiclink_token)
        if email_service is not None:
            pulumi.set(__self__, "email_service", email_service)
        if expire_invited_users is not None:
            pulumi.set(__self__, "expire_invited_users", expire_invited_users)
        if invite_expiration is not None:
            pulumi.set(__self__, "invite_expiration", invite_expiration)
        if invite_url is not None:
            pulumi.set(__self__, "invite_url", invite_url)
        if require_invitation is not None:
            pulumi.set(__self__, "require_invitation", require_invitation)
        if send_email is not None:
            pulumi.set(__self__, "send_email", send_email)
        if send_text is not None:
            pulumi.set(__self__, "send_text", send_text)

    @_builtins.property
    @pulumi.getter(name="addMagiclinkToken")
    def add_magiclink_token(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to include a magic link token in invitation messages.
        """
        return pulumi.get(self, "add_magiclink_token")

    @add_magiclink_token.setter
    def add_magiclink_token(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "add_magiclink_token", value)

    @_builtins.property
    @pulumi.getter(name="emailService")
    def email_service(self) -> Optional[pulumi.Input['ProjectInviteSettingsEmailServiceArgs']]:
        """
        Settings related to sending invitation emails.
        """
        return pulumi.get(self, "email_service")

    @email_service.setter
    def email_service(self, value: Optional[pulumi.Input['ProjectInviteSettingsEmailServiceArgs']]):
        pulumi.set(self, "email_service", value)

    @_builtins.property
    @pulumi.getter(name="expireInvitedUsers")
    def expire_invited_users(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Expire the user account if the invitation is not accepted within the expiration time.
        """
        return pulumi.get(self, "expire_invited_users")

    @expire_invited_users.setter
    def expire_invited_users(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expire_invited_users", value)

    @_builtins.property
    @pulumi.getter(name="inviteExpiration")
    def invite_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time for the invitation, meant to be used together with `expire_invited_users` and/or `add_magiclink_token`. Use values such as "2 weeks", "4 days", etc. The minimum value is "1 hour".
        """
        return pulumi.get(self, "invite_expiration")

    @invite_expiration.setter
    def invite_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invite_expiration", value)

    @_builtins.property
    @pulumi.getter(name="inviteUrl")
    def invite_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom URL to include in the message sent to invited users.
        """
        return pulumi.get(self, "invite_url")

    @invite_url.setter
    def invite_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invite_url", value)

    @_builtins.property
    @pulumi.getter(name="requireInvitation")
    def require_invitation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether users must be invited before they can sign up to the project.
        """
        return pulumi.get(self, "require_invitation")

    @require_invitation.setter
    def require_invitation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_invitation", value)

    @_builtins.property
    @pulumi.getter(name="sendEmail")
    def send_email(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send invitation emails to users.
        """
        return pulumi.get(self, "send_email")

    @send_email.setter
    def send_email(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_email", value)

    @_builtins.property
    @pulumi.getter(name="sendText")
    def send_text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to send invitation SMS messages to users.
        """
        return pulumi.get(self, "send_text")

    @send_text.setter
    def send_text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_text", value)


if not MYPY:
    class ProjectInviteSettingsEmailServiceArgsDict(TypedDict):
        connector: pulumi.Input[_builtins.str]
        """
        The name of the email connector to use for sending emails.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectInviteSettingsEmailServiceTemplateArgsDict']]]]
        """
        A list of email templates for different authentication flows.
        """
elif False:
    ProjectInviteSettingsEmailServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectInviteSettingsEmailServiceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[_builtins.str],
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectInviteSettingsEmailServiceTemplateArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] connector: The name of the email connector to use for sending emails.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectInviteSettingsEmailServiceTemplateArgs']]] templates: A list of email templates for different authentication flows.
        """
        pulumi.set(__self__, "connector", connector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the email connector to use for sending emails.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connector", value)

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectInviteSettingsEmailServiceTemplateArgs']]]]:
        """
        A list of email templates for different authentication flows.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectInviteSettingsEmailServiceTemplateArgs']]]]):
        pulumi.set(self, "templates", value)


if not MYPY:
    class ProjectInviteSettingsEmailServiceTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this email template.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject line of the email message.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this email template is currently active and in use.
        """
        html_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        plain_text_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        use_plain_text_body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use the plain text body instead of HTML for the email.
        """
elif False:
    ProjectInviteSettingsEmailServiceTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectInviteSettingsEmailServiceTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 html_body: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 plain_text_body: Optional[pulumi.Input[_builtins.str]] = None,
                 use_plain_text_body: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this email template.
        :param pulumi.Input[_builtins.str] subject: Subject line of the email message.
        :param pulumi.Input[_builtins.bool] active: Whether this email template is currently active and in use.
        :param pulumi.Input[_builtins.str] html_body: HTML content of the email message body, required if `use_plain_text_body` isn't set.
        :param pulumi.Input[_builtins.str] plain_text_body: Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        :param pulumi.Input[_builtins.bool] use_plain_text_body: Whether to use the plain text body instead of HTML for the email.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subject", subject)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if html_body is not None:
            pulumi.set(__self__, "html_body", html_body)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if plain_text_body is not None:
            pulumi.set(__self__, "plain_text_body", plain_text_body)
        if use_plain_text_body is not None:
            pulumi.set(__self__, "use_plain_text_body", use_plain_text_body)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this email template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject line of the email message.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this email template is currently active and in use.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="htmlBody")
    def html_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTML content of the email message body, required if `use_plain_text_body` isn't set.
        """
        return pulumi.get(self, "html_body")

    @html_body.setter
    def html_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "html_body", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="plainTextBody")
    def plain_text_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plain text version of the email message body, required if `use_plain_text_body` is set to `true`.
        """
        return pulumi.get(self, "plain_text_body")

    @plain_text_body.setter
    def plain_text_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plain_text_body", value)

    @_builtins.property
    @pulumi.getter(name="usePlainTextBody")
    def use_plain_text_body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use the plain text body instead of HTML for the email.
        """
        return pulumi.get(self, "use_plain_text_body")

    @use_plain_text_body.setter
    def use_plain_text_body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_plain_text_body", value)


if not MYPY:
    class ProjectJwtTemplatesArgsDict(TypedDict):
        access_key_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgsDict']]]]
        """
        A list of `Access Key` type JWT Templates.
        """
        user_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgsDict']]]]
        """
        A list of `User` type JWT Templates.
        """
elif False:
    ProjectJwtTemplatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesArgs:
    def __init__(__self__, *,
                 access_key_templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]] = None,
                 user_templates: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]] access_key_templates: A list of `Access Key` type JWT Templates.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]] user_templates: A list of `User` type JWT Templates.
        """
        if access_key_templates is not None:
            pulumi.set(__self__, "access_key_templates", access_key_templates)
        if user_templates is not None:
            pulumi.set(__self__, "user_templates", user_templates)

    @_builtins.property
    @pulumi.getter(name="accessKeyTemplates")
    def access_key_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]]:
        """
        A list of `Access Key` type JWT Templates.
        """
        return pulumi.get(self, "access_key_templates")

    @access_key_templates.setter
    def access_key_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesAccessKeyTemplateArgs']]]]):
        pulumi.set(self, "access_key_templates", value)

    @_builtins.property
    @pulumi.getter(name="userTemplates")
    def user_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]]:
        """
        A list of `User` type JWT Templates.
        """
        return pulumi.get(self, "user_templates")

    @user_templates.setter
    def user_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectJwtTemplatesUserTemplateArgs']]]]):
        pulumi.set(self, "user_templates", value)


if not MYPY:
    class ProjectJwtTemplatesAccessKeyTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the JWT Template.
        """
        template: pulumi.Input[_builtins.str]
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        auth_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        auto_tenant_claim: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        conformance_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the JWT Template.
        """
        empty_claim_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        enforce_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectJwtTemplatesAccessKeyTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesAccessKeyTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 template: pulumi.Input[_builtins.str],
                 auth_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_tenant_claim: Optional[pulumi.Input[_builtins.bool]] = None,
                 conformance_issuer: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 empty_claim_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_issuer: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the JWT Template.
        :param pulumi.Input[_builtins.str] template: The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        :param pulumi.Input[_builtins.str] auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param pulumi.Input[_builtins.bool] auto_tenant_claim: When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        :param pulumi.Input[_builtins.bool] conformance_issuer: Whether to use OIDC conformance for the JWT issuer field.
        :param pulumi.Input[_builtins.str] description: Description of the JWT Template.
        :param pulumi.Input[_builtins.str] empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        :param pulumi.Input[_builtins.bool] enforce_issuer: Whether to enforce that the JWT issuer matches the project configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if auto_tenant_claim is not None:
            pulumi.set(__self__, "auto_tenant_claim", auto_tenant_claim)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> pulumi.Input[_builtins.str]:
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @auth_schema.setter
    def auth_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_schema", value)

    @_builtins.property
    @pulumi.getter(name="autoTenantClaim")
    def auto_tenant_claim(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        return pulumi.get(self, "auto_tenant_claim")

    @auto_tenant_claim.setter
    def auto_tenant_claim(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_tenant_claim", value)

    @_builtins.property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        return pulumi.get(self, "conformance_issuer")

    @conformance_issuer.setter
    def conformance_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "conformance_issuer", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @empty_claim_policy.setter
    def empty_claim_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "empty_claim_policy", value)

    @_builtins.property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        return pulumi.get(self, "enforce_issuer")

    @enforce_issuer.setter
    def enforce_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_issuer", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectJwtTemplatesUserTemplateArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the JWT Template.
        """
        template: pulumi.Input[_builtins.str]
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        auth_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        auto_tenant_claim: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        conformance_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the JWT Template.
        """
        empty_claim_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        enforce_issuer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ProjectJwtTemplatesUserTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectJwtTemplatesUserTemplateArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 template: pulumi.Input[_builtins.str],
                 auth_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 auto_tenant_claim: Optional[pulumi.Input[_builtins.bool]] = None,
                 conformance_issuer: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 empty_claim_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 enforce_issuer: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the JWT Template.
        :param pulumi.Input[_builtins.str] template: The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        :param pulumi.Input[_builtins.str] auth_schema: The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        :param pulumi.Input[_builtins.bool] auto_tenant_claim: When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        :param pulumi.Input[_builtins.bool] conformance_issuer: Whether to use OIDC conformance for the JWT issuer field.
        :param pulumi.Input[_builtins.str] description: Description of the JWT Template.
        :param pulumi.Input[_builtins.str] empty_claim_policy: Policy for empty claims - `none`, `nil` or `delete`.
        :param pulumi.Input[_builtins.bool] enforce_issuer: Whether to enforce that the JWT issuer matches the project configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template", template)
        if auth_schema is not None:
            pulumi.set(__self__, "auth_schema", auth_schema)
        if auto_tenant_claim is not None:
            pulumi.set(__self__, "auto_tenant_claim", auto_tenant_claim)
        if conformance_issuer is not None:
            pulumi.set(__self__, "conformance_issuer", conformance_issuer)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if empty_claim_policy is not None:
            pulumi.set(__self__, "empty_claim_policy", empty_claim_policy)
        if enforce_issuer is not None:
            pulumi.set(__self__, "enforce_issuer", enforce_issuer)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the JWT Template.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> pulumi.Input[_builtins.str]:
        """
        The JSON template defining the structure and claims of the JWT token. This is expected to be a valid JSON object given as a `string` value.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter(name="authSchema")
    def auth_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authorization claims format - `default`, `tenantOnly` or `none`. Read more about schema types [here](https://docs.descope.com/project-settings/jwt-templates).
        """
        return pulumi.get(self, "auth_schema")

    @auth_schema.setter
    def auth_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_schema", value)

    @_builtins.property
    @pulumi.getter(name="autoTenantClaim")
    def auto_tenant_claim(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When a user is associated with a single tenant, the tenant will be set as the user's active tenant, using the `dct` (Descope Current Tenant) claim in their JWT.
        """
        return pulumi.get(self, "auto_tenant_claim")

    @auto_tenant_claim.setter
    def auto_tenant_claim(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_tenant_claim", value)

    @_builtins.property
    @pulumi.getter(name="conformanceIssuer")
    def conformance_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use OIDC conformance for the JWT issuer field.
        """
        return pulumi.get(self, "conformance_issuer")

    @conformance_issuer.setter
    def conformance_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "conformance_issuer", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the JWT Template.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="emptyClaimPolicy")
    def empty_claim_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy for empty claims - `none`, `nil` or `delete`.
        """
        return pulumi.get(self, "empty_claim_policy")

    @empty_claim_policy.setter
    def empty_claim_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "empty_claim_policy", value)

    @_builtins.property
    @pulumi.getter(name="enforceIssuer")
    def enforce_issuer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enforce that the JWT issuer matches the project configuration.
        """
        return pulumi.get(self, "enforce_issuer")

    @enforce_issuer.setter
    def enforce_issuer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce_issuer", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectListArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        """
        The name of the Descope project.
        """
        type: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of this resource.
        """
elif False:
    ProjectListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectListArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the Descope project.
        :param pulumi.Input[_builtins.str] id: The ID of this resource.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Descope project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ProjectProjectSettingsArgsDict(TypedDict):
        access_key_jwt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the access key JWT Template.
        """
        access_key_session_token_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        """
        app_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL which your application resides on.
        """
        approved_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        """
        custom_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        default_no_sso_apps: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
        """
        enable_inactivity: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        """
        inactivity_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        """
        refresh_token_cookie_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        refresh_token_cookie_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        refresh_token_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        """
        refresh_token_response_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        refresh_token_rotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        """
        session_migration: NotRequired[pulumi.Input['ProjectProjectSettingsSessionMigrationArgsDict']]
        """
        Configure seamless migration of existing user sessions from another vendor to Descope.
        """
        session_token_cookie_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        session_token_cookie_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        session_token_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        """
        session_token_response_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        step_up_token_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        """
        test_users_loginid_regexp: NotRequired[pulumi.Input[_builtins.str]]
        """
        Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        """
        test_users_static_otp: NotRequired[pulumi.Input[_builtins.str]]
        """
        A 6 digit static OTP code for use with test users.
        """
        test_users_verifier_regexp: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pattern of the verifiers that will be used for testing.
        """
        trusted_device_token_expiration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiry time for the trusted device token. The minimum value is "3 minutes".
        """
        user_jwt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the user JWT Template.
        """
elif False:
    ProjectProjectSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProjectSettingsArgs:
    def __init__(__self__, *,
                 access_key_jwt_template: Optional[pulumi.Input[_builtins.str]] = None,
                 access_key_session_token_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 app_url: Optional[pulumi.Input[_builtins.str]] = None,
                 approved_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 default_no_sso_apps: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_inactivity: Optional[pulumi.Input[_builtins.bool]] = None,
                 inactivity_time: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_token_cookie_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_token_cookie_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_token_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_token_response_method: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_token_rotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 session_migration: Optional[pulumi.Input['ProjectProjectSettingsSessionMigrationArgs']] = None,
                 session_token_cookie_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 session_token_cookie_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 session_token_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 session_token_response_method: Optional[pulumi.Input[_builtins.str]] = None,
                 step_up_token_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 test_users_loginid_regexp: Optional[pulumi.Input[_builtins.str]] = None,
                 test_users_static_otp: Optional[pulumi.Input[_builtins.str]] = None,
                 test_users_verifier_regexp: Optional[pulumi.Input[_builtins.str]] = None,
                 trusted_device_token_expiration: Optional[pulumi.Input[_builtins.str]] = None,
                 user_jwt_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key_jwt_template: Name of the access key JWT Template.
        :param pulumi.Input[_builtins.str] access_key_session_token_expiration: The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        :param pulumi.Input[_builtins.str] app_url: The URL which your application resides on.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] approved_domains: The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        :param pulumi.Input[_builtins.str] custom_domain: A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[_builtins.bool] default_no_sso_apps: Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
        :param pulumi.Input[_builtins.bool] enable_inactivity: Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        :param pulumi.Input[_builtins.str] inactivity_time: The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        :param pulumi.Input[_builtins.str] refresh_token_cookie_domain: The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[_builtins.str] refresh_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[_builtins.str] refresh_token_expiration: The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        :param pulumi.Input[_builtins.str] refresh_token_response_method: Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param pulumi.Input[_builtins.bool] refresh_token_rotation: Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        :param pulumi.Input['ProjectProjectSettingsSessionMigrationArgs'] session_migration: Configure seamless migration of existing user sessions from another vendor to Descope.
        :param pulumi.Input[_builtins.str] session_token_cookie_domain: The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[_builtins.str] session_token_cookie_policy: Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        :param pulumi.Input[_builtins.str] session_token_expiration: The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        :param pulumi.Input[_builtins.str] session_token_response_method: Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        :param pulumi.Input[_builtins.str] step_up_token_expiration: The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        :param pulumi.Input[_builtins.str] test_users_loginid_regexp: Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        :param pulumi.Input[_builtins.str] test_users_static_otp: A 6 digit static OTP code for use with test users.
        :param pulumi.Input[_builtins.str] test_users_verifier_regexp: The pattern of the verifiers that will be used for testing.
        :param pulumi.Input[_builtins.str] trusted_device_token_expiration: The expiry time for the trusted device token. The minimum value is "3 minutes".
        :param pulumi.Input[_builtins.str] user_jwt_template: Name of the user JWT Template.
        """
        if access_key_jwt_template is not None:
            pulumi.set(__self__, "access_key_jwt_template", access_key_jwt_template)
        if access_key_session_token_expiration is not None:
            pulumi.set(__self__, "access_key_session_token_expiration", access_key_session_token_expiration)
        if app_url is not None:
            pulumi.set(__self__, "app_url", app_url)
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)
        if custom_domain is not None:
            pulumi.set(__self__, "custom_domain", custom_domain)
        if default_no_sso_apps is not None:
            pulumi.set(__self__, "default_no_sso_apps", default_no_sso_apps)
        if enable_inactivity is not None:
            pulumi.set(__self__, "enable_inactivity", enable_inactivity)
        if inactivity_time is not None:
            pulumi.set(__self__, "inactivity_time", inactivity_time)
        if refresh_token_cookie_domain is not None:
            pulumi.set(__self__, "refresh_token_cookie_domain", refresh_token_cookie_domain)
        if refresh_token_cookie_policy is not None:
            pulumi.set(__self__, "refresh_token_cookie_policy", refresh_token_cookie_policy)
        if refresh_token_expiration is not None:
            pulumi.set(__self__, "refresh_token_expiration", refresh_token_expiration)
        if refresh_token_response_method is not None:
            pulumi.set(__self__, "refresh_token_response_method", refresh_token_response_method)
        if refresh_token_rotation is not None:
            pulumi.set(__self__, "refresh_token_rotation", refresh_token_rotation)
        if session_migration is not None:
            pulumi.set(__self__, "session_migration", session_migration)
        if session_token_cookie_domain is not None:
            pulumi.set(__self__, "session_token_cookie_domain", session_token_cookie_domain)
        if session_token_cookie_policy is not None:
            pulumi.set(__self__, "session_token_cookie_policy", session_token_cookie_policy)
        if session_token_expiration is not None:
            pulumi.set(__self__, "session_token_expiration", session_token_expiration)
        if session_token_response_method is not None:
            pulumi.set(__self__, "session_token_response_method", session_token_response_method)
        if step_up_token_expiration is not None:
            pulumi.set(__self__, "step_up_token_expiration", step_up_token_expiration)
        if test_users_loginid_regexp is not None:
            pulumi.set(__self__, "test_users_loginid_regexp", test_users_loginid_regexp)
        if test_users_static_otp is not None:
            pulumi.set(__self__, "test_users_static_otp", test_users_static_otp)
        if test_users_verifier_regexp is not None:
            pulumi.set(__self__, "test_users_verifier_regexp", test_users_verifier_regexp)
        if trusted_device_token_expiration is not None:
            pulumi.set(__self__, "trusted_device_token_expiration", trusted_device_token_expiration)
        if user_jwt_template is not None:
            pulumi.set(__self__, "user_jwt_template", user_jwt_template)

    @_builtins.property
    @pulumi.getter(name="accessKeyJwtTemplate")
    def access_key_jwt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the access key JWT Template.
        """
        return pulumi.get(self, "access_key_jwt_template")

    @access_key_jwt_template.setter
    def access_key_jwt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_jwt_template", value)

    @_builtins.property
    @pulumi.getter(name="accessKeySessionTokenExpiration")
    def access_key_session_token_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time for access key session tokens. Use values such as "10 minutes", "4 hours", etc. The value needs to be at least 3 minutes and can't be longer than 4 weeks.
        """
        return pulumi.get(self, "access_key_session_token_expiration")

    @access_key_session_token_expiration.setter
    def access_key_session_token_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key_session_token_expiration", value)

    @_builtins.property
    @pulumi.getter(name="appUrl")
    def app_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL which your application resides on.
        """
        return pulumi.get(self, "app_url")

    @app_url.setter
    def app_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_url", value)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of approved domains that are allowed for redirect and verification URLs for different authentication methods.
        """
        return pulumi.get(self, "approved_domains")

    @approved_domains.setter
    def approved_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "approved_domains", value)

    @_builtins.property
    @pulumi.getter(name="customDomain")
    def custom_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A custom CNAME that's configured to point to `cname.descope.com`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "custom_domain")

    @custom_domain.setter
    def custom_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_domain", value)

    @_builtins.property
    @pulumi.getter(name="defaultNoSsoApps")
    def default_no_sso_apps(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Define whether a user created with no federated apps, will have access to all apps, or will not have access to any app.
        """
        return pulumi.get(self, "default_no_sso_apps")

    @default_no_sso_apps.setter
    def default_no_sso_apps(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_no_sso_apps", value)

    @_builtins.property
    @pulumi.getter(name="enableInactivity")
    def enable_inactivity(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use `True` to enable session inactivity. To read more about session inactivity click [here](https://docs.descope.com/project-settings#session-inactivity).
        """
        return pulumi.get(self, "enable_inactivity")

    @enable_inactivity.setter
    def enable_inactivity(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_inactivity", value)

    @_builtins.property
    @pulumi.getter(name="inactivityTime")
    def inactivity_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session inactivity time. Use values such as "15 minutes", "1 hour", etc. The minimum value is "10 minutes".
        """
        return pulumi.get(self, "inactivity_time")

    @inactivity_time.setter
    def inactivity_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inactivity_time", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenCookieDomain")
    def refresh_token_cookie_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name for refresh token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_domain")

    @refresh_token_cookie_domain.setter
    def refresh_token_cookie_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_token_cookie_domain", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenCookiePolicy")
    def refresh_token_cookie_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "refresh_token_cookie_policy")

    @refresh_token_cookie_policy.setter
    def refresh_token_cookie_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_token_cookie_policy", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenExpiration")
    def refresh_token_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time for the refresh token, after which the user must log in again. Use values such as "4 weeks", "14 days", etc. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "refresh_token_expiration")

    @refresh_token_expiration.setter
    def refresh_token_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_token_expiration", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenResponseMethod")
    def refresh_token_response_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure how refresh tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "refresh_token_response_method")

    @refresh_token_response_method.setter
    def refresh_token_response_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_token_response_method", value)

    @_builtins.property
    @pulumi.getter(name="refreshTokenRotation")
    def refresh_token_rotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Every time the user refreshes their session token via their refresh token, the refresh token itself is also updated to a new one.
        """
        return pulumi.get(self, "refresh_token_rotation")

    @refresh_token_rotation.setter
    def refresh_token_rotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "refresh_token_rotation", value)

    @_builtins.property
    @pulumi.getter(name="sessionMigration")
    def session_migration(self) -> Optional[pulumi.Input['ProjectProjectSettingsSessionMigrationArgs']]:
        """
        Configure seamless migration of existing user sessions from another vendor to Descope.
        """
        return pulumi.get(self, "session_migration")

    @session_migration.setter
    def session_migration(self, value: Optional[pulumi.Input['ProjectProjectSettingsSessionMigrationArgs']]):
        pulumi.set(self, "session_migration", value)

    @_builtins.property
    @pulumi.getter(name="sessionTokenCookieDomain")
    def session_token_cookie_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain name for session token cookies. To read more about custom domain and cookie policy click [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_domain")

    @session_token_cookie_domain.setter
    def session_token_cookie_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_token_cookie_domain", value)

    @_builtins.property
    @pulumi.getter(name="sessionTokenCookiePolicy")
    def session_token_cookie_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use `strict`, `lax` or `none`. Read more about custom domains and cookie policy [here](https://docs.descope.com/how-to-deploy-to-production/custom-domain).
        """
        return pulumi.get(self, "session_token_cookie_policy")

    @session_token_cookie_policy.setter
    def session_token_cookie_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_token_cookie_policy", value)

    @_builtins.property
    @pulumi.getter(name="sessionTokenExpiration")
    def session_token_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time of the session token, used for accessing the application's resources. The value needs to be at least 3 minutes and can't be longer than the refresh token expiration.
        """
        return pulumi.get(self, "session_token_expiration")

    @session_token_expiration.setter
    def session_token_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_token_expiration", value)

    @_builtins.property
    @pulumi.getter(name="sessionTokenResponseMethod")
    def session_token_response_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure how sessions tokens are managed by the Descope SDKs. Must be either `response_body` or `cookies`. The default value is `response_body`.
        """
        return pulumi.get(self, "session_token_response_method")

    @session_token_response_method.setter
    def session_token_response_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_token_response_method", value)

    @_builtins.property
    @pulumi.getter(name="stepUpTokenExpiration")
    def step_up_token_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time for the step up token, after which it will not be valid and the user will automatically go back to the session token.
        """
        return pulumi.get(self, "step_up_token_expiration")

    @step_up_token_expiration.setter
    def step_up_token_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "step_up_token_expiration", value)

    @_builtins.property
    @pulumi.getter(name="testUsersLoginidRegexp")
    def test_users_loginid_regexp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Define a regular expression so that whenever a user is created with a matching login ID it will automatically be marked as a test user.
        """
        return pulumi.get(self, "test_users_loginid_regexp")

    @test_users_loginid_regexp.setter
    def test_users_loginid_regexp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_users_loginid_regexp", value)

    @_builtins.property
    @pulumi.getter(name="testUsersStaticOtp")
    def test_users_static_otp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A 6 digit static OTP code for use with test users.
        """
        return pulumi.get(self, "test_users_static_otp")

    @test_users_static_otp.setter
    def test_users_static_otp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_users_static_otp", value)

    @_builtins.property
    @pulumi.getter(name="testUsersVerifierRegexp")
    def test_users_verifier_regexp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pattern of the verifiers that will be used for testing.
        """
        return pulumi.get(self, "test_users_verifier_regexp")

    @test_users_verifier_regexp.setter
    def test_users_verifier_regexp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_users_verifier_regexp", value)

    @_builtins.property
    @pulumi.getter(name="trustedDeviceTokenExpiration")
    def trusted_device_token_expiration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiry time for the trusted device token. The minimum value is "3 minutes".
        """
        return pulumi.get(self, "trusted_device_token_expiration")

    @trusted_device_token_expiration.setter
    def trusted_device_token_expiration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trusted_device_token_expiration", value)

    @_builtins.property
    @pulumi.getter(name="userJwtTemplate")
    def user_jwt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the user JWT Template.
        """
        return pulumi.get(self, "user_jwt_template")

    @user_jwt_template.setter
    def user_jwt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_jwt_template", value)


if not MYPY:
    class ProjectProjectSettingsSessionMigrationArgsDict(TypedDict):
        audience: NotRequired[pulumi.Input[_builtins.str]]
        """
        The audience value if needed by the vendor.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique client ID for the vendor.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain value if needed by the vendor.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        An issuer URL if needed by the vendor.
        """
        loginid_matched_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
        """
        vendor: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the vendor the sessions are migrated from, in all lowercase.
        """
elif False:
    ProjectProjectSettingsSessionMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProjectSettingsSessionMigrationArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 loginid_matched_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vendor: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audience: The audience value if needed by the vendor.
        :param pulumi.Input[_builtins.str] client_id: The unique client ID for the vendor.
        :param pulumi.Input[_builtins.str] domain: The domain value if needed by the vendor.
        :param pulumi.Input[_builtins.str] issuer: An issuer URL if needed by the vendor.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] loginid_matched_attributes: A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
        :param pulumi.Input[_builtins.str] vendor: The name of the vendor the sessions are migrated from, in all lowercase.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if loginid_matched_attributes is not None:
            pulumi.set(__self__, "loginid_matched_attributes", loginid_matched_attributes)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The audience value if needed by the vendor.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audience", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique client ID for the vendor.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain value if needed by the vendor.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An issuer URL if needed by the vendor.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="loginidMatchedAttributes")
    def loginid_matched_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A set of attributes from the vendor's user that should be used to match with the Descope user's login ID.
        """
        return pulumi.get(self, "loginid_matched_attributes")

    @loginid_matched_attributes.setter
    def loginid_matched_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "loginid_matched_attributes", value)

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the vendor the sessions are migrated from, in all lowercase.
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class ProjectStylesArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
        """
elif False:
    ProjectStylesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectStylesArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        The JSON data defining the visual styling and theme configuration used for authentication, widgets, etc.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)


if not MYPY:
    class ProjectWidgetsArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
        """
elif False:
    ProjectWidgetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectWidgetsArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        The JSON data defining the widget. This will usually be exported as a `.json` file from the Descope console, and set in the `.tf` file using the `data = file("...")` syntax.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)


