Metadata-Version: 2.4
Name: discrete-math-toolkit
Version: 0.2.0
Summary: A comprehensive Python package for discrete mathematics automation
Author-email: CodewithTanzeel <ahmedtanzeel681@gmail.com>
License: MIT
Project-URL: Homepage, https://github.com/CodewithTanzeel/pypi-package-dm
Project-URL: Documentation, https://github.com/CodewithTanzeel/pypi-package-dm#readme
Project-URL: Repository, https://github.com/CodewithTanzeel/pypi-package-dm
Project-URL: Issues, https://github.com/CodewithTanzeel/pypi-package-dm/issues
Keywords: discrete-mathematics,graph-theory,combinatorics,logic,set-theory,number-theory,relations,mathematics,education
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: Topic :: Education
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy>=1.20.0
Requires-Dist: matplotlib>=3.3.0
Requires-Dist: networkx>=2.5
Requires-Dist: sympy>=1.8
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: pytest-cov>=3.0; extra == "dev"
Requires-Dist: black>=22.0; extra == "dev"
Requires-Dist: flake8>=4.0; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Requires-Dist: sphinx>=4.0; extra == "dev"
Requires-Dist: build>=0.7; extra == "dev"
Requires-Dist: twine>=4.0; extra == "dev"
Dynamic: license-file

# ğŸ§® Discrete Math Toolkit

**Your Python companion for discrete mathematics!**

Whether you're a student tackling homework, an educator creating examples, or a researcher exploring mathematical concepts, this toolkit automates the tedious calculations so you can focus on understanding the concepts.

## ğŸ¯ What Can You Do With This?

### For Students ğŸ“š
- âœ… Verify your homework answers instantly
- âœ… Generate truth tables for logic assignments
- âœ… Calculate permutations and combinations without manual work
- âœ… Visualize graph algorithms step-by-step
- âœ… Check if your relations are reflexive, symmetric, or transitive

### For Educators ğŸ‘¨â€ğŸ«
- âœ… Generate examples and test cases quickly
- âœ… Create consistent problem sets
- âœ… Demonstrate algorithms programmatically
- âœ… Build interactive demonstrations

### For Developers ğŸš€
- âœ… Integrate discrete math operations into your applications
- âœ… Build educational tools and games
- âœ… Prototype algorithms before optimization
- âœ… Add mathematical validation to your systems

## ğŸ“¦ Installation

Super simple! Just one command:

```bash
pip install discrete-math-toolkit
```

That's it! No complicated setup, no additional dependencies to worry about.

## ğŸ¯ Two Ways to Use This Library

### 1. **Python API** (For Developers)
Import and use the functions in your Python code:
```python
from discrete_math import combinatorics
result = combinatorics.factorial(5)
```

### 2. **Command Line Interface (CLI)** (For Everyone!)
Use the `dmath` command directly from your terminal - **perfect for non-technical users**:
```bash
dmath factorial 5
# Output: 120
```

**âœ¨ The CLI makes discrete math accessible to everyone - no coding required!**

# ğŸ–¥ï¸ Complete CLI Reference Guide

The Discrete Math Toolkit includes a comprehensive CLI that allows both technical and non-technical users to access all library functions directly from the command line.

## Basic CLI Usage

```bash
dmath <function-name> <arguments>
```

To see all available functions:
```bash
dmath --help
```

To get help for a specific function:
```bash
dmath <function-name> --help
```

---

## ğŸ“Š Combinatorics CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Factorial | `factorial(5)` | `dmath factorial 5` |
| Permutations | `permutations(5, 2)` | `dmath permutations 5 2` |
| Combinations | `combinations(5, 2)` | `dmath combinations 5 2` |
| Binomial Coefficient | `binomial_coefficient(5, 2)` | `dmath binomial 5 2` |
| Permutations with Repetition | `permutations_with_repetition(3, 2)` | `dmath perm-rep 3 2` |
| Combinations with Repetition | `combinations_with_repetition(3, 2)` | `dmath comb-rep 3 2` |
| Pascal's Triangle | `pascals_triangle(5)` | `dmath pascal 5` |
| Catalan Number | `catalan_number(4)` | `dmath catalan 4` |
| Stirling Number | `stirling_second_kind(5, 2)` | `dmath stirling 5 2` |
| Bell Number | `bell_number(4)` | `dmath bell 4` |
| Derangements | `derangements(4)` | `dmath derangements 4` |
| Fibonacci | `fibonacci(10)` | `dmath fibonacci 10` |
| Multinomial | `multinomial_coefficient([2,3,4])` | `dmath multinomial 2 3 4` |

### CLI Examples - Combinatorics

```bash
# Factorial
dmath factorial 5
# Output: 120

# Permutations P(5,2)
dmath permutations 5 2
# Output: 20

# Combinations C(10,3)
dmath combinations 10 3
# Output: 120

# Pascal's Triangle with 5 rows
dmath pascal 5

# Catalan number
dmath catalan 4
# Output: 14

# Fibonacci
dmath fibonacci 10
# Output: 55

# Generate permutations
dmath gen-perms "[1,2,3]" 2
# Output: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

# Generate combinations
dmath gen-combs "[1,2,3,4]" 2
# Output: [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]

# Generate combinations with repetition
dmath gen-combs-rep "[1,2]" 2
# Output: [(1, 1), (1, 2), (2, 2)]
```

---

## ğŸ”¢ Number Theory CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| GCD | `gcd(48, 18)` | `dmath gcd 48 18` |
| LCM | `lcm(12, 18)` | `dmath lcm 12 18` |
| Extended GCD | `extended_gcd(30, 20)` | `dmath extended-gcd 30 20` |
| Is Prime | `is_prime(17)` | `dmath is-prime 17` |
| Prime Factorization | `prime_factorization(60)` | `dmath prime-factors 60` |
| Primes Up To N | `sieve_of_eratosthenes(20)` | `dmath primes-upto 20` |
| Modular Inverse | `mod_inverse(3, 11)` | `dmath mod-inverse 3 11` |
| Modular Exponentiation | `mod_exp(2, 10, 1000)` | `dmath mod-exp 2 10 1000` |
| Euler's Totient | `euler_totient(9)` | `dmath euler-phi 9` |
| Chinese Remainder Theorem | `chinese_remainder_theorem([2,3,2], [3,5,7])` | `dmath crt "[2,3,2]" "[3,5,7]"` |
| Is Coprime | `is_coprime(15, 28)` | `dmath is-coprime 15 28` |
| Divisors | `divisors(12)` | `dmath divisors 12` |
| Sum of Divisors | `sum_of_divisors(12)` | `dmath sum-divisors 12` |
| Is Perfect Number | `is_perfect_number(6)` | `dmath is-perfect 6` |

### CLI Examples - Number Theory

```bash
# GCD
dmath gcd 48 18
# Output: 6

# LCM
dmath lcm 12 18
# Output: 36

# Extended GCD (returns gcd, x, y where ax + by = gcd)
dmath extended-gcd 30 20
# Output: (10, 1, -1)

# Check if prime
dmath is-prime 17
# Output: True

# Prime factorization
dmath prime-factors 60
# Output: {2: 2, 3: 1, 5: 1}  (60 = 2Â² Ã— 3 Ã— 5)

# Find all primes up to N
dmath primes-upto 20
# Output: [2, 3, 5, 7, 11, 13, 17, 19]

# Modular inverse
dmath mod-inverse 3 11
# Output: 4  (because 3 Ã— 4 â‰¡ 1 (mod 11))

# Modular exponentiation
dmath mod-exp 2 10 1000
# Output: 24  (2^10 mod 1000)

# Euler's totient
dmath euler-phi 9
# Output: 6

# Chinese Remainder Theorem
dmath crt "[2,3,2]" "[3,5,7]"
# Output: 23

# Find divisors
dmath divisors 12
# Output: [1, 2, 3, 4, 6, 12]

# Check if perfect number
dmath is-perfect 6
# Output: True
```

---

## ğŸ§  Logic CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Truth Table | `generate_truth_table("p AND q")` | `dmath truth-table "p AND q"` |
| Is Tautology | `is_tautology("p OR (NOT p)")` | `dmath is-tautology "p OR (NOT p)"` |
| Is Contradiction | `is_contradiction("p AND (NOT p)")` | `dmath is-contradiction "p AND (NOT p)"` |
| Is Contingency | `is_contingency("p AND q")` | `dmath is-contingency "p AND q"` |
| Convert to CNF | `convert_to_cnf("p IMPLIES q")` | `dmath to-cnf "p IMPLIES q"` |
| Convert to DNF | `convert_to_dnf("p IMPLIES q")` | `dmath to-dnf "p IMPLIES q"` |
| Logical Equivalence | `are_equivalent(expr1, expr2)` | `dmath logic-equiv "p IMPLIES q" "(NOT p) OR q"` |
| Simplify | `simplify("p AND p")` | `dmath simplify-logic "p AND p"` |
| Evaluate | `evaluate("p AND q", {"p": True, "q": False})` | `dmath eval-logic "p AND q" '{"p": true, "q": false}'` |
| Minterms | `get_minterms("p OR q")` | `dmath minterms "p OR q"` |
| Maxterms | `get_maxterms("p OR q")` | `dmath maxterms "p OR q"` |

### CLI Examples - Logic

```bash
# Generate truth table
dmath truth-table "p AND q"
dmath truth-table "p IMPLIES q"
dmath truth-table "(p OR q) AND (NOT r)"

# Check if tautology (always true)
dmath is-tautology "p OR (NOT p)"
# Output: True

# Check if contradiction (always false)
dmath is-contradiction "p AND (NOT p)"
# Output: True

# Check if contingency
dmath is-contingency "p AND q"
# Output: True

# Convert to CNF
dmath to-cnf "p IMPLIES q"
# Output: (~p) | q

# Convert to DNF
dmath to-dnf "p IMPLIES q"
# Output: (~p) | q

# Check logical equivalence
dmath logic-equiv "p IMPLIES q" "(NOT p) OR q"
# Output: True

# Simplify expression
dmath simplify-logic "p AND p"
# Output: p

# Evaluate with values
dmath eval-logic "p AND q" '{"p": true, "q": false}'
# Output: False

# Get minterms (rows where True)
dmath minterms "p OR q"
# Output: [1, 2, 3]

# Get maxterms (rows where False)
dmath maxterms "p OR q"
# Output: [0]
```

**Supported Logical Operators in CLI:**
- `AND`, `&`, `âˆ§`
- `OR`, `|`, `âˆ¨`
- `NOT`, `~`, `Â¬`
- `IMPLIES`, `->`
- `IFF`, `<->`
- `XOR`, `^`

---

## ğŸ“¦ Set Theory CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Union | `union({1,2,3}, {3,4,5})` | `dmath set-union "{1,2,3}" "{3,4,5}"` |
| Intersection | `intersection({1,2,3}, {2,3,4})` | `dmath set-intersect "{1,2,3}" "{2,3,4}"` |
| Difference | `difference({1,2,3}, {2,3,4})` | `dmath set-diff "{1,2,3}" "{2,3,4}"` |
| Symmetric Difference | `symmetric_difference({1,2,3}, {2,3,4})` | `dmath set-sym-diff "{1,2,3}" "{2,3,4}"` |
| Complement | `complement({1,2}, {1,2,3,4,5})` | `dmath set-complement "{1,2}" "{1,2,3,4,5}"` |
| Power Set | `power_set({1,2,3})` | `dmath power-set "{1,2,3}"` |
| Cartesian Product | `cartesian_product({1,2}, {3,4})` | `dmath cartesian "{1,2}" "{3,4}"` |
| Is Subset | `is_subset({1,2}, {1,2,3,4})` | `dmath is-subset "{1,2}" "{1,2,3,4}"` |
| Is Proper Subset | `is_proper_subset({1,2}, {1,2,3})` | `dmath is-proper-subset "{1,2}" "{1,2,3}"` |
| Is Superset | `is_superset({1,2,3,4}, {1,2})` | `dmath is-superset "{1,2,3,4}" "{1,2}"` |
| Is Disjoint | `is_disjoint({1,2}, {3,4})` | `dmath is-disjoint "{1,2}" "{3,4}"` |
| Cardinality | `cardinality({1,2,3,4,5})` | `dmath cardinality "{1,2,3,4,5}"` |
| Is Partition | `partition({1,2,3,4}, {1,2}, {3}, {4})` | `dmath is-partition "{1,2,3,4}" "{1,2}" "{3}" "{4}"` |
| Sets Equal | `are_equal({1,2,3}, {3,2,1})` | `dmath sets-equal "{1,2,3}" "{3,2,1}"` |
| Power Set Size | `power_set_cardinality({1,2,3})` | `dmath power-set-size "{1,2,3}"` |

### CLI Examples - Set Theory

```bash
# Union
dmath set-union "{1,2,3}" "{3,4,5}"
# Output: [1, 2, 3, 4, 5]

# Multiple sets union
dmath set-union "{1,2}" "{2,3}" "{3,4}"
# Output: [1, 2, 3, 4]

# Intersection
dmath set-intersect "{1,2,3}" "{2,3,4}"
# Output: [2, 3]

# Difference (A - B)
dmath set-diff "{1,2,3}" "{2,3,4}"
# Output: [1]

# Symmetric Difference
dmath set-sym-diff "{1,2,3}" "{2,3,4}"
# Output: [1, 4]

# Complement
dmath set-complement "{1,2}" "{1,2,3,4,5}"
# Output: [3, 4, 5]

# Power Set
dmath power-set "{1,2,3}"
# Output: All subsets including empty set

# Cartesian Product
dmath cartesian "{1,2}" "{3,4}"
# Output: [(1, 3), (1, 4), (2, 3), (2, 4)]

# Cartesian Product of N sets
dmath cartesian-n "{1,2}" "{a,b}" "{x,y}"
# Output: All n-tuples from the product

# Check subset
dmath is-subset "{1,2}" "{1,2,3,4}"
# Output: True

# Check proper subset
dmath is-proper-subset "{1,2}" "{1,2,3}"
# Output: True

# Check superset
dmath is-superset "{1,2,3,4}" "{1,2}"
# Output: True

# Check disjoint
dmath is-disjoint "{1,2}" "{3,4}"
# Output: True

# Cardinality
dmath cardinality "{1,2,3,4,5}"
# Output: 5

# Check partition
dmath is-partition "{1,2,3,4}" "{1,2}" "{3}" "{4}"
# Output: True

# Check sets equal
dmath sets-equal "{1,2,3}" "{3,2,1}"
# Output: True

# Power set cardinality
dmath power-set-size "{1,2,3}"
# Output: 8  (2^3)
```

---

## ğŸ”— Relations CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Is Reflexive | `is_reflexive(R, domain)` | `dmath is-reflexive "{(1,1),(2,2),(3,3)}" "{1,2,3}"` |
| Is Symmetric | `is_symmetric(R)` | `dmath is-symmetric "{(1,2),(2,1),(3,3)}"` |
| Is Antisymmetric | `is_antisymmetric(R)` | `dmath is-antisymmetric "{(1,2),(2,3),(1,1)}"` |
| Is Transitive | `is_transitive(R)` | `dmath is-transitive "{(1,2),(2,3),(1,3)}"` |
| Is Equivalence | `is_equivalence_relation(R, domain)` | `dmath is-equivalence "{(1,1),(2,2),(1,2),(2,1)}" "{1,2}"` |
| Is Partial Order | `is_partial_order(R, domain)` | `dmath is-partial-order "{(1,1),(2,2),(1,2)}" "{1,2}"` |
| Reflexive Closure | `reflexive_closure(R, domain)` | `dmath reflexive-closure "{(1,2),(2,3)}" "{1,2,3}"` |
| Symmetric Closure | `symmetric_closure(R)` | `dmath symmetric-closure "{(1,2),(2,3)}"` |
| Transitive Closure | `transitive_closure(R)` | `dmath transitive-closure "{(1,2),(2,3)}"` |
| Equivalence Classes | `equivalence_classes(R, domain)` | `dmath equiv-classes "{(1,1),(2,2),(1,2),(2,1)}" "{1,2}"` |
| Compose Relations | `compose(R1, R2)` | `dmath compose-rel "{(1,2),(2,3)}" "{(2,4),(3,5)}"` |
| Inverse Relation | `inverse_relation(R)` | `dmath inverse-rel "{(1,2),(2,3),(3,4)}"` |
| Relation Domain | `get_domain(R)` | `dmath rel-domain "{(1,2),(2,3),(3,4)}"` |
| Relation Range | `get_range(R)` | `dmath rel-range "{(1,2),(2,3),(3,4)}"` |
| Relation Matrix | `relation_matrix(R, elements)` | `dmath rel-matrix "{(0,0),(0,1),(1,1)}" "[0,1,2]"` |

### CLI Examples - Relations

```bash
# Check reflexive
dmath is-reflexive "{(1,1),(2,2),(3,3)}" "{1,2,3}"
# Output: True

# Check symmetric
dmath is-symmetric "{(1,2),(2,1),(3,3)}"
# Output: True

# Check antisymmetric
dmath is-antisymmetric "{(1,2),(2,3),(1,1)}"
# Output: True

# Check transitive
dmath is-transitive "{(1,2),(2,3),(1,3)}"
# Output: True

# Check equivalence relation
dmath is-equivalence "{(1,1),(2,2),(3,3),(1,2),(2,1)}" "{1,2,3}"
# Output: False (not transitive)

# Check partial order
dmath is-partial-order "{(1,1),(2,2),(3,3),(1,2),(2,3),(1,3)}" "{1,2,3}"
# Output: True

# Reflexive closure
dmath reflexive-closure "{(1,2),(2,3)}" "{1,2,3}"
# Output: {(1,1),(2,2),(3,3),(1,2),(2,3)}

# Symmetric closure
dmath symmetric-closure "{(1,2),(2,3)}"
# Output: {(1,2),(2,1),(2,3),(3,2)}

# Transitive closure
dmath transitive-closure "{(1,2),(2,3)}"
# Output: {(1,2),(2,3),(1,3)}

# Equivalence classes
dmath equiv-classes "{(1,1),(2,2),(3,3),(1,2),(2,1)}" "{1,2,3}"
# Output: [{1, 2}, {3}]

# Compose relations
dmath compose-rel "{(1,2),(2,3)}" "{(2,4),(3,5)}"
# Output: Composed relation

# Inverse relation
dmath inverse-rel "{(1,2),(2,3),(3,4)}"
# Output: {(2,1),(3,2),(4,3)}

# Relation domain
dmath rel-domain "{(1,2),(2,3),(3,4)}"
# Output: {1, 2, 3}

# Relation range
dmath rel-range "{(1,2),(2,3),(3,4)}"
# Output: {2, 3, 4}

# Relation matrix
dmath rel-matrix "{(0,0),(0,1),(1,1)}" "[0,1,2]"
# Output: [[1, 1, 0], [0, 1, 0], [0, 0, 0]]
```

---

## ğŸ¯ Functions CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Is Function | `is_function(R, domain)` | `dmath is-function "{(1,2),(2,3),(3,4)}" "{1,2,3}"` |
| Is Injective | `is_injective(f)` | `dmath is-injective "{(1,2),(2,3),(3,4)}"` |
| Is Surjective | `is_surjective(f, codomain)` | `dmath is-surjective "{(1,'a'),(2,'b')}" "{'a','b'}"` |
| Is Bijective | `is_bijective(f, domain, codomain)` | `dmath is-bijective "{(1,2),(2,3)}" "{1,2}" "{2,3}"` |
| Compose Functions | `compose_functions(g, f)` | `dmath compose-func "{(1,2),(2,3)}" "{(0,1),(1,2)}"` |
| Inverse Function | `inverse_function(f, domain, codomain)` | `dmath inverse-func "{(1,2),(2,3),(3,4)}"` |
| Function Domain | `get_domain(f)` | `dmath func-domain "{(1,2),(2,3),(3,4)}"` |
| Function Range | `get_range(f)` | `dmath func-range "{(1,2),(2,3),(3,4)}"` |
| Function to Dict | `function_to_dict(f)` | `dmath func-to-dict "{(1,2),(2,3),(3,4)}"` |

### CLI Examples - Functions

```bash
# Check if relation is a function
dmath is-function "{(1,2),(2,3),(3,4)}" "{1,2,3}"
# Output: True

dmath is-function "{(1,2),(1,3)}" "{1,2}"
# Output: False (one input maps to multiple outputs)

# Check injective (one-to-one)
dmath is-injective "{(1,2),(2,3),(3,4)}"
# Output: True

# Check surjective (onto)
dmath is-surjective "{(1,'a'),(2,'b')}" "{'a','b'}"
# Output: True

# Check bijective
dmath is-bijective "{(1,2),(2,3),(3,4)}" "{1,2,3}" "{2,3,4}"
# Output: True

# Compose functions
dmath compose-func "{(1,2),(2,3),(3,4)}" "{(0,1),(1,2),(2,3)}"
# Output: {(0, 2), (1, 3), (2, 4)}

# Inverse function
dmath inverse-func "{(1,2),(2,3),(3,4)}"
# Output: {(2,1),(3,2),(4,3)}

# Get function domain
dmath func-domain "{(1,2),(2,3),(3,4)}"
# Output: {1, 2, 3}

# Get function range
dmath func-range "{(1,2),(2,3),(3,4)}"
# Output: {2, 3, 4}

# Convert function to dictionary
dmath func-to-dict "{(1,2),(2,3),(3,4)}"
# Output: {1: 2, 2: 3, 3: 4}
```

---

## ğŸ“ˆ Graph CLI Commands

| Function | Python Code | CLI Command |
|----------|-------------|-------------|
| Complete Graph | `Graph.complete_graph(5)` | `dmath complete-graph 5` |
| Cycle Graph | `Graph.cycle_graph(4)` | `dmath cycle-graph 4` |
| Path Graph | `Graph.path_graph(3)` | `dmath path-graph 3` |
| BFS Traversal | `graph.bfs(start)` | `dmath graph-bfs "[(0,1),(1,2)]" 0` |
| DFS Traversal | `graph.dfs(start)` | `dmath graph-dfs "[(0,1),(1,2)]" 0` |
| Is Connected | `graph.is_connected()` | `dmath graph-connected "[(0,1),(1,2)]"` |
| Has Cycle | `graph.has_cycle()` | `dmath graph-cycle "[(0,1),(1,2),(2,0)]"` |
| Is Bipartite | `graph.is_bipartite()` | `dmath graph-bipartite "[(0,1),(1,2)]"` |
| Shortest Path | `graph.shortest_path(s, t)` | `dmath graph-shortest-path "[(0,1),(1,2)]" 0 2` |
| Topological Sort | `graph.topological_sort()` | `dmath graph-topo-sort "[(0,1),(1,2)]"` |

### CLI Examples - Graphs

```bash
# Create complete graph K_5
dmath complete-graph 5

# Create cycle graph C_4
dmath cycle-graph 4

# Create path graph P_3
dmath path-graph 3

# BFS traversal
dmath graph-bfs "[(0,1),(1,2),(2,3),(0,3)]" 0
# Output: [0, 1, 3, 2]

# DFS traversal
dmath graph-dfs "[(0,1),(1,2),(2,3),(0,3)]" 0
# Output: [0, 1, 2, 3]

# Check if connected
dmath graph-connected "[(0,1),(1,2),(2,3)]"
# Output: True

# Check if has cycle
dmath graph-cycle "[(0,1),(1,2),(2,0)]"
# Output: True

# Check if bipartite
dmath graph-bipartite "[(0,1),(1,2),(2,3),(3,0)]"
# Output: True

# Shortest path
dmath graph-shortest-path "[(0,1),(1,2),(2,3),(0,3)]" 0 3
# Output: Path: [0, 3], Distance: 1.0

# Topological sort (for DAGs)
dmath graph-topo-sort "[(0,1),(1,2),(0,2)]"
# Output: [0, 1, 2]
```

---

## ğŸ’¡ CLI Tips for Non-Technical Users

### Understanding Input Notation

| Type | Format | Example |
|------|--------|---------|
| Sets | Curly braces | `"{1,2,3}"` |
| Relations/Functions | Set of pairs | `"{(1,2),(2,3)}"` |
| Lists | Square brackets | `"[1,2,3]"` |
| Empty set | Empty braces | `"{}"` |

### Common Mistakes to Avoid

1. **Forgetting quotes for sets**: Use `"{1,2,3}"` not `{1,2,3}`
2. **Wrong syntax for relations**: Use `"{(1,2),(2,3)}"` not `{(1,2),(2,3)}`
3. **Logical operators**: Use `"p AND q"` not `"p && q"`

### Getting Help

```bash
# See all commands
dmath --help

# Get help for a specific command
dmath factorial --help
dmath is-prime --help
```

---

## ğŸ“ CLI Educational Examples

### Example 1: Homework Helper - Set Theory
```bash
# Given A = {1,2,3,4,5} and B = {4,5,6,7}
# Find: A âˆª B, A âˆ© B, A - B

dmath set-union "{1,2,3,4,5}" "{4,5,6,7}"
# Output: [1, 2, 3, 4, 5, 6, 7]

dmath set-intersect "{1,2,3,4,5}" "{4,5,6,7}"
# Output: [4, 5]

dmath set-diff "{1,2,3,4,5}" "{4,5,6,7}"
# Output: [1, 2, 3]
```

### Example 2: Combinatorics Problems
```bash
# How many ways to choose 3 items from 10?
dmath combinations 10 3
# Output: 120

# How many ways to arrange 5 items?
dmath permutations 5
# Output: 120

# Calculate 10!
dmath factorial 10
# Output: 3628800
```

### Example 3: Number Theory
```bash
# Check if numbers are prime
dmath is-prime 17
# Output: True

dmath is-prime 20
# Output: False

# Find GCD and LCM
dmath gcd 48 18
# Output: 6

dmath lcm 48 18
# Output: 144
```

### Example 4: Logic Verification
```bash
# Check if an expression is always true
dmath is-tautology "p OR (NOT p)"
# Output: True

# Check logical equivalence
dmath logic-equiv "p IMPLIES q" "(NOT p) OR q"
# Output: True
```

---

## ğŸ¯ Benefits of CLI Access

âœ… **Easy for beginners** - No Python knowledge required  
âœ… **Quick calculations** - Run functions directly from terminal  
âœ… **Educational tool** - Perfect for learning discrete mathematics  
âœ… **Scriptable** - Can be used in shell scripts and automation  
âœ… **Cross-platform** - Works on Windows, Mac, and Linux



## ğŸš€ Quick Start - Get Results in 30 Seconds

```python
from discrete_math import logic, sets, combinatorics

# Example 1: Check if a logical statement is always true
print(logic.is_tautology("p OR (NOT p)"))  # True - this is always true!

# Example 2: Find what elements two sets share
students_in_math = {1, 2, 3, 4, 5}
students_in_cs = {3, 4, 5, 6, 7}
print(sets.intersection(students_in_math, students_in_cs))  # {3, 4, 5}

# Example 3: How many ways can you choose 3 people from 10?
print(combinatorics.combinations(10, 3))  # 120 different ways!
```

## ğŸ“š Complete Feature Guide

---
## 1ï¸âƒ£ Logic Module â€“ Work with Logical Statements

**What it does:**  
Analyze propositional logic expressions, generate truth tables, evaluate expressions, check logical properties, convert to normal forms, and extract minterms/maxterms.

This module is ideal for **Discrete Mathematics**, **Logic Design**, and **Computer Organization** students.

---

## ğŸ”¹ Supported Logical Operators

| Operator | Syntax |
|--------|-------|
| AND | `AND`, `&`, `âˆ§` |
| OR | `OR`, `|`, `âˆ¨` |
| NOT | `NOT`, `~`, `Â¬` |
| IMPLIES | `IMPLIES`, `->` |
| IFF (â†”) | `IFF`, `<->` |
| XOR | `XOR`, `^` |

---

## ğŸ“˜ Example Usage

```python
from discrete_math.logic import *
````


## âœ… 1. Generate Truth Tables

```python

table = generate_truth_table("p AND q")
print(table)
```

**Output:**

```text
[
 {'p': False, 'q': False, 'result': False},
 {'p': False, 'q': True, 'result': False},
 {'p': True, 'q': False, 'result': False},
 {'p': True, 'q': True, 'result': True}
]
```

ğŸ“Œ *Useful for understanding all possible outcomes of a logical expression.*

---

## âœ… 2. Check Logical Properties

### ğŸ”¹ Tautology (Always True)

```python
print(is_tautology("p OR (NOT p)"))
```

âœ”ï¸ Output:

```text
True
```

---

### ğŸ”¹ Contradiction (Always False)

```python
print(is_contradiction("p AND (NOT p)"))
```

âœ”ï¸ Output:

```text
True
```

---

### ğŸ”¹ Contingency (Sometimes True, Sometimes False)

```python
print(is_contingency("p AND q"))
```

âœ”ï¸ Output:

```text
True
```

---

## âœ… 3. Evaluate an Expression with Given Values

```python
result = evaluate("p AND q", {"p": True, "q": False})
print(result)
```

âœ”ï¸ Output:

```text
False
```

ğŸ“Œ *Helpful in exams and quick verification.*

---

## âœ… 4. Convert to Normal Forms

### ğŸ”¹ Conjunctive Normal Form (CNF)

```python
cnf = convert_to_cnf("(p OR q) IMPLIES r")
print(cnf)
```

âœ”ï¸ Output:

```text
(~p | r) & (~q | r)
```

---

### ğŸ”¹ Disjunctive Normal Form (DNF)

```python
dnf = convert_to_dnf("(p AND q) OR (p AND r)")
print(dnf)
```

âœ”ï¸ Output:

```text
p & (q | r)
```

---

## âœ… 5. Simplify Logical Expressions

```python
simple = simplify("(p AND p) OR (q AND True)")
print(simple)
```

âœ”ï¸ Output:

```text
p | q
```

ğŸ“Œ *Applies logical identities automatically.*

---

## âœ… 6. Check Logical Equivalence

```python
expr1 = "p IMPLIES q"
expr2 = "(NOT p) OR q"

print(are_equivalent(expr1, expr2))
```

âœ”ï¸ Output:

```text
True
```

ğŸ“Œ *Confirms whether two expressions mean the same thing.*

---

## âœ… 7. Find Minterms

```python
print(get_minterms("p OR q"))
```

âœ”ï¸ Output:

```text
[1, 2, 3]
```

ğŸ“Œ *Indexes represent rows where the expression is TRUE.*

---

## âœ… 8. Find Maxterms

```python
print(get_maxterms("p OR q"))
```

âœ”ï¸ Output:

```text
[0]
```

ğŸ“Œ *Indexes represent rows where the expression is FALSE.*

---

## ğŸ“ Student Tip

* Use **truth tables** to verify exam answers
* Use **CNF/DNF** for SAT solvers and logic circuits
* Use **minterms/maxterms** in Boolean algebra & K-maps

---


## 2ï¸âƒ£ Sets Module â€“ Master Set Operations

**What it does:**  
Perform all fundamental and advanced set theory operations such as union, intersection, difference, power sets, Cartesian products, partitions, and set relationships.

This module is ideal for **Discrete Mathematics**, **Computer Science**, and **Logic Foundations**.

---

## ğŸ“˜ Example Usage

```python
from discrete_math.sets import *
````

---

## âœ… 1. Basic Set Operations

### ğŸ”¹ Union

```python
result = union({1, 2}, {2, 3}, {3, 4})
print(result)
```

**Output:**

```text
{1, 2, 3, 4}
```

---

### ğŸ”¹ Intersection

```python
result = intersection({1, 2, 3}, {2, 3, 4})
print(result)
```

**Output:**

```text
{2, 3}
```

---

### ğŸ”¹ Difference (A âˆ’ B)

```python
result = difference({1, 2, 3}, {2, 3, 4})
print(result)
```

**Output:**

```text
{1}
```

---

### ğŸ”¹ Symmetric Difference (A â–³ B)

```python
result = symmetric_difference({1, 2, 3}, {2, 3, 4})
print(result)
```

**Output:**

```text
{1, 4}
```

---

### ğŸ”¹ Complement

```python
universal = {1, 2, 3, 4, 5}
subset = {1, 2}
print(complement(subset, universal))
```

**Output:**

```text
{3, 4, 5}
```

---

## âœ… 2. Power Sets

### ğŸ”¹ Generate Power Set

```python
ps = power_set({1, 2})
print(ps)
```

**Output:**

```text
{frozenset(), frozenset({1}), frozenset({2}), frozenset({1, 2})}
```

ğŸ“Œ *Each subset is returned as a `frozenset`.*

---

### ğŸ”¹ Power Set Cardinality (Without Generating)

```python
print(power_set_cardinality({1, 2, 3}))
```

**Output:**

```text
8
```

ğŸ“Œ *Uses the formula: 2â¿*

---

## âœ… 3. Cartesian Products

### ğŸ”¹ Cartesian Product of Two Sets

```python
pairs = cartesian_product({1, 2}, {'a', 'b'})
print(pairs)
```

**Output:**

```text
{(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')}
```

---

### ğŸ”¹ Cartesian Product of N Sets

```python
result = cartesian_product_n({1, 2}, {'a', 'b'}, {True, False})
print(result)
```

ğŸ“Œ *Returns all possible n-tuples.*

---

## âœ… 4. Set Relationships

### ğŸ”¹ Subset (âŠ†)

```python
print(is_subset({1, 2}, {1, 2, 3}))
```

**Output:**

```text
True
```

---

### ğŸ”¹ Proper Subset (âŠ‚)

```python
print(is_proper_subset({1, 2}, {1, 2, 3}))
```

**Output:**

```text
True
```

---

### ğŸ”¹ Superset (âŠ‡)

```python
print(is_superset({1, 2, 3}, {1, 2}))
```

**Output:**

```text
True
```

---

### ğŸ”¹ Disjoint Sets

```python
print(is_disjoint({1, 2}, {3, 4}))
```

**Output:**

```text
True
```

---

### ğŸ”¹ Set Equality

```python
print(are_equal({1, 2, 3}, {3, 2, 1}))
```

**Output:**

```text
True
```

---

## âœ… 5. Cardinality

```python
print(cardinality({10, 20, 30, 40}))
```

**Output:**

```text
4
```

ğŸ“Œ *Returns the number of elements in a set.*

---

## âœ… 6. Partition of a Set

```python
result = partition({1, 2, 3, 4}, {1, 2}, {3}, {4})
print(result)
```

**Output:**

```text
True
```

ğŸ“Œ *Checks whether subsets form a valid partition.*

---

## âœ… 7. Set-Builder Notation

```python
evens = set_builder(lambda x: x % 2 == 0, {1, 2, 3, 4, 5, 6})
print(evens)
```

**Output:**

```text
{2, 4, 6}
```

ğŸ“Œ *Mimics mathematical set-builder notation.*


---

Got it ğŸ‘
Iâ€™ll **fix and extend your README section** so that it **covers *all* public functions** exposed by your **Combinatorics Module**, based strictly on the `__all__` list in your code.

Below is a **drop-in replacement** for your current README section, written in the **same style**, with **clear examples for every function**.

---

## 3ï¸âƒ£ Combinatorics Module â€“ Count Like a Pro

**What it does:**
Perform combinatorial calculations such as permutations, combinations, binomial coefficients, and advanced counting sequences used in probability, algorithms, and discrete mathematics.

---

### ğŸ“ Real-World Use Case: Counting, Probability & Algorithms

```python
from discrete_math.combinatorics import *
```

---

### ğŸ”¢ Basic Building Block

#### Factorial

```python
# 5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1
print(factorial(5))  # 120
```

---

### ğŸ” Permutations & Combinations

#### Permutations (order matters)

```python
# Arrange 3 items from 5
print(permutations(5, 3))  # 60
```

#### Combinations (order does NOT matter)

```python
# Choose 3 students from 10
print(combinations(10, 3))  # 120
```

---

### ğŸ”‚ With Repetition Allowed

#### Permutations with repetition

```python
# 3-character password from 4 symbols (repetition allowed)
print(permutations_with_repetition(4, 3))  # 64
```

#### Combinations with repetition

```python
# Choose 3 candies from 5 types
print(combinations_with_repetition(5, 3))  # 35
```

---

### ğŸ“ Binomial & Multinomial Coefficients

#### Binomial Coefficient

```python
# C(5,2)
print(binomial_coefficient(5, 2))  # 10
```

#### Multinomial Coefficient

```python
# Distribute items into groups of sizes 2,1,1
print(multinomial_coefficient([2, 1, 1]))  # 12
```

---

### ğŸ“Š Pascalâ€™s Triangle

```python
triangle = pascals_triangle(5)
for row in triangle:
    print(row)

# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
```

---

### ğŸŒ± Famous Sequences

#### Fibonacci Numbers

```python
print(fibonacci(10))  # 55
```

#### Catalan Numbers

```python
# Used in counting trees, valid parentheses, etc.
print(catalan_number(5))  # 42
```

---

### ğŸ”„ Special Counting Problems

#### Derangements (no element in original position)

```python
# Secret Santa problem
print(derangements(4))  # 9
```

#### Stirling Numbers (Second Kind)

```python
# Partition 5 elements into 2 non-empty sets
print(stirling_second_kind(5, 2))  # 15
```

#### Bell Numbers

```python
# Number of ways to partition a set of size 4
print(bell_number(4))  # 15
```

---

### ğŸ” Generators (Actual Arrangements)

#### Generate permutations

```python
for p in generate_permutations([1, 2, 3], 2):
    print(p)

# (1, 2)
# (1, 3)
# (2, 1)
# ...
```

#### Generate combinations

```python
for c in generate_combinations([1, 2, 3, 4], 2):
    print(c)
```

#### Generate combinations with repetition

```python
for c in generate_combinations_with_repetition([1, 2, 3], 2):
    print(c)
```

---

### ğŸ’¡ Student Tip

* **Permutations** â†’ order matters (rankings, passwords)
* **Combinations** â†’ order doesnâ€™t matter (teams, selections)
* **Catalan & Stirling numbers** often appear in **DSA, trees, and recursion problems**






## 5ï¸âƒ£ Number Theory Module - Explore Number Properties

Perfect â€” Iâ€™ll **repeat the same process** as before ğŸ‘
Below is a **clean, complete, drop-in README.md section** for your **Number Theory Module**, **covering *every function listed in `__all__`***, written in the **same tone, structure, and teaching style** you used.

You can **copy-paste this directly** into `README.md`.

---

## 5ï¸âƒ£ Number Theory Module â€“ Explore Number Properties

**What it does:**
Work with prime numbers, divisibility, GCD/LCM, modular arithmetic, and classic number-theoretic functions used in cryptography, algorithms, and discrete mathematics.

---

### ğŸ“ Real-World Use Case: Cryptography, Scheduling & Mathematics

```python
from discrete_math.number_theory import *
```

---

### ğŸ”¢ Fundamental Operations

#### Greatest Common Divisor (GCD)

```python
# Simplifying fractions, checking coprimality
print(gcd(48, 18))  # 6
print(gcd(17, 19))  # 1
```

#### Least Common Multiple (LCM)

```python
# Scheduling and periodic events
print(lcm(12, 18))  # 36
print(lcm(7, 5))    # 35
```

---

### ğŸ” Extended Euclidean Algorithm

```python
# Finds gcd(a, b) and x, y such that ax + by = gcd(a, b)
g, x, y = extended_gcd(30, 20)
print(g, x, y)  # 10, 1, -1
```

ğŸ“Œ **Used in:** Modular inverse, cryptography, Diophantine equations

---

### ğŸ” Prime Number Utilities

#### Prime Test

```python
print(is_prime(17))  # True
print(is_prime(100)) # False
```

#### Prime Factorization

```python
factors = prime_factorization(60)
print(factors)  # {2: 2, 3: 1, 5: 1}
# 60 = 2Â² Ã— 3Â¹ Ã— 5Â¹
```

#### Generate Primes (Sieve of Eratosthenes)

```python
print(sieve_of_eratosthenes(30))
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

---

### ğŸ” Modular Arithmetic (Cryptography Core)

#### Modular Inverse

```python
# Find x such that (a * x) % m == 1
inverse = mod_inverse(3, 11)
print(inverse)  # 4
```

âš ï¸ Raises error if inverse does not exist.

---

#### Fast Modular Exponentiation

```python
print(mod_exp(2, 100, 17))  # Efficient for huge powers
print(mod_exp(3, 10, 7))    # 4
```

ğŸ“Œ **Used in:** RSA, Diffie-Hellman, hashing

---

### ğŸ”¢ Eulerâ€™s Totient Function

```python
# Counts integers â‰¤ n that are coprime with n
print(euler_totient(9))   # 6
print(euler_totient(10))  # 4
```

ğŸ“Œ **Key idea in RSA encryption**

---

### ğŸ§® Chinese Remainder Theorem (CRT)

```python
# Solve:
# x â‰¡ 2 (mod 3)
# x â‰¡ 3 (mod 5)
# x â‰¡ 2 (mod 7)
solution = chinese_remainder_theorem([2, 3, 2], [3, 5, 7])
print(solution)  # 23
```

ğŸ“Œ **Used in:** Distributed systems, cryptography, time synchronization

---

### ğŸ”— Coprimality

```python
print(is_coprime(15, 28))  # True
print(is_coprime(15, 25))  # False
```

---

### ğŸ“ Divisor Functions

#### All Divisors

```python
print(divisors(24))
# [1, 2, 3, 4, 6, 8, 12, 24]
```

#### Sum of Divisors

```python
print(sum_of_divisors(12))  # 28
```

---

### â­ Perfect Numbers

```python
print(is_perfect_number(6))   # True
print(is_perfect_number(28))  # True
print(is_perfect_number(12))  # False
```

ğŸ“Œ A **perfect number** equals the sum of its proper divisors.




Got it ğŸ‘
Below is the **complete, polished README.md section for the Relations Module**, written in **the same style, structure, tone, and teaching depth** as your previous modules.
It **covers *all functions listed in `__all__`*** and aligns perfectly with the code you shared.

You can **copy-paste this directly into `README.md`**.

---

## 6ï¸âƒ£ Relations Module â€“ Analyze Relationships

**What it does:**
Work with binary relations, check their properties, compute closures, and analyze structured relationships mathematically.

---

### ğŸ“ Real-World Use Case: Databases, Hierarchies & Graphs

```python
from discrete_math.relations import *
```

---

### ğŸ”— Defining a Relation

```python
# Relation R on set {1, 2, 3, 4}
# (a, b) means "a is related to b"
R = {(1, 1), (1, 2), (2, 2), (3, 3), (4, 4), (2, 3)}
domain = {1, 2, 3, 4}
```

---

### âœ… Relation Properties

#### Reflexive

```python
print(is_reflexive(R, domain))  # True
```

ğŸ“Œ Every element relates to itself
**Example:** â€œEvery person knows themselvesâ€

---

#### Symmetric

```python
print(is_symmetric(R))  # False
```

ğŸ“Œ If `a â†’ b`, then `b â†’ a`
**Example:** Friendship (symmetric), Twitter follow (not symmetric)

---

#### Antisymmetric

```python
print(is_antisymmetric(R))  # True or False depending on R
```

ğŸ“Œ If `a â†’ b` and `b â†’ a`, then `a = b`
**Used in:** Partial orders (â‰¤)

---

#### Transitive

```python
print(is_transitive(R))  # False
```

ğŸ“Œ If `a â†’ b` and `b â†’ c`, then `a â†’ c`
**Example:** Ancestor relationships

---

### ğŸŸ° Special Relations

#### Equivalence Relation

```python
print(is_equivalence_relation(R, domain))
```

âœ” Reflexive
âœ” Symmetric
âœ” Transitive

ğŸ“Œ **Partitions a set into equivalence classes**

---

#### Partial Order

```python
partial_order = {(1,1), (2,2), (3,3), (1,2), (2,3), (1,3)}
print(is_partial_order(partial_order, {1, 2, 3}))  # True
```

ğŸ“Œ **Used in:** Task scheduling, version control systems

---

### ğŸ” Relation Closures

#### Reflexive Closure

```python
ref_closure = reflexive_closure(R, domain)
print(ref_closure)
```

Adds `(a, a)` for all `a âˆˆ domain`

---

#### Symmetric Closure

```python
sym_closure = symmetric_closure(R)
print(sym_closure)
```

Makes every relation bidirectional

---

#### Transitive Closure

```python
trans_closure = transitive_closure(R)
print(trans_closure)
```

Adds all **implied indirect relationships**

ğŸ“Œ Uses **Warshallâ€™s Algorithm**

---

### ğŸ§© Equivalence Classes

```python
R_eq = {(1,1), (2,2), (3,3), (1,2), (2,1)}
classes = equivalence_classes(R_eq, {1, 2, 3})
print(classes)  # [{1, 2}, {3}]
```

ğŸ“Œ **Only valid for equivalence relations**

---

### ğŸ”„ Relation Operations

#### Composition of Relations

```python
R1 = {(1, 2), (2, 3)}
R2 = {(0, 1), (1, 2)}
print(compose(R1, R2))  # {(0, 2), (1, 3)}
```

ğŸ“Œ Used in **function chaining and graph traversal**

---

#### Inverse Relation

```python
print(inverse_relation({(1, 2), (2, 3)}))
# {(2, 1), (3, 2)}
```

ğŸ“Œ Swaps direction of every pair

---

### ğŸ“¦ Domain & Range

```python
print(get_domain(R))  # {1, 2, 3, 4}
print(get_range(R))   # {1, 2, 3, 4}
```

ğŸ“Œ Helps analyze inputs and outputs of relations

---

### ğŸ§® Matrix Representation

```python
matrix = relation_matrix({(1, 2), (2, 3)}, {1, 2, 3})
for row in matrix:
    print(row)
```

**Output:**

```
[0, 1, 0]
[0, 0, 1]
[0, 0, 0]
```

ğŸ“Œ **Used in:** Graph theory, adjacency matrices, algorithms


Perfect â€” repeating **the exact same style, depth, and structure** as your previous modules.
Below is a **clean, complete, production-ready `README.md` section** for the **Functions Module**, fully aligned with your code and `__all__`.

You can **copy-paste this directly**.

---

## 7ï¸âƒ£ Functions Module â€“ Analyze Mappings

**What it does:**
Analyze mathematical functions, verify their properties (injective, surjective, bijective), perform composition, inversion, and convert between representations.

---

### ğŸ“ Real-World Use Case: Data Mapping & Transformations

```python
from discrete_math.functions import *
```

---

### ğŸ”— Defining a Function

Functions are represented as **sets of ordered pairs** or **Python dictionaries**.

```python
# Function as a dictionary
grades = {
    101: 'A',
    102: 'B',
    103: 'A',
    104: 'C',
    105: 'B'
}

domain = {101, 102, 103, 104, 105}
codomain = {'A', 'B', 'C', 'D', 'F'}

# Convert dictionary to function form
relation = dict_to_function(grades)
```

---

### âœ… Valid Function Check

```python
print(is_function(relation, domain))  # True
```

ğŸ“Œ Each domain element must map to **exactly one** output.

---

### ğŸ” Function Properties

#### Injective (One-to-One)

```python
print(is_injective(relation))  # False
```

ğŸ“Œ No two inputs share the same output
âŒ Here, multiple students received `'A'`

---

#### Surjective (Onto)

```python
print(is_surjective(relation, codomain))  # False
```

ğŸ“Œ Every element of codomain must be used
âŒ Grades `'D'` and `'F'` are unused

---

#### Bijective (One-to-One & Onto)

```python
print(is_bijective(relation, domain, codomain))  # False
```

ğŸ“Œ **Only bijective functions are invertible**

---

### ğŸ” Function Composition

```python
# f(x) = x + 1
f = {(1, 2), (2, 3), (3, 4)}

# g(x) = 2x
g = {(2, 4), (3, 6), (4, 8)}

# Composition: g âˆ˜ f
composition = compose_functions(g, f)
print(composition)  # {(1, 4), (2, 6), (3, 8)}
```

ğŸ“Œ Apply **f first**, then **g**

---

### ğŸ”„ Inverse Function

```python
bijection = {(1, 'a'), (2, 'b'), (3, 'c')}
inverse = inverse_function(bijection, {1, 2, 3}, {'a', 'b', 'c'})
print(inverse)  # {('a', 1), ('b', 2), ('c', 3)}
```

âš ï¸ Only works for **bijective functions**

---

### ğŸ§  Real-Life Mapping Example

```python
age_mapping = {
    'Alice': 25,
    'Bob': 30,
    'Charlie': 25,
    'David': 35
}

relation = dict_to_function(age_mapping)
print(is_injective(relation))  # False
```

ğŸ“Œ Two people share the same age â†’ not injective

---

### ğŸ“¦ Domain & Range

```python
print(get_domain(relation))
# {'Alice', 'Bob', 'Charlie', 'David'}

print(get_range(relation))
# {25, 30, 35}
```

ğŸ“Œ Helps analyze **inputs vs outputs**

---

### ğŸ” Representation Conversion

#### Function â†’ Dictionary

```python
print(function_to_dict({(1, 'a'), (2, 'b')}))
# {1: 'a', 2: 'b'}
```

#### Dictionary â†’ Function

```python
print(dict_to_function({1: 'x', 2: 'y'}))
# {(1, 'x'), (2, 'y')}
```

---

### âš™ï¸ Function Evaluation (Callable)

```python
square = lambda x: x * x
print(evaluate_function(square, 5))  # 25
```

ğŸ“Œ Works with **any Python callable**




---

## ğŸ› ï¸ Development & Contributing

### Want to Contribute? We'd Love Your Help!

This is an open-source project, and contributions are always welcome! Whether you're fixing bugs, adding features, or improving documentation - every contribution matters.

### Setup Your Development Environment

```bash
# Step 1: Fork and clone the repository
git clone https://github.com/CodewithTanzeel/pypi-package-dm.git
cd pypi-package-dm

# Step 2: Create a virtual environment
python -m venv venv

# Step 3: Activate it
# On Windows:
venv\Scripts\activate
# On macOS/Linux:
source venv/bin/activate

# Step 4: Install in development mode with all dev tools
pip install -e ".[dev]"
```

### Running Tests

Make sure everything works before submitting changes:

```bash
# Run all tests
pytest

# Run tests with coverage report (see which code is tested)
pytest --cov=discrete_math --cov-report=html

# Run a specific test file
pytest tests/test_logic.py

# Run tests in verbose mode (see each test individually)
pytest -v
```

### Code Quality Tools

Keep the codebase clean and consistent:

```bash
# Auto-format your code (makes it pretty!)
black src/

# Check for code style issues
flake8 src/

# Type checking (catch bugs early)
mypy src/
```

### How to Contribute

1. **Fork** the repository on GitHub
2. **Create a branch** for your feature: `git checkout -b feature/AmazingFeature`
3. **Make your changes** and add tests
4. **Run tests** to ensure nothing breaks: `pytest`
5. **Commit** your changes: `git commit -m 'Add some AmazingFeature'`
6. **Push** to your branch: `git push origin feature/AmazingFeature`
7. **Open a Pull Request** on GitHub

**For major changes, please open an issue first to discuss what you'd like to change!**

---

## ğŸ“– Common Use Cases & Recipes

### Recipe 1: Homework Helper - Verify Set Theory Answers

```python
from discrete_math import sets

# Your homework problem:
# Given A = {1,2,3,4,5} and B = {4,5,6,7}
# Find: A âˆª B, A âˆ© B, A - B, |P(A)|

A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7}

print(f"A âˆª B = {sets.union(A, B)}")  # {1,2,3,4,5,6,7}
print(f"A âˆ© B = {sets.intersection(A, B)}")  # {4,5}
print(f"A - B = {sets.difference(A, B)}")  # {1,2,3}
print(f"|P(A)| = {len(sets.power_set(A))}")  # 32 subsets
```

### Recipe 2: Password Strength Analyzer

```python
from discrete_math import combinatorics

def analyze_password_strength(length, use_lowercase=True, use_uppercase=True,
                              use_digits=True, use_special=True):
    """Calculate how many possible passwords exist."""
    charset_size = 0
    if use_lowercase: charset_size += 26  # a-z
    if use_uppercase: charset_size += 26  # A-Z
    if use_digits: charset_size += 10     # 0-9
    if use_special: charset_size += 32    # !@#$%^&*...
    
    total_combinations = charset_size ** length
    print(f"Password length: {length}")
    print(f"Character set size: {charset_size}")
    print(f"Total possible passwords: {total_combinations:,}")
    print(f"Entropy: {length * charset_size} bits")
    return total_combinations

# 8-character password with all character types
analyze_password_strength(8, True, True, True, True)
# Result: Over 6 quadrillion combinations!
```

### Recipe 3: Social Network Analysis

```python
from discrete_math.graphs import Graph

def analyze_social_network(friendships):
    """Analyze a social network graph."""
    network = Graph()
    
    # Build the network
    for person1, person2 in friendships:
        network.add_edge(person1, person2)
    
    # Analysis
    print(f"Total people: {len(network.vertices)}")
    print(f"Total friendships: {len(network.edges)}")
    print(f"Network is connected: {network.is_connected()}")
    
    # Find most central person (most connections)
    connections = {person: network.degree(person) for person in network.vertices}
    most_connected = max(connections, key=connections.get)
    print(f"Most connected person: {most_connected} ({connections[most_connected]} friends)")
    
    return network

friendships = [
    ('Alice', 'Bob'), ('Bob', 'Charlie'), ('Charlie', 'David'),
    ('Alice', 'David'), ('Eve', 'Alice')
]
analyze_social_network(friendships)
```

### Recipe 4: Class Scheduling Conflict Checker

```python
from discrete_math import sets

def check_schedule_conflicts(student_schedule):
    """Check if a student's schedule has time conflicts."""
    # Each course is (course_name, time_slot)
    time_slots = {}
    conflicts = []
    
    for course, time in student_schedule:
        if time in time_slots:
            conflicts.append((time_slots[time], course, time))
        else:
            time_slots[time] = course
    
    if conflicts:
        print("âš ï¸ Schedule conflicts found:")
        for course1, course2, time in conflicts:
            print(f"  {course1} and {course2} both at {time}")
    else:
        print("âœ… No conflicts! Schedule is valid.")
    
    return len(conflicts) == 0

schedule = [
    ('Math 101', 'Mon 9AM'),
    ('CS 201', 'Mon 11AM'),
    ('Physics 101', 'Mon 9AM'),  # Conflict!
    ('History 101', 'Tue 10AM')
]
check_schedule_conflicts(schedule)
```

### Recipe 5: Cryptography - Simple RSA Key Generation

```python
from discrete_math.number_theory import *

def generate_simple_rsa_keys(p, q):
    """Generate RSA public and private keys (simplified educational version)."""
    # Step 1: Calculate n
    n = p * q
    
    # Step 2: Calculate Euler's totient Ï†(n)
    phi_n = (p - 1) * (q - 1)
    
    # Step 3: Choose public exponent e (commonly 65537)
    e = 65537
    if gcd(e, phi_n) != 1:
        e = 3  # Fallback
    
    # Step 4: Calculate private exponent d
    d = mod_inverse(e, phi_n)
    
    print(f"Public Key: (e={e}, n={n})")
    print(f"Private Key: (d={d}, n={n})")
    print(f"Ï†(n) = {phi_n}")
    
    return (e, n), (d, n)

# Example with small primes (educational only!)
if is_prime(61) and is_prime(53):
    public_key, private_key = generate_simple_rsa_keys(61, 53)
    
    # Encrypt a message (m = 42)
    m = 42
    e, n = public_key
    encrypted = mod_exp(m, e, n)
    print(f"\nOriginal message: {m}")
    print(f"Encrypted: {encrypted}")
    
    # Decrypt
    d, n = private_key
    decrypted = mod_exp(encrypted, d, n)
    print(f"Decrypted: {decrypted}")
```

---

## â“ FAQ - Frequently Asked Questions

**Q: Do I need to know advanced math to use this library?**  
A: Not at all! The library is designed to help you *learn* discrete math. Start with the examples and experiment.

**Q: Can I use this for my homework?**  
A: Yes! It's a great tool to verify your answers and understand concepts. But make sure you understand *why* the answers are correct.

**Q: Is this suitable for production applications?**  
A: The library is educational-focused. For production cryptography, use established libraries like `cryptography` or `pycryptodome`.

**Q: How can I visualize graphs?**  
A: The library uses NetworkX under the hood. You can export graphs and use matplotlib for visualization.

**Q: What Python version do I need?**  
A: Python 3.8 or higher. Check with `python --version`.

**Q: The library is missing feature X. Can I request it?**  
A: Absolutely! Open an issue on GitHub with your feature request.

**Q: I found a bug. What should I do?**  
A: Please report it on [GitHub Issues](https://github.com/CodewithTanzeel/pypi-package-dm/issues) with:
- Python version
- Code that reproduces the bug
- Expected vs actual behavior

---

## ğŸ“š Learning Resources

**Want to dive deeper into Discrete Mathematics?**

### Recommended Books
- "Discrete Mathematics and Its Applications" by Kenneth Rosen
- "Concrete Mathematics" by Graham, Knuth, Patashnik
- "Introduction to Graph Theory" by Douglas West

### Online Courses
- MIT OpenCourseWare: Mathematics for Computer Science
- Coursera: Discrete Mathematics Specialization
- Khan Academy: Discrete Math Topics

### Practice Problems
- Use this library to verify your solutions
- Check out [Project Euler](https://projecteuler.net/) for challenging problems
- LeetCode has many discrete math algorithm problems

---

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

**What does this mean?**  
You can freely use, modify, and distribute this library, even for commercial purposes. Just include the original license.

---

## ğŸ‘¤ Author

**CodewithTanzeel**

- GitHub: [@CodewithTanzeel](https://github.com/CodewithTanzeel)
- Email: Tanzeelofficial@outlook.com

---

## ğŸ™ Acknowledgments

- **Students of MS-207 Discrete Mathematics** - This library was built with you in mind!
- **Open Source Community** - Built on amazing libraries like NumPy, SymPy, NetworkX, and Matplotlib
- **Educators worldwide** - For inspiring the need for better educational tools
- **Contributors** - Everyone who has helped improve this project

---

## ğŸ’¬ Support & Community

- **Questions?** Open a [GitHub Discussion](https://github.com/CodewithTanzeel/pypi-package-dm/discussions)
- **Found a bug?** File an [Issue](https://github.com/CodewithTanzeel/pypi-package-dm/issues)
- **Want to contribute?** Check out our [Contributing Guidelines](#-development--contributing)
- **Need help?** Reach out via email or GitHub

---

## ğŸ“Š Project Stats

![Python Version](https://img.shields.io/badge/python-3.8%2B-blue)
![License](https://img.shields.io/badge/license-MIT-green)
![Status](https://img.shields.io/badge/status-active-success)

---

## ğŸ—ºï¸ Roadmap

### Version 0.2.0 (Coming Soon)
- [ ] Interactive Jupyter Notebook examples
- [ ] Graph visualization helpers
- [ ] More number theory algorithms
- [ ] Performance optimizations
- [ ] Enhanced documentation

### Version 0.3.0 (Planned)
- [ ] CLI tool for quick calculations
- [ ] LaTeX output for formulas
- [ ] Step-by-step solution explanations
- [ ] More real-world examples

**Have ideas?** Share them in GitHub Issues!

---

## ğŸ“ Changelog

### Version 0.1.0 (Initial Release)
- âœ… Logic operations and truth tables
- âœ… Complete set theory operations
- âœ… Relations and properties
- âœ… Combinatorics functions
- âœ… Graph theory algorithms
- âœ… Number theory utilities
- âœ… Function analysis tools
- âœ… Comprehensive test suite (46 tests passing)
- âœ… Full documentation and examples

---

**Happy Computing! ğŸ‰**

*Remember: Discrete mathematics is everywhere - from computer science to cryptography, from scheduling to social networks. This library is your companion in exploring these fascinating concepts!*

---
