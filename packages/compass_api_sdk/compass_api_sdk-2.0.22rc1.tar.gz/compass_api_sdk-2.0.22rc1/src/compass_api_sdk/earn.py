"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from compass_api_sdk import errors, models, utils
from compass_api_sdk._hooks import HookContext
from compass_api_sdk.types import OptionalNullable, UNSET
from compass_api_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union


class Earn(BaseSDK):
    def earn_positions(
        self,
        *,
        chain: models.V2EarnPositionsChain,
        user_address: str,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        days: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnPositionsResponse:
        r"""List earn positions

        This endpoint fetches all Compass Earn positions.

        :param chain:
        :param user_address: The address of the user to get vault positions for.
        :param offset: The offset of the first item to return.
        :param limit: The number of items to return.
        :param days: How many days back from the current time to include in the blockchain scan.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnPositionsRequest(
            offset=offset,
            limit=limit,
            chain=chain,
            user_address=user_address,
            days=days,
        )

        req = self._build_request(
            method="GET",
            path="/v2/earn/positions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_positions",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnPositionsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_positions_async(
        self,
        *,
        chain: models.V2EarnPositionsChain,
        user_address: str,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        days: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnPositionsResponse:
        r"""List earn positions

        This endpoint fetches all Compass Earn positions.

        :param chain:
        :param user_address: The address of the user to get vault positions for.
        :param offset: The offset of the first item to return.
        :param limit: The number of items to return.
        :param days: How many days back from the current time to include in the blockchain scan.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnPositionsRequest(
            offset=offset,
            limit=limit,
            chain=chain,
            user_address=user_address,
            days=days,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/earn/positions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_positions",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnPositionsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_vaults(
        self,
        *,
        order_by: str,
        direction: Optional[models.Direction] = None,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        chain: OptionalNullable[models.Chain] = UNSET,
        asset_symbol: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.VaultsResponse:
        r"""List vaults

        List information about 4626 vaults.

        These are earn opportunities for protocols like morpho.

        :param order_by: The field to order the results by.
        :param direction: The direction to order the results by.
        :param offset: The offset of the first item to return.
        :param limit: The number of items to return.
        :param chain: Optional chain filter. If not provided, returns vaults for all chains.
        :param asset_symbol: Filter vaults by underlying asset symbol (e.g., 'USDC', 'WETH').
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnVaultsRequest(
            order_by=order_by,
            direction=direction,
            offset=offset,
            limit=limit,
            chain=chain,
            asset_symbol=asset_symbol,
        )

        req = self._build_request(
            method="GET",
            path="/v2/earn/vaults",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_vaults",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.VaultsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_vaults_async(
        self,
        *,
        order_by: str,
        direction: Optional[models.Direction] = None,
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        chain: OptionalNullable[models.Chain] = UNSET,
        asset_symbol: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.VaultsResponse:
        r"""List vaults

        List information about 4626 vaults.

        These are earn opportunities for protocols like morpho.

        :param order_by: The field to order the results by.
        :param direction: The direction to order the results by.
        :param offset: The offset of the first item to return.
        :param limit: The number of items to return.
        :param chain: Optional chain filter. If not provided, returns vaults for all chains.
        :param asset_symbol: Filter vaults by underlying asset symbol (e.g., 'USDC', 'WETH').
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnVaultsRequest(
            order_by=order_by,
            direction=direction,
            offset=offset,
            limit=limit,
            chain=chain,
            asset_symbol=asset_symbol,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/earn/vaults",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_vaults",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.VaultsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_aave_markets(
        self,
        *,
        chain: OptionalNullable[models.Chain] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAaveMarketsResponse:
        r"""List aave markets

        List all aave markets with their supply and borrow rates.

        Returns rates organized by token symbol, with chain-specific data for each token.
        Each token includes rates for all chains where it's available, plus information
        about which chain offers the highest supply APY.

        APY values are returned in percentage format (e.g., 4.5 means 4.5%). Tokens with
        zero APY on both supply and borrow are excluded.

        Optionally filter by chain.

        :param chain: Optional chain filter. If not provided, returns rates for all chains.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnAaveMarketsRequest(
            chain=chain,
        )

        req = self._build_request(
            method="GET",
            path="/v2/earn/aave_markets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_aave_markets",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListAaveMarketsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_aave_markets_async(
        self,
        *,
        chain: OptionalNullable[models.Chain] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAaveMarketsResponse:
        r"""List aave markets

        List all aave markets with their supply and borrow rates.

        Returns rates organized by token symbol, with chain-specific data for each token.
        Each token includes rates for all chains where it's available, plus information
        about which chain offers the highest supply APY.

        APY values are returned in percentage format (e.g., 4.5 means 4.5%). Tokens with
        zero APY on both supply and borrow are excluded.

        Optionally filter by chain.

        :param chain: Optional chain filter. If not provided, returns rates for all chains.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2EarnAaveMarketsRequest(
            chain=chain,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/earn/aave_markets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_aave_markets",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ListAaveMarketsResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_create_account(
        self,
        *,
        chain: models.CreateAccountRequestChain,
        sender: str,
        owner: str,
        estimate_gas: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateAccountResponse:
        r"""Create earn account

        Create an Earn Account.

        Before creating Earn positions, the `owner` must create an Earn Account associated with their wallet address.

        Only the `owner` has the authority to sign transactions for this account. This can be done in one of two ways:

        1) **No gas-sponsorship:** The `owner` signs a transaction and submits it to the network for execution. The `owner` covers the cost of gas in this case.

        2) **Gas-sponsorship:** The `owner` does an off-chain EIP-712 signature and submits this signature to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`). Here, another wallet address is set as `sender`. This wallet will sign, submit and cover the gas fees of the transaction.

        The creation of an Earn Account itself can be a gas-sponsored transaction by setting the `sender` to the wallet which will sign and send the transaction.

        :param chain:
        :param sender: The address of the transaction sender.
        :param owner: The address that will own and control the compass account
        :param estimate_gas: Determines whether to estimate gas costs for transactions, also verifying that the transaction can be successfully executed.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAccountRequest(
            chain=chain,
            sender=sender,
            estimate_gas=estimate_gas,
            owner=owner,
        )

        req = self._build_request(
            method="POST",
            path="/v2/earn/create_account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAccountRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_create_account",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreateAccountResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_create_account_async(
        self,
        *,
        chain: models.CreateAccountRequestChain,
        sender: str,
        owner: str,
        estimate_gas: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateAccountResponse:
        r"""Create earn account

        Create an Earn Account.

        Before creating Earn positions, the `owner` must create an Earn Account associated with their wallet address.

        Only the `owner` has the authority to sign transactions for this account. This can be done in one of two ways:

        1) **No gas-sponsorship:** The `owner` signs a transaction and submits it to the network for execution. The `owner` covers the cost of gas in this case.

        2) **Gas-sponsorship:** The `owner` does an off-chain EIP-712 signature and submits this signature to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`). Here, another wallet address is set as `sender`. This wallet will sign, submit and cover the gas fees of the transaction.

        The creation of an Earn Account itself can be a gas-sponsored transaction by setting the `sender` to the wallet which will sign and send the transaction.

        :param chain:
        :param sender: The address of the transaction sender.
        :param owner: The address that will own and control the compass account
        :param estimate_gas: Determines whether to estimate gas costs for transactions, also verifying that the transaction can be successfully executed.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAccountRequest(
            chain=chain,
            sender=sender,
            estimate_gas=estimate_gas,
            owner=owner,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/earn/create_account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAccountRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_create_account",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.CreateAccountResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_transfer(
        self,
        *,
        owner: str,
        chain: models.Chain,
        token: str,
        amount: Union[
            models.EarnTransferRequestAmount, models.EarnTransferRequestAmountTypedDict
        ],
        action: models.EarnTransferRequestAction,
        gas_sponsorship: Optional[bool] = None,
        spender: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnTransferResponse:
        r"""Transfer tokens to/from account

        Transfer tokens to and from an Earn Account.

        If `DEPOSIT`'` is selected, tokens will be transferred from the `owner`'s wallet into their Earn Account.

        If `WITHDRAW` is selected, tokens will be transferred from the `owner`'s Earn Account into their wallet.

        If a gas-sponsored `DEPOSIT` transfer is desired for a given token, a one-time Permit2 allowance must be set before proceeding. This is common practice for many other applications and, for many `owner`s, this one-time allowance will already have been set for the token they would like to transfer.
        Once the one-time allowance is set for a given token and `gas_sponsorship` is set to 'true', EIP-712 typed data will be returned and can be signed off-chain by the user. This signature can then be submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`) where a `sender` can be set for the transaction.

        :param owner: The owner's wallet address.
        :param chain: The chain to use.
        :param token: The token you would like to transfer.
        :param amount: The amount of 'token' to transfer.
        :param action: Whether you are depositing to or withdrawing from your earn account.
        :param gas_sponsorship: Optionally request gas sponsorship. If set to `true`, EIP-712 signature data will be returned that must be signed by the `owner` and submitted to the `/gas_sponsorship/prepare` endpoint.
        :param spender: The address of the wallet which will send the transaction. This only needs to be set when `action` is 'DEPOSIT' and `gas_sponsorship` is `true`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnTransferRequest(
            owner=owner,
            chain=chain,
            token=token,
            amount=amount,
            action=action,
            gas_sponsorship=gas_sponsorship,
            spender=spender,
        )

        req = self._build_request(
            method="POST",
            path="/v2/earn/transfer",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnTransferRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_transfer",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnTransferResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_transfer_async(
        self,
        *,
        owner: str,
        chain: models.Chain,
        token: str,
        amount: Union[
            models.EarnTransferRequestAmount, models.EarnTransferRequestAmountTypedDict
        ],
        action: models.EarnTransferRequestAction,
        gas_sponsorship: Optional[bool] = None,
        spender: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnTransferResponse:
        r"""Transfer tokens to/from account

        Transfer tokens to and from an Earn Account.

        If `DEPOSIT`'` is selected, tokens will be transferred from the `owner`'s wallet into their Earn Account.

        If `WITHDRAW` is selected, tokens will be transferred from the `owner`'s Earn Account into their wallet.

        If a gas-sponsored `DEPOSIT` transfer is desired for a given token, a one-time Permit2 allowance must be set before proceeding. This is common practice for many other applications and, for many `owner`s, this one-time allowance will already have been set for the token they would like to transfer.
        Once the one-time allowance is set for a given token and `gas_sponsorship` is set to 'true', EIP-712 typed data will be returned and can be signed off-chain by the user. This signature can then be submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`) where a `sender` can be set for the transaction.

        :param owner: The owner's wallet address.
        :param chain: The chain to use.
        :param token: The token you would like to transfer.
        :param amount: The amount of 'token' to transfer.
        :param action: Whether you are depositing to or withdrawing from your earn account.
        :param gas_sponsorship: Optionally request gas sponsorship. If set to `true`, EIP-712 signature data will be returned that must be signed by the `owner` and submitted to the `/gas_sponsorship/prepare` endpoint.
        :param spender: The address of the wallet which will send the transaction. This only needs to be set when `action` is 'DEPOSIT' and `gas_sponsorship` is `true`.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnTransferRequest(
            owner=owner,
            chain=chain,
            token=token,
            amount=amount,
            action=action,
            gas_sponsorship=gas_sponsorship,
            spender=spender,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/earn/transfer",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnTransferRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_transfer",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnTransferResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_manage(
        self,
        *,
        venue: Union[
            models.EarnManageRequestVenue, models.EarnManageRequestVenueTypedDict
        ],
        action: models.EarnManageRequestAction,
        amount: Any,
        owner: str,
        chain: models.Chain,
        gas_sponsorship: Optional[bool] = None,
        fee: OptionalNullable[Union[models.Fee, models.FeeTypedDict]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnManageResponse:
        r"""Manage earn position

        Manage an Earn position for a given `owner`'s Earn Account.

        The `owner` is the main wallet address that owns and controls the Earn Account. It is not the Earn Account address itself.

        Venue Types:
        - VAULTS
        - AAVE

        If `DEPOSIT` is selected for `action`, tokens will be deposited into the selected venue address from the Earn Account associated with the  `owner` wallet.

        If `WITHDRAW` is selected for `action`, tokens will be withdrawn from the selected venue address back into the Earn Account associated with the `owner` wallet.

        A fee can be configured. This fee is deducted from the total `amount`. It can be expressed as a `FIXED` amount or a `PERCENTAGE` of `amount`.

        The transaction can be gas-sponsored by an arbitrary wallet address which will sign, submit and pay the required gas for the transaction. If `gas_sponsorship` is set to `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`) where the `sender` of the transaction can be set.

        :param venue: The earn venue.
        :param action: Whether you are depositing into or withdrawing from the given Earn `venue`.
        :param amount: Amount of the underlying asset to act on (deposit or withdraw). For VAULT, this is the vault's underlying token; for AAVE, this is the Aave reserve asset. Provide as a decimal in token units (not wei); must be > 0.
        :param owner: The primary wallet address that owns and controls the Earn Account.
        :param chain: The chain to use.
        :param gas_sponsorship: Optionally request gas sponsorship. If set to `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`).
        :param fee: Optional fee configuration. If provided, a fee will be applied to the transaction amount and sent to the specified recipient address. The fee can be specified as a percentage of the transaction amount or as a fixed token amount.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnManageRequest(
            venue=utils.get_pydantic_model(venue, models.EarnManageRequestVenue),
            action=action,
            amount=amount,
            owner=owner,
            chain=chain,
            gas_sponsorship=gas_sponsorship,
            fee=utils.get_pydantic_model(fee, OptionalNullable[models.Fee]),
        )

        req = self._build_request(
            method="POST",
            path="/v2/earn/manage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnManageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_manage",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnManageResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_manage_async(
        self,
        *,
        venue: Union[
            models.EarnManageRequestVenue, models.EarnManageRequestVenueTypedDict
        ],
        action: models.EarnManageRequestAction,
        amount: Any,
        owner: str,
        chain: models.Chain,
        gas_sponsorship: Optional[bool] = None,
        fee: OptionalNullable[Union[models.Fee, models.FeeTypedDict]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnManageResponse:
        r"""Manage earn position

        Manage an Earn position for a given `owner`'s Earn Account.

        The `owner` is the main wallet address that owns and controls the Earn Account. It is not the Earn Account address itself.

        Venue Types:
        - VAULTS
        - AAVE

        If `DEPOSIT` is selected for `action`, tokens will be deposited into the selected venue address from the Earn Account associated with the  `owner` wallet.

        If `WITHDRAW` is selected for `action`, tokens will be withdrawn from the selected venue address back into the Earn Account associated with the `owner` wallet.

        A fee can be configured. This fee is deducted from the total `amount`. It can be expressed as a `FIXED` amount or a `PERCENTAGE` of `amount`.

        The transaction can be gas-sponsored by an arbitrary wallet address which will sign, submit and pay the required gas for the transaction. If `gas_sponsorship` is set to `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`) where the `sender` of the transaction can be set.

        :param venue: The earn venue.
        :param action: Whether you are depositing into or withdrawing from the given Earn `venue`.
        :param amount: Amount of the underlying asset to act on (deposit or withdraw). For VAULT, this is the vault's underlying token; for AAVE, this is the Aave reserve asset. Provide as a decimal in token units (not wei); must be > 0.
        :param owner: The primary wallet address that owns and controls the Earn Account.
        :param chain: The chain to use.
        :param gas_sponsorship: Optionally request gas sponsorship. If set to `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`).
        :param fee: Optional fee configuration. If provided, a fee will be applied to the transaction amount and sent to the specified recipient address. The fee can be specified as a percentage of the transaction amount or as a fixed token amount.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnManageRequest(
            venue=utils.get_pydantic_model(venue, models.EarnManageRequestVenue),
            action=action,
            amount=amount,
            owner=owner,
            chain=chain,
            gas_sponsorship=gas_sponsorship,
            fee=utils.get_pydantic_model(fee, OptionalNullable[models.Fee]),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/earn/manage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnManageRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_manage",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnManageResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_swap(
        self,
        *,
        token_in: str,
        token_out: str,
        amount_in: Union[
            models.EarnSwapRequestAmountIn, models.EarnSwapRequestAmountInTypedDict
        ],
        owner: str,
        chain: models.Chain,
        slippage: Optional[
            Union[
                models.EarnSwapRequestSlippage, models.EarnSwapRequestSlippageTypedDict
            ]
        ] = None,
        gas_sponsorship: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnSwapResponse:
        r"""Swap tokens within Earn Account

        Swap tokens within an Earn Account.

        :param token_in: Token to sell (input). Provide a token symbol from a limited set (e.g., 'USDC') or any token address.
        :param token_out: Token to buy (output). Provide a token symbol from a limited set (e.g., 'USDT') or any token address.
        :param amount_in: Human-readable amount of `token_in` to swap (token units, not wei).
        :param owner: The owner's wallet address.
        :param chain: The chain to use.
        :param slippage: Maximum slippage tolerance as a percentage (e.g., 0.5 = 0.5%).
        :param gas_sponsorship: Optionally request gas sponsorship. If `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnSwapRequest(
            token_in=token_in,
            token_out=token_out,
            amount_in=amount_in,
            slippage=slippage,
            owner=owner,
            chain=chain,
            gas_sponsorship=gas_sponsorship,
        )

        req = self._build_request(
            method="POST",
            path="/v2/earn/swap",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnSwapRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_swap",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnSwapResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_swap_async(
        self,
        *,
        token_in: str,
        token_out: str,
        amount_in: Union[
            models.EarnSwapRequestAmountIn, models.EarnSwapRequestAmountInTypedDict
        ],
        owner: str,
        chain: models.Chain,
        slippage: Optional[
            Union[
                models.EarnSwapRequestSlippage, models.EarnSwapRequestSlippageTypedDict
            ]
        ] = None,
        gas_sponsorship: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EarnSwapResponse:
        r"""Swap tokens within Earn Account

        Swap tokens within an Earn Account.

        :param token_in: Token to sell (input). Provide a token symbol from a limited set (e.g., 'USDC') or any token address.
        :param token_out: Token to buy (output). Provide a token symbol from a limited set (e.g., 'USDT') or any token address.
        :param amount_in: Human-readable amount of `token_in` to swap (token units, not wei).
        :param owner: The owner's wallet address.
        :param chain: The chain to use.
        :param slippage: Maximum slippage tolerance as a percentage (e.g., 0.5 = 0.5%).
        :param gas_sponsorship: Optionally request gas sponsorship. If `true`, EIP-712 typed data will be returned that must be signed by the `owner` and submitted to the 'Prepare gas-sponsored transaction' endpoint (`/gas_sponsorship/prepare`).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EarnSwapRequest(
            token_in=token_in,
            token_out=token_out,
            amount_in=amount_in,
            slippage=slippage,
            owner=owner,
            chain=chain,
            gas_sponsorship=gas_sponsorship,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/earn/swap",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.EarnSwapRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_swap",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EarnSwapResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    def earn_bundle(
        self,
        *,
        owner: str,
        chain: models.Chain,
        actions: Union[
            List[models.V2UserOperation], List[models.V2UserOperationTypedDict]
        ],
        gas_sponsorship: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V2BundleResponse:
        r"""Execute multiple earn actions

        This endpoint allows combining multiple actions (swaps, vault
        deposits/withdrawals, Aave deposits/withdrawals) into a single atomic transaction
        executed via the Earn account).

        **Example Use Case:** Swap USDC to AUSD, then deposit AUSD into a vault - all in one transaction.

        Actions are executed in the order they are provided. Each action type has its own parameters:

        - **V2_SWAP**: Swapping tokens within the Earn Account
        - **V2_MANAGE**: Manage positions - deposit/withdraw to ERC-4626 vaults or Aave lending pool

        The bundled transaction can be gas-sponsored by setting `gas_sponsorship=true`.
        This returns EIP-712 typed data that the owner must sign and submit to
        `/gas_sponsorship/prepare` for execution by a gas sponsor.

        :param owner: The owner's wallet address that controls the Earn Account.
        :param chain: The chain to use.
        :param actions: List of actions to bundle. Actions are executed in order.
        :param gas_sponsorship: If true, returns EIP-712 typed data for gas sponsorship. The owner must sign this data and submit to /gas_sponsorship/prepare.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2BundleRequest(
            owner=owner,
            chain=chain,
            actions=utils.get_pydantic_model(actions, List[models.V2UserOperation]),
            gas_sponsorship=gas_sponsorship,
        )

        req = self._build_request(
            method="POST",
            path="/v2/earn/bundle",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.V2BundleRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_bundle",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.V2BundleResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)

    async def earn_bundle_async(
        self,
        *,
        owner: str,
        chain: models.Chain,
        actions: Union[
            List[models.V2UserOperation], List[models.V2UserOperationTypedDict]
        ],
        gas_sponsorship: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V2BundleResponse:
        r"""Execute multiple earn actions

        This endpoint allows combining multiple actions (swaps, vault
        deposits/withdrawals, Aave deposits/withdrawals) into a single atomic transaction
        executed via the Earn account).

        **Example Use Case:** Swap USDC to AUSD, then deposit AUSD into a vault - all in one transaction.

        Actions are executed in the order they are provided. Each action type has its own parameters:

        - **V2_SWAP**: Swapping tokens within the Earn Account
        - **V2_MANAGE**: Manage positions - deposit/withdraw to ERC-4626 vaults or Aave lending pool

        The bundled transaction can be gas-sponsored by setting `gas_sponsorship=true`.
        This returns EIP-712 typed data that the owner must sign and submit to
        `/gas_sponsorship/prepare` for execution by a gas sponsor.

        :param owner: The owner's wallet address that controls the Earn Account.
        :param chain: The chain to use.
        :param actions: List of actions to bundle. Actions are executed in order.
        :param gas_sponsorship: If true, returns EIP-712 typed data for gas sponsorship. The owner must sign this data and submit to /gas_sponsorship/prepare.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.V2BundleRequest(
            owner=owner,
            chain=chain,
            actions=utils.get_pydantic_model(actions, List[models.V2UserOperation]),
            gas_sponsorship=gas_sponsorship,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/earn/bundle",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.V2BundleRequest
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="v2_earn_bundle",
                oauth2_scopes=None,
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.V2BundleResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)

        raise errors.APIError("Unexpected response received", http_res)
