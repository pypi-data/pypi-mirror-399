# Author: Cameron F. Abrams, <cfa22@drexel.edu>
import yaml
import os
from collections import UserList
import pandas as pd
import logging

logger = logging.getLogger(__name__)

class AnswerSet:
    _keys = ['label', 'value', 'units', 'formatter']
    def __init__(self, serial: int = 0):
        self.serial = serial
        self.dumpname = f'answers-{serial:08d}.yaml'
        self.D = {}
        self.first_index = None

    def __len__(self):
        return len(self.D)

    @classmethod
    def from_yaml(cls, filename, delete=False):
        """
        Create an AnswerSet instance by loading from a YAML file of the same format as that 
        generated by the to_yaml() method.
        """
        root, ext = os.path.splitext(filename)
        assert ext in ['.yaml', '.yml'], f'{filename} does not end in .yaml or .yml'
        tokens = root.split('-')
        assert len(tokens) == 2, f'{filename} should be of the format "answers-<serial#>.yaml"'
        serial = int(tokens[1])
        R = cls(serial)
        with open(filename, 'r') as f:
            R.D = yaml.safe_load(f)
        if delete:
            os.remove(filename)
        return R
    
    def register(self, index, label=None, value=None, units=None, formatter=None, group=None):
        """
        Register an answer entry for a particular question index.
        """
        if not self.first_index:
            self.first_index = index
        if not index in self.D:
            self.D[index] = []
        # if value is a numpy data type, convert to native python type
        if hasattr(value, 'item'):
            value = value.item()
        self.D[index].append(dict(  label=label,
                                    value=value,
                                    units=units,
                                    formatter=formatter,
                                    group=group))
        logger.debug(f'AnswerSet.register index={index} label={label} value={value} units={units} formatter={formatter} group={group}')
    
    def display(self, index, element=0):
        D = None
        if element < len(self.D[index]):
            D = self.D[index][element]
        if D:
            fmt = D.get('formatter',None)
            val = D.get('value',None)
            label = D.get('label',None)
            units = D.get('units',None)
            vstr = ''
            if val:
                if fmt:
                    vstr = fmt.format(val)
                else:
                    vstr = str(val)
                if units:
                    vstr += f' {units}'
            if label:
                if vstr:
                    return f'{label} = {vstr}'
                else:
                    return label
        return ''

    def to_yaml(self):
        # check all indices for common bytes at the start, and remove them
        raw_indices = list(self.D.keys())
        common_prefix = os.path.commonprefix([str(x) for x in raw_indices])
        logger.debug(f'AnswerSet.to_yaml common prefix: "{common_prefix}"')
        if common_prefix:
            new_D = {}
            for index, AL in self.D.items():
                new_index = str(index)[len(common_prefix):]
                new_D[new_index] = AL
            self.D = new_D
        with open(self.dumpname, 'w') as f:
            yaml.safe_dump(self.D, f)

class AnswerSuperSet(UserList):

    def __init__(self, initial: list[AnswerSet] = None):
        self.data: list[AnswerSet] = initial if initial is not None else []
        super().__init__(self.data)
        if not self._check_congruency():
            print(f'Error: There is a lack of congruency among answer sets')
        self._make_dfs()

    @classmethod
    def from_dumpfiles(cls, files=[], delete=False):
        data=[]
        for f in files:
            data.append(AnswerSet.from_yaml(f, delete=delete))
        return cls(initial=data)

    def to_latex(self):
        result = ''
        for group_name, group_data in self.groups.items():
            df = group_data['df']
            formatters = group_data.get('formatters', None)
            logger.debug(f'AnswerSuperSet.to_latex group "{group_name}" with formatters: {formatters}')
            result += df.to_latex(formatters=formatters, index=False, longtable=True)#,header=self.headings)
        return result
    
    def _check_congruency(self):
        if len(self)>0:
            indices=list(self.data[0].D.keys())
            for l in self.data[1:]:
                test_indices=list(l.D.keys())
                check=all([x==y for x,y in zip(indices,test_indices)])
                if not check:
                    return False
            for i in indices:
                ilen=len(self.data[0].D[i])
                for l in self.data[1:]:
                    test_ilen=len(l.D[i])
                    check=ilen==test_ilen
                    if not check:
                        return False
        return True
    
    def _make_dfs(self):
        # to do: groupify
        serials = [x.serial for x in self.data]
        # logger.debug(serials)
        # self.headings = ['serials']
        # keys = ['serials']
        values = {'serials': serials}
        pattern = self.data[0]  # keys in first AnswerSet form the pattern all sets follow
        self.formatters = {}
        self.groups = {}
        # keys in D may be prepended with a common prefix; remove it
        common_prefix = os.path.commonprefix([str(x) for x in pattern.D.keys()])
        logger.debug(f'Overall common prefix: "{common_prefix}"')
        for dataset in self.data:
            new_dataset_D = {}
            for index in dataset.D.keys():
                new_index = str(index)[len(common_prefix):]
                new_dataset_D[new_index] = dataset.D[index]
            dataset.D = new_dataset_D
        for index, AL in pattern.D.items():
            index_pref = f'{index}-'
            if len(serials) == 1:
                index_pref = ''
            for a in AL:
                key = f'{index_pref}{a["label"]}'
                if 'units' in a and a['units']:
                    key += f' ({a["units"]})'
                group = a.get('group', None)
                if group:
                    if group not in self.groups:
                        self.groups[group] = dict(formatters={}, df=None, values={'serials': serials})
                    self.groups[group]['values'][key] = []
                    if 'formatter' in a:
                        self.groups[group]['formatters'][key] = a['formatter']
                else:
                    values[key] = []
                    if 'formatter' in a:
                        self.formatters[key] = a['formatter']
        # logger.debug(values)
        for inst in self.data:
            for index, AL in inst.D.items():
                index_pref = f'{index}-'
                if len(serials) == 1:
                    index_pref = ''
                for a in AL:
                    key = f'{index_pref}{a["label"]}'
                    if 'units' in a and a['units']:
                        key += f' ({a["units"]})'
                    group = a.get('group', None)
                    if group:
                        self.groups[group]['values'][key].append(a['value'])
                    else:
                        values[key].append(a['value'])
        # logger.debug(values)
        if not self.groups:
            DF = pd.DataFrame(values)
            DF.sort_values(by='serials', inplace=True)
            self.groups['base'] = dict(formatters=self.formatters, df=DF)
        else:
            for gname, gdata in self.groups.items():
                logger.debug(f'Building DataFrame for group {gname} with values: {gdata["values"]}')
                DF = pd.DataFrame(gdata['values'])
                DF.sort_values(by='serials', inplace=True)
                self.groups[gname]['df'] = DF
        # print(self.DF)


