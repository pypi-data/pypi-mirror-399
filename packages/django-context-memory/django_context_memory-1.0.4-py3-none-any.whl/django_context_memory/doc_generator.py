"""
Auto-generation of project-specific documentation and policies
"""

from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional
from .config import Config
from .scanner import ProjectScanner


class DocumentationGenerator:
    """Generates project-specific documentation"""

    def __init__(self, project_root: Path, config: Optional[Config] = None):
        """
        Initialize documentation generator

        Args:
            project_root: Path to Django project root
            config: Optional configuration object
        """
        self.project_root = Path(project_root)
        self.config = config or Config(project_root)
        self.scanner = ProjectScanner(project_root, self.config)

    def generate_all(self):
        """Generate all documentation"""
        self.generate_project_readme()
        self.generate_claude_policy()

    def generate_project_readme(self) -> Path:
        """
        Generate project-specific README for context memory

        Returns:
            Path to generated README file
        """
        project_info = self.scanner.get_project_info()
        apps = self.scanner.discover_apps()

        readme_content = f"""# {project_info['name']} - Context Memory

This directory contains AI-readable context generated by Django Context Memory.

## Project Information

- **Project**: {project_info['name']}
- **Root**: {project_info['root']}
- **Django Version**: {project_info.get('django_version', 'Unknown')}
- **Apps**: {project_info['apps_count']}

## Apps Included

{self._format_app_list(apps)}

## Context Files

### For AI Assistants

- **`claude_aggregated_context.json`** - Primary file for Claude Code
  - Contains complete project intelligence
  - All models, views, URLs, and dependencies
  - Cross-app relationships
  - Technology stack

### Per-App Context

Each app has its own directory with:
- `snapshot.json` - Raw scan data with deep code analysis
- `app_memory.json` - Versioned context (previous + latest)
- `claude_context.json` - Machine-readable context

## Last Updated

Generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC

## Maintenance

To rebuild context:
```bash
django-context scan-all
django-context build-all
```

To check status:
```bash
django-context status
```

## Documentation

For more information about Django Context Memory:
- https://github.com/yourusername/django-context-memory
- Run: `django-context --help`

---

*Generated automatically by Django Context Memory*
"""

        readme_path = self.config.memory_dir / "README.md"
        with open(readme_path, 'w') as f:
            f.write(readme_content)

        return readme_path

    def generate_claude_policy(self) -> Path:
        """
        Generate Claude-specific policy file for the project

        Returns:
            Path to generated policy file
        """
        project_info = self.scanner.get_project_info()
        apps = self.scanner.discover_apps()

        policy_content = f"""# Claude Code Policy — {project_info['name']}

This policy is **mandatory** for all AI assistants working on this project.

---

## Context Authority & Source of Truth

* Claude **MUST read and rely on** `.app_memory/claude_aggregated_context.json` as the **PRIMARY AUTHORITY** for project structure.

* This file contains:
  - All Django models with fields, types, and relationships
  - All views (function-based and class-based)
  - All URL patterns and routing
  - All forms and serializers
  - Cross-app dependencies and imports
  - Complete technology stack
  - Per-app code intelligence

* **MANDATORY**: Before ANY coding work, Claude MUST:
  1. Read `.app_memory/claude_aggregated_context.json`
  2. Check `generated_at` timestamp to ensure context is recent
  3. Review `apps_included` list to know which apps are tracked
  4. Identify what exists in the codebase

* If `.app_memory/claude_aggregated_context.json` is missing or stale (>7 days old):
  - **STOP immediately**
  - Inform user to run: `django-context build-all`
  - Do not proceed with assumptions

---

## Project Structure

**Project**: {project_info['name']}
**Apps**: {len(apps)}

{self._format_app_list_for_policy(apps)}

---

## Working with Context

### What the Context Contains

The aggregated context includes:

1. **Models** - All Django models with:
   - Field names and types
   - Field options (max_length, null, blank, etc.)
   - Relationships (ForeignKey, ManyToMany)
   - Custom methods

2. **Views** - All views with:
   - Function/class-based view types
   - Decorators
   - HTTP methods

3. **URLs** - All URL patterns with:
   - Route patterns
   - View mappings
   - URL names

4. **Forms & Serializers** - All forms with:
   - Form fields
   - Meta class configuration

5. **Dependencies** - All imports categorized:
   - Django components used
   - Third-party packages
   - Local app imports
   - Cross-app relationships

### How to Use Context

**Before modifying a model**:
```python
# Check the context to see existing fields
# Model: infrastructure.Server
# Fields: name, hostname, ssh_port, ssh_username, etc.
```

**Before adding a view**:
```python
# Check existing views and URL patterns
# Don't duplicate routes or view names
```

**Before importing from another app**:
```python
# Check cross_app_imports to see existing dependencies
# Follow established patterns
```

---

## Code Integrity Rules

* **DO NOT invent**:
  - Database fields not shown in context
  - Models not listed in context
  - Views or URL patterns not in context
  - Import paths not shown in dependencies

* **If schema is missing or ambiguous**:
  - Ask user for clarification
  - Stop and do not guess
  - Do not hallucinate field names or types

* **Always verify** against context:
  - Model field names (exact spelling)
  - ForeignKey relationships
  - URL pattern names
  - View function signatures

---

## Context Maintenance

### When to Rebuild Context

Rebuild context after:
- Adding/removing Django apps
- Creating/modifying models
- Adding new views or URL patterns
- Changing app dependencies

### How to Rebuild

```bash
# Rebuild everything
django-context scan-all
django-context build-all

# Rebuild single app
django-context scan <app_name>
django-context build <app_name>
```

### Checking Context Status

```bash
# See what's been built
django-context status
```

---

## Token Efficiency

* Context is pre-built and optimized
* Claude reads context **once** per session
* No need to scan files manually
* No need to grep or search
* All information is in the aggregated context

---

## Enforcement Checklist

Before responding to ANY coding request, verify:

* ✅ `.app_memory/claude_aggregated_context.json` was read
* ✅ Context timestamp was checked (must be recent)
* ✅ All referenced models exist in context
* ✅ All referenced fields match context exactly
* ✅ URL patterns don't conflict with existing routes
* ✅ Cross-app imports follow existing patterns
* ✅ No schema invented outside of context

**CRITICAL VIOLATIONS** (immediate stop required):
* Working without reading context first
* Inventing models or fields not in context
* Hallucinating database schema
* Ignoring context and guessing structure

---

## Project-Specific Notes

**Technology Stack** (based on context analysis):
- Django framework
- Apps: {', '.join([app['name'] for app in apps])}
- Context last generated: Check `claude_aggregated_context.json`

**Key Models** (verify in context):
- See `global_summary.all_models` in aggregated context

**URL Structure** (verify in context):
- See `global_summary.all_url_patterns` in aggregated context

---

Generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC
Auto-generated by Django Context Memory v1.0.0

This policy ensures Claude has accurate, up-to-date project knowledge.
"""

        policy_path = self.config.memory_dir / "CLAUDE_POLICY.md"
        with open(policy_path, 'w') as f:
            f.write(policy_content)

        return policy_path

    def _format_app_list(self, apps) -> str:
        """Format app list for README"""
        if not apps:
            return "(No apps discovered)"

        lines = []
        for app in apps:
            lines.append(f"- `{app['name']}`")
        return "\n".join(lines)

    def _format_app_list_for_policy(self, apps) -> str:
        """Format app list for policy"""
        if not apps:
            return "(No apps)"

        lines = []
        for i, app in enumerate(apps, 1):
            lines.append(f"{i}. **{app['name']}** - `{app['path']}`")
        return "\n".join(lines)
