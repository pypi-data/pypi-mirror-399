# generated by datamodel-codegen:
#   filename:  tmppd9h6l0s.json
#   timestamp: 2025-12-29T21:32:55+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from pydantic import AwareDatetime, BaseModel, Field, PositiveInt, RootModel, conint, constr


class GroupBy(Enum):
    model = 'model'
    customer_id = 'customer_id'
    event_type = 'event_type'
    provider = 'provider'


class Interval(Enum):
    hour = 'hour'
    day = 'day'
    week = 'week'


class CustomerUsageResponse(BaseModel):
    customerId: str = Field(..., description='Customer identifier')
    totalEvents: float = Field(..., description='Total number of events for this customer')
    totalTokens: float = Field(..., description='Total tokens consumed by this customer')
    totalInputTokens: float = Field(..., description='Total input tokens consumed')
    totalOutputTokens: float = Field(..., description='Total output tokens generated')
    totalCostCents: float = Field(..., description='Total cost in cents for this customer')


class ErrorResponse(BaseModel):
    error: str = Field(..., description='Error message describing what went wrong')


class Event(BaseModel):
    id: str = Field(..., description='Unique identifier for the event')
    customerId: str = Field(..., description='Customer identifier associated with the event')
    eventType: str = Field(..., description='Type of event that was recorded')
    model: str | None = Field(None, description='Model name used (if provided)')
    provider: str | None = Field(None, description='Provider name (if provided)')
    inputTokens: float | None = Field(None, description='Input tokens consumed (if provided)')
    outputTokens: float | None = Field(None, description='Output tokens generated (if provided)')
    totalTokens: float | None = Field(None, description='Total tokens for the event')
    latencyMs: float | None = Field(
        None, description='Request latency in milliseconds (if provided)'
    )
    costCents: float | None = Field(None, description='Cost in cents (if provided)')
    properties: dict[str, Any] = Field(
        ..., description='Custom properties/dimensions associated with the event'
    )
    createdAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the event was created'
    )


class EventsBatchPostResponse(BaseModel):
    count: float = Field(..., description='Number of events successfully ingested')


class EventsPostRequest(BaseModel):
    customerId: constr(min_length=1) = Field(
        ..., description="Your customer's identifier (e.g., user ID, tenant ID)"
    )
    eventType: constr(min_length=1) = Field(
        ..., description='Type of event (e.g., "model_call", "embedding", "tool_call")'
    )
    model: str | None = Field(
        None, description='Model used (e.g., "gpt-4", "claude-3-opus", "gpt-3.5-turbo")'
    )
    provider: str | None = Field(
        None, description='Provider name (e.g., "openai", "anthropic", "google")'
    )
    inputTokens: conint(ge=0) | None = Field(None, description='Number of input tokens consumed')
    outputTokens: conint(ge=0) | None = Field(None, description='Number of output tokens generated')
    totalTokens: conint(ge=0) | None = Field(
        None, description='Total tokens (auto-calculated if not provided)'
    )
    latencyMs: conint(ge=0) | None = Field(None, description='Request latency in milliseconds')
    costCents: conint(ge=0) | None = Field(None, description='Cost in cents (e.g., 25 = $0.25)')
    properties: dict[str, Any] | None = Field(
        None,
        description='Custom dimensions for filtering and grouping (e.g., user_id, team_id, feature)',
    )
    idempotencyKey: str | None = Field(
        None, description='Unique key for deduplication (prevents duplicate events)'
    )
    timestamp: AwareDatetime | None = Field(
        None, description='ISO 8601 timestamp (defaults to current time if not provided)'
    )


class EventsPostResponse(BaseModel):
    id: str = Field(..., description='Unique identifier for the ingested event')


class PaginationCursor(BaseModel):
    nextCursor: str = Field(
        ..., description='Cursor for the next page of results. Null if there are no more results.'
    )
    hasMore: bool = Field(..., description='Whether there are more results available')


class Project(BaseModel):
    id: str = Field(..., description='Unique identifier for the project')
    organizationId: str = Field(..., description='ID of the organization that owns this project')
    name: str = Field(..., description='Human-readable name of the project')
    slug: str = Field(..., description='URL-friendly identifier for the project')
    createdAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the project was created'
    )
    updatedAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the project was last updated'
    )


class Quota(BaseModel):
    id: str = Field(..., description='Unique identifier for the quota')
    projectId: str = Field(..., description='ID of the project that owns this quota')
    name: str = Field(..., description='Human-readable name for the quota')
    dimensionFilters: dict[str, Any] = Field(
        ...,
        description='Dimension filters that determine which events match this quota (e.g., {"customer_id": "cust_123", "model": "gpt-4"})',
    )
    metric: str = Field(
        ..., description='Metric being tracked (e.g., "total_tokens", "cost_cents", "total_events")'
    )
    limitValue: float = Field(..., description='Quota limit value')
    period: str = Field(..., description='Time period for the quota (e.g., "day", "month", "year")')
    createdAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the quota was created'
    )
    updatedAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the quota was last updated'
    )


class QuotaAlert(BaseModel):
    id: str
    quotaId: str
    threshold: float
    lastTriggeredAt: AwareDatetime | None = None
    createdAt: AwareDatetime
    updatedAt: AwareDatetime


class QuotaAlertLog(BaseModel):
    id: str
    quotaAlertId: str
    quotaId: str
    threshold: float
    currentUsage: float
    limitValue: float
    percentage: float
    webhookStatus: str
    webhookResponseCode: float
    triggeredAt: AwareDatetime


class QuotaAlertsDeleteResponse(BaseModel):
    success: bool = Field(..., description='Whether the alert was successfully deleted')


class QuotaAlertsPostRequest(BaseModel):
    threshold: conint(ge=1, le=100) = Field(
        ..., description='Threshold percentage (1-100) at which to trigger the alert'
    )


class QuotaAlertsPutRequest(BaseModel):
    threshold: conint(ge=1, le=100) | None = Field(
        None, description='Threshold percentage (1-100) at which to trigger the alert'
    )


class QuotasCheckRequest(RootModel[dict[str, Any]]):
    root: dict[str, Any]


class QuotasDeleteResponse(BaseModel):
    success: bool = Field(..., description='Whether the quota was successfully deleted')


class Metric(Enum):
    total_tokens = 'total_tokens'
    total_events = 'total_events'
    total_cost_cents = 'total_cost_cents'


class Period(Enum):
    hour = 'hour'
    day = 'day'
    week = 'week'
    month = 'month'


class QuotasPostRequest(BaseModel):
    name: constr(min_length=1) = Field(..., description='Human-readable name for the quota')
    dimensionFilters: dict[str, Any] | None = Field(
        {}, description='Dimension filters that determine which events match this quota'
    )
    metric: Metric = Field(..., description='Metric being tracked')
    limitValue: PositiveInt = Field(..., description='Quota limit value')
    period: Period = Field(..., description='Time period for the quota')


class QuotasPutRequest(BaseModel):
    name: constr(min_length=1) | None = Field(None, description='Human-readable name for the quota')
    dimensionFilters: dict[str, Any] | None = Field(
        None, description='Dimension filters that determine which events match this quota'
    )
    metric: Metric | None = Field(None, description='Metric being tracked')
    limitValue: PositiveInt | None = Field(None, description='Quota limit value')
    period: Period | None = Field(None, description='Time period for the quota')


class RateLimit(BaseModel):
    id: str = Field(..., description='Unique identifier for the rate limit')
    projectId: str = Field(..., description='ID of the project that owns this rate limit')
    name: str = Field(..., description='Human-readable name for the rate limit')
    dimensionFilters: dict[str, Any] = Field(
        ...,
        description='Dimension filters that determine which requests match this rate limit (e.g., {"customer_id": "cust_123"})',
    )
    limitValue: float = Field(
        ..., description='Maximum number of requests allowed in the time window'
    )
    window: str = Field(..., description='Time window for the rate limit (e.g., "1m", "1h", "1d")')
    enabled: bool = Field(..., description='Whether the rate limit is currently enabled')
    createdAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the rate limit was created'
    )
    updatedAt: AwareDatetime = Field(
        ..., description='ISO 8601 timestamp when the rate limit was last updated'
    )


class RateLimitsCheckRequest(RootModel[dict[str, Any]]):
    root: dict[str, Any]


class RateLimitsDeleteResponse(BaseModel):
    success: bool = Field(..., description='Whether the rate limit was successfully deleted')


class Window(Enum):
    second = 'second'
    minute = 'minute'
    hour = 'hour'


class RateLimitsPostRequest(BaseModel):
    name: constr(min_length=1) = Field(..., description='Human-readable name for the rate limit')
    dimensionFilters: dict[str, Any] | None = Field(
        {}, description='Dimension filters that determine which requests match this rate limit'
    )
    limitValue: PositiveInt = Field(
        ..., description='Maximum number of requests allowed in the time window'
    )
    window: Window = Field(..., description='Time window for the rate limit')
    enabled: bool | None = Field(True, description='Whether the rate limit is enabled')


class RateLimitsPutRequest(BaseModel):
    name: constr(min_length=1) | None = Field(
        None, description='Human-readable name for the rate limit'
    )
    dimensionFilters: dict[str, Any] | None = Field(
        None, description='Dimension filters that determine which requests match this rate limit'
    )
    limitValue: PositiveInt | None = Field(
        None, description='Maximum number of requests allowed in the time window'
    )
    window: Window | None = Field(None, description='Time window for the rate limit')
    enabled: bool | None = Field(None, description='Whether the rate limit is enabled')


class TrackPostRequest(BaseModel):
    customerId: constr(min_length=1) = Field(
        ..., description="Your customer's identifier (e.g., user ID, tenant ID)"
    )
    eventType: constr(min_length=1) = Field(
        ..., description='Type of event (e.g., "model_call", "embedding", "tool_call")'
    )
    model: str | None = Field(
        None, description='Model used (e.g., "gpt-4", "claude-3-opus", "gpt-3.5-turbo")'
    )
    provider: str | None = Field(
        None, description='Provider name (e.g., "openai", "anthropic", "google")'
    )
    inputTokens: conint(ge=0) | None = Field(None, description='Number of input tokens consumed')
    outputTokens: conint(ge=0) | None = Field(None, description='Number of output tokens generated')
    totalTokens: conint(ge=0) | None = Field(
        None, description='Total tokens (auto-calculated if not provided)'
    )
    latencyMs: conint(ge=0) | None = Field(None, description='Request latency in milliseconds')
    costCents: conint(ge=0) | None = Field(None, description='Cost in cents (e.g., 25 = $0.25)')
    properties: dict[str, Any] | None = Field(
        None,
        description='Custom dimensions for quota/rate limit matching (e.g., user_id, team_id, feature)',
    )
    idempotencyKey: str | None = Field(
        None, description='Unique key for deduplication (prevents duplicate events)'
    )
    timestamp: AwareDatetime | None = Field(
        None, description='ISO 8601 timestamp (defaults to current time if not provided)'
    )


class UsageSummary(BaseModel):
    totalEvents: float = Field(..., description='Total number of events in the time range')
    totalTokens: float = Field(..., description='Total tokens consumed across all events')
    totalInputTokens: float = Field(..., description='Total input tokens consumed')
    totalOutputTokens: float = Field(..., description='Total output tokens generated')
    totalCostCents: float = Field(..., description='Total cost in cents across all events')


class QuotaCheckResult(BaseModel):
    id: str = Field(..., description='Unique identifier for the quota')
    name: str = Field(..., description='Human-readable name of the quota')
    metric: str = Field(..., description='Metric being tracked')
    period: str = Field(..., description='Time period for the quota')
    limit: float = Field(..., description='Quota limit value')
    used: float = Field(..., description='Current usage value')
    remaining: float = Field(..., description='Remaining quota (limit - used)')
    exceeded: bool = Field(..., description='Whether the quota has been exceeded')


class QuotaStatus(BaseModel):
    id: str = Field(..., description='Unique identifier for the quota')
    name: str = Field(..., description='Human-readable name of the quota')
    metric: str = Field(
        ..., description='Metric being tracked (e.g., "total_tokens", "cost_cents")'
    )
    period: str = Field(..., description='Period for the quota (e.g., "day", "month", "year")')
    limit: float = Field(..., description='Quota limit value')
    used: float = Field(..., description='Current usage value')
    remaining: float = Field(..., description='Remaining quota (limit - used)')
    exceeded: bool = Field(..., description='Whether the quota has been exceeded')
    reset: float = Field(..., description='Unix timestamp when the quota period resets')


class RateLimitCheckResult(BaseModel):
    id: str = Field(..., description='Unique identifier for the rate limit')
    name: str = Field(..., description='Human-readable name of the rate limit')
    window: str = Field(..., description='Time window for the rate limit')
    limit: float = Field(..., description='Maximum requests allowed in the window')
    remaining: float = Field(..., description='Number of requests remaining in the current window')
    reset: float = Field(..., description='Unix timestamp when the rate limit window resets')
    exceeded: bool = Field(..., description='Whether the rate limit has been exceeded')


class RateLimitStatus(BaseModel):
    id: str = Field(..., description='Unique identifier for the rate limit')
    name: str = Field(..., description='Human-readable name of the rate limit')
    window: str = Field(..., description='Time window for the rate limit (e.g., "1m", "1h", "1d")')
    limit: float = Field(..., description='Maximum number of requests allowed in the window')
    remaining: float = Field(..., description='Number of requests remaining in the current window')
    reset: float = Field(..., description='Unix timestamp when the rate limit window resets')
    exceeded: bool = Field(..., description='Whether the rate limit has been exceeded')


class UsageBreakdownItem(BaseModel):
    dimension: str | None = Field(
        None, description='Dimension value (e.g., model name, customer ID)'
    )
    totalEvents: float = Field(..., description='Total events for this dimension')
    totalTokens: float = Field(..., description='Total tokens for this dimension')
    totalInputTokens: float = Field(..., description='Total input tokens')
    totalOutputTokens: float = Field(..., description='Total output tokens')
    totalCostCents: float = Field(..., description='Total cost in cents')


class UsageTimeseriesItem(BaseModel):
    timestamp: AwareDatetime = Field(..., description='Timestamp for this data point')
    totalEvents: float = Field(..., description='Total events in this time bucket')
    totalTokens: float = Field(..., description='Total tokens in this time bucket')
    totalInputTokens: float = Field(..., description='Total input tokens')
    totalOutputTokens: float = Field(..., description='Total output tokens')
    totalCostCents: float = Field(..., description='Total cost in cents')


class EventsGetResponse(PaginationCursor):
    data: list[Event]


class QuotasGetResponse(PaginationCursor):
    data: list[Quota]


class QuotasQuotaIdAlertsGetResponse(PaginationCursor):
    data: list[QuotaAlert]


class QuotaAlertsAlertIdHistoryGetResponse(PaginationCursor):
    data: list[QuotaAlertLog]


class RateLimitsGetResponse(PaginationCursor):
    data: list[RateLimit]


class EventsBatchPostRequest(BaseModel):
    events: list[EventsPostRequest] = Field(
        ..., description='Array of events to ingest (max 1000)', max_length=1000
    )


class QuotasCheckResponse(BaseModel):
    allowed: bool = Field(..., description='Whether the quota check passed')
    quotas: list[QuotaCheckResult] = Field(..., description='Status of all matching quotas')


class RateLimitsCheckResponse(BaseModel):
    allowed: bool = Field(..., description='Whether the rate limit check passed')
    rateLimits: list[RateLimitCheckResult] = Field(
        ..., description='Status of all matching rate limits'
    )


class TrackPostErrorResponse(BaseModel):
    allowed: bool = Field(
        ..., description='Whether the request was allowed (always false for 429 responses)'
    )
    error: str = Field(..., description='Error message indicating which limit was exceeded')
    rateLimits: list[RateLimitStatus] | None = Field(
        None, description='Status of all matching rate limits'
    )
    quotas: list[QuotaStatus] | None = Field(None, description='Status of all matching quotas')


class TrackPostResponse(BaseModel):
    id: str = Field(..., description='Unique identifier for the ingested event')
    allowed: bool = Field(
        ..., description='Whether the request was allowed (always true for 201 responses)'
    )
    rateLimits: list[RateLimitStatus] = Field(..., description='Status of all matching rate limits')
    quotas: list[QuotaStatus] = Field(..., description='Status of all matching quotas')


class UsageBreakdownResponse(BaseModel):
    data: list[UsageBreakdownItem] = Field(..., description='Array of usage breakdown by dimension')


class UsageTimeseriesResponse(BaseModel):
    data: list[UsageTimeseriesItem] = Field(..., description='Array of usage data over time')
