"""Auto-generated operation classes.

This file is auto-generated by the operators generator.
Do not edit this file manually.
"""

from typing import TYPE_CHECKING, Any, Dict, List, Optional

from limitry.client.types import (
    UsageBreakdownResponse,
    UsageSummary,
    UsageTimeseriesResponse
)
from limitry.client.utils.pagination import PaginatedResponse

if TYPE_CHECKING:
    from limitry.client.client import Client


class Usage:
    """Operations for usage."""

    def __init__(self, client: "Client") -> None:
        """Initialize Usage operations.

        Args:
            client: The Limitry client instance
        """
        self._client = client

    async def get_summary(
        self,
        start_date: str,
        end_date: str,
        customer_id: Optional[str] = None,
        event_type: Optional[str] = None,
        model: Optional[str] = None
    ) -> UsageSummary:
        """Get usage summary.

Retrieve aggregated usage metrics for the project.

Returns totals for events, tokens, and costs within the specified date range. You can filter by customer, event type, or model to get specific subsets of data.

**Metrics Included:**
- Total events count
- Total tokens (input + output)
- Total input tokens
- Total output tokens
- Total cost in cents.

Args:
    customer_id: Filter usage by customer ID
    event_type: Filter usage by event type (e.g., "model_call", "embedding")
    model: Filter usage by model name (e.g., "gpt-4", "claude-3")
    start_date: Start of the date range (ISO 8601 format)
    end_date: End of the date range (ISO 8601 format)

Returns:
    UsageSummary: Usage summary"""
        params = {
            "customerId": customer_id,
            "eventType": event_type,
            "model": model,
            "startDate": start_date,
            "endDate": end_date,
        }
        params = {k: v for k, v in params.items() if v is not None}
        response = await self._client.request("GET", "/usage", params=params)
        return UsageSummary(**response)


    async def get_breakdown(
        self,
        group_by: str,
        start_date: str,
        end_date: str,
        customer_id: Optional[str] = None,
        event_type: Optional[str] = None,
        model: Optional[str] = None
    ) -> UsageBreakdownResponse:
        """Get usage breakdown.

Retrieve usage metrics grouped by a specific dimension.

This endpoint provides detailed breakdowns of usage data, allowing you to see how usage is distributed across different dimensions like models, customers, event types, or providers.

**Use Cases:**
- See which models consume the most tokens
- Identify top customers by usage
- Compare usage across different event types
- Analyze provider-specific consumption.

Args:
    group_by: Dimension to group usage by
    customer_id: Filter usage by customer ID before grouping
    event_type: Filter usage by event type before grouping
    model: Filter usage by model name before grouping
    start_date: Start of the date range (ISO 8601 format)
    end_date: End of the date range (ISO 8601 format)

Returns:
    UsageBreakdownResponse: Usage breakdown"""
        params = {
            "groupBy": group_by,
            "customerId": customer_id,
            "eventType": event_type,
            "model": model,
            "startDate": start_date,
            "endDate": end_date,
        }
        params = {k: v for k, v in params.items() if v is not None}
        response = await self._client.request("GET", "/usage/breakdown", params=params)
        return UsageBreakdownResponse(**response)


    async def get_timeseries(
        self,
        interval: str,
        start_date: str,
        end_date: str,
        customer_id: Optional[str] = None,
        event_type: Optional[str] = None,
        model: Optional[str] = None
    ) -> UsageTimeseriesResponse:
        """Get usage timeseries.

Retrieve usage metrics bucketed by time interval.

Returns time-series data showing how usage changes over time. Useful for creating charts, identifying trends, and monitoring usage patterns.

**Intervals:**
- \\`hour\\`: Bucket data by hour
- \\`day\\`: Bucket data by day
- \\`week\\`: Bucket data by week

Each data point includes the timestamp and all usage metrics for that time period.

Args:
    interval: Time interval for bucketing data
    customer_id: Filter usage by customer ID
    event_type: Filter usage by event type
    model: Filter usage by model name
    start_date: Start of the date range (ISO 8601 format)
    end_date: End of the date range (ISO 8601 format)

Returns:
    UsageTimeseriesResponse: Usage timeseries"""
        params = {
            "interval": interval,
            "customerId": customer_id,
            "eventType": event_type,
            "model": model,
            "startDate": start_date,
            "endDate": end_date,
        }
        params = {k: v for k, v in params.items() if v is not None}
        response = await self._client.request("GET", "/usage/timeseries", params=params)
        return UsageTimeseriesResponse(**response)

