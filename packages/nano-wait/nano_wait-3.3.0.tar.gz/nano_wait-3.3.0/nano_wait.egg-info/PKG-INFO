Metadata-Version: 2.4
Name: nano_wait
Version: 3.3.0
Summary: Adaptive waiting and computer vision execution engine â€” replaces time.sleep() with system-aware, vision-driven automation.
Author: Luiz Filipe Seabra de Marco
Author-email: luizfilipeseabra@icloud.com
License: MIT
Keywords: automation,adaptive wait,smart wait,execution engine,gui automation,computer vision,vision mode,ocr,screen automation,rpa,ai automation,pyautogui,selenium alternative,testing,wifi awareness,system context
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Testing
Classifier: Topic :: Desktop Environment
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Utilities
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: psutil
Requires-Dist: pywifi
Provides-Extra: vision
Requires-Dist: pyautogui; extra == "vision"
Requires-Dist: pytesseract; extra == "vision"
Requires-Dist: pynput; extra == "vision"
Requires-Dist: opencv-python; extra == "vision"
Requires-Dist: numpy; extra == "vision"
Requires-Dist: Pillow; extra == "vision"
Provides-Extra: dev
Requires-Dist: pytest; extra == "dev"
Requires-Dist: pytest-mock; extra == "dev"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: keywords
Dynamic: license
Dynamic: license-file
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

# ğŸ§  Nano-Wait â€” Adaptive & Visual Execution Engine

## Nano-Wait Ã© um motor de execuÃ§Ã£o adaptativo para Python que substitui delays cegos (time.sleep) por decisÃµes baseadas em contexto do sistema e estado visual da tela.

Ele combina:

- â± Espera adaptativa (CPU, memÃ³ria, rede)

- ğŸ‘ï¸ VisÃ£o computacional (OCR + Ã­cones)

- ğŸ§  MemÃ³ria visual determinÃ­stica (sem ML pesado)

- ğŸ–¥ï¸ API Python + CLI

### ğŸš€ Quick Start (o essencial)
```
from nano_wait import wait

wait(2.0)
wait(2.0, speed="fast")
wait(2.0, smart=True)
```

Com rede:
```
wait(3.0, wifi="MyNetwork", smart=True)
```

Com visÃ£o:
```
wait(until="logged_in", timeout=15)
wait(icon="ok.png", timeout=10)
```
## âš ï¸ InstalaÃ§Ã£o & DependÃªncias (LEIA ISTO)

Nano-Wait nÃ£o Ã© uma biblioteca leve por padrÃ£o.
Ela integra sistema operacional, visÃ£o computacional e automaÃ§Ã£o grÃ¡fica.

### ğŸ“¦ DependÃªncias Python

Instaladas via pip:
```
pip install nano-wait
```

Incluem:

- psutil

- opencv-python

- pytesseract

- pynput

- pyautogui

- numpy

## ğŸ§  DependÃªncia EXTERNA OBRIGATÃ“RIA (VisionMode)

ğŸ‘‰ O Tesseract OCR precisa estar instalado no sistema operacional.

macOS
```
brew install tesseract
```
Ubuntu / Debian
```
sudo apt install tesseract-ocr
```
Windows

- Baixar o instalador oficial do Tesseract

- Adicionar o caminho ao PATH

âš ï¸ Sem o Tesseract, qualquer uso de OCR no VisionMode falharÃ¡ imediatamente.

## ğŸ§  Mental Model â€” Como o Nano-Wait funciona

Nano-Wait executa continuamente:
```
observe â†’ reason â†’ wait â†’ observe
```

Ele Ã© composto por dois motores cooperativos:

### â± Adaptive Waiting Engine â€” quando avanÃ§ar?

- CPU

- MemÃ³ria

- Wi-Fi (se disponÃ­vel)

- Speed / Smart Mode

### ğŸ‘ï¸ Vision Engine â€” o que estÃ¡ acontecendo?

- OCR (texto)

- Ãcones (template matching)

- MemÃ³ria visual persistente

ğŸ‘‰ A execuÃ§Ã£o nunca avanÃ§a cegamente.

## â±ï¸ Adaptive Waiting Engine
ğŸ“Š PC Score (estado da mÃ¡quina)
```
cpu_score = 10 - cpu_usage / 10
mem_score = 10 - mem_usage / 10

pc_score = (cpu_score + mem_score) / 2
```

- Intervalo: 0.0 â†’ 10.0

- Suave

- Sem thresholds rÃ­gidos

## ğŸŒ Wi-Fi Awareness (opcional)
| Sistema | ImplementaÃ§Ã£o |
| ------- | ------------- |
| Windows | pywifi        |
| macOS   | airport       |
| Linux   | nmcli         |

### ğŸ§¯ Casos de borda (importante)

- Se o pywifi falhar no Windows

- Se o comando do sistema nÃ£o responder

- Se nÃ£o houver Wi-Fi ativo

ğŸ‘‰ Nano-Wait assume automaticamente um valor neutro:
```
wifi_score = 5.0
```

Isso garante:

- Nenhuma exceÃ§Ã£o

- Nenhum comportamento extremo

- ExecuÃ§Ã£o previsÃ­vel

## ğŸ§  Smart Context Mode
```
wait(2.0, smart=True)
```

Nesse modo, o Nano-Wait calcula a agressividade automaticamente:
```
risk = (pc_score + wifi_score) / 2
speed = clamp(risk, 0.5 â†’ 5.0)
```

Ideal para:

- Ambientes desconhecidos

- MÃ¡quinas diferentes

- Scripts distribuÃ­dos

âš¡ Speed Presets (manual)
| Speed  | Valor interno |
| ------ | ------------- |
| slow   | 0.8           |
| normal | 1.5           |
| fast   | 3.0           |
| ultra  | 6.0           |


âš ï¸ Speed nÃ£o define tempo fixo, apenas limite de agressividade.

## â±ï¸ CÃ¡lculo Final de Espera
```
wait_time = clamp(t / factor, 0.05 â†’ t)
```

Garantias:

- Nunca < 50 ms

- Nunca > tempo base

- EstÃ¡vel mesmo sob carga

## ğŸ‘ï¸ Vision Engine
```
from nano_wait.vision import VisionMode

vision = VisionMode(mode="observe")
state = vision.observe()
```
Modos conceituais

- observe â†’ detectar estados

- learn â†’ ensinar padrÃµes

- decision â†’ agir conforme estado

## ğŸ“š Learn Mode â€” MemÃ³ria Visual (sem ML)
```
vision.learn("Welcome", state="home")
vision.learn_icon("ok.png", state="confirmed")
```

Os padrÃµes sÃ£o salvos em:
```
~/.nano-wait/vision_patterns.json
```

âœ”ï¸ DeterminÃ­stico
âœ”ï¸ Versionado
âœ”ï¸ ReproduzÃ­vel
âœ”ï¸ ExplicÃ¡vel

## ğŸ” Retorno da funÃ§Ã£o wait (TIPOS)

A funÃ§Ã£o wait nÃ£o retorna sempre a mesma coisa:
```
result = wait(...)
```
### PossÃ­veis retornos
â±ï¸ Espera por tempo
```
float  # tempo efetivamente aguardado
```

Exemplo:
```
elapsed = wait(2.0)
```
### ğŸ‘ï¸ Espera visual
```
VisualState
```

Exemplo:
```
state = wait(until="logged_in")

if state.detected:
    print(state.name, state.confidence)
```

ğŸ‘‰ Sempre valide o tipo do retorno em automaÃ§Ãµes crÃ­ticas.

## ğŸ–¥ï¸ CLI â€” Uso via Terminal
### ğŸ“¦ InstalaÃ§Ã£o correta da CLI

Para que o comando funcione:
```
nano-wait 2 --smart
```

O pacote deve expor um entry_point no setup.py ou pyproject.toml:
```
entry_points={
    "console_scripts": [
        "nano-wait=nano_wait.cli:main"
    ]
}

```
Sem isso, o comando nÃ£o existirÃ¡ no terminal, apenas a API Python.

### Exemplos de uso
```
nano-wait 2 --smart --verbose
nano-wait 3 --wifi MyNetwork --speed fast
```

Flags:

- --smart

- --wifi

- --speed

- --verbose

- --log

## ğŸ”Ÿ O que pode melhorar (o caminho para o 10)

DocumentaÃ§Ã£o honesta Ã© o que separa libs boas de libs grandes.

### PrÃ³ximos upgrades naturais:

-  InstalaÃ§Ã£o modular (nano-wait[vision])

 - Lazy import do VisionMode

 - Typed overloads para wait

 - ExceÃ§Ãµes semÃ¢nticas (VisionTimeout, ContextUnavailable)

-  Benchmarks oficiais vs time.sleep

-  Modo headless/documentado

## ğŸ“Œ Em uma frase

**Nano-Wait nÃ£o espera tempo â€” ele espera condiÃ§Ãµes.**
