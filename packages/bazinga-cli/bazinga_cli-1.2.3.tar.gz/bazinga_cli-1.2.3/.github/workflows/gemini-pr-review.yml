# Automated PR review workflow using Gemini API
name: Gemini PR Review

on:
  # Manual trigger only - automatic PR triggers disabled
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request number to review'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: write

# Prevent duplicate runs on same PR
concurrency:
  group: gemini-pr-review-${{ github.event.inputs.pr_number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest

    steps:
      - name: Fetch PR details
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=${{ inputs.pr_number }}
          echo "Fetching details for PR #$PR_NUMBER..."

          # Fetch PR data
          PR_DATA=$(gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER")

          # Extract needed fields
          echo "head_ref=$(echo "$PR_DATA" | jq -r '.head.ref')" >> $GITHUB_OUTPUT
          echo "base_ref=$(echo "$PR_DATA" | jq -r '.base.ref')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$PR_DATA" | jq -r '.head.sha')" >> $GITHUB_OUTPUT
          echo "title=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

          # Check if PR is from same repo (not a fork)
          HEAD_REPO=$(echo "$PR_DATA" | jq -r '.head.repo.full_name')
          if [ "$HEAD_REPO" != "${{ github.repository }}" ]; then
            echo "::error::PR is from a fork ($HEAD_REPO). Cannot review fork PRs due to secret access restrictions."
            exit 1
          fi

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          # Full history ensures merge base is always available for diff
          fetch-depth: 0
          # Checkout the PR branch by name (not just SHA) to ensure we're on the right branch
          ref: ${{ steps.pr.outputs.head_ref }}

      - name: Verify checkout
        env:
          EXPECTED_SHA: ${{ steps.pr.outputs.head_sha }}
          EXPECTED_REF: ${{ steps.pr.outputs.head_ref }}
        run: |
          ACTUAL_SHA=$(git rev-parse HEAD)
          ACTUAL_BRANCH=$(git branch --show-current || echo "detached")

          echo "Expected branch: $EXPECTED_REF"
          echo "Expected SHA: $EXPECTED_SHA"
          echo "Actual branch: $ACTUAL_BRANCH"
          echo "Actual SHA: $ACTUAL_SHA"

          # Verify we have the right commit (SHA should match or be ancestor if force-pushed)
          if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
            echo "::warning::Checked out SHA ($ACTUAL_SHA) differs from PR head ($EXPECTED_SHA). PR may have been updated."
          fi

          echo "âœ… Checkout verified: reviewing branch '$EXPECTED_REF' at commit ${ACTUAL_SHA:0:7}"

      - name: Compute diff
        id: diff
        env:
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        run: |
          git fetch origin "$BASE_REF"

          # Capture the commit SHA being reviewed (important for staleness detection)
          REVIEW_SHA=$(git rev-parse HEAD)
          REVIEW_SHA_SHORT=$(git rev-parse --short HEAD)
          echo "review_sha=$REVIEW_SHA" >> $GITHUB_OUTPUT
          echo "review_sha_short=$REVIEW_SHA_SHORT" >> $GITHUB_OUTPUT
          echo "Reviewing commit: $REVIEW_SHA_SHORT ($REVIEW_SHA)"

          # Exclude package-lock.json (large, auto-generated) from review diff
          git diff "origin/$BASE_REF"...HEAD -- . ':!**/package-lock.json' > diff.patch

      - name: Check API key
        id: api_key_check
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "has_key=false" >> $GITHUB_OUTPUT
            echo "## Gemini Code Review" > review.txt
            echo "" >> review.txt
            echo "Gemini review skipped: no API key available for this PR context." >> review.txt
          else
            echo "has_key=true" >> $GITHUB_OUTPUT
          fi

      - name: Fetch previous Gemini reviews from PR
        id: previous_gemini
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          # Fetch previous review comments from this PR posted by github-actions bot
          # This ensures Gemini has context from its own previous reviews
          echo "Fetching comments from PR #$PR_NUMBER..."

          # Fetch previous review for context AND timestamp for response filtering
          # Note: (last // {}) handles case when no previous reviews exist (avoids jq null error)
          gh api "repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            --jq '[.[] | select((.user.login == "github-actions[bot]" or .user.login == "github-actions") and (.body | contains("## Gemini Code Review")))] | (last // {}) | {body: .body, created_at: .created_at, id: .id}' \
            > previous_gemini_review.json

          # Extract body for prompt context
          jq -r '.body // empty' previous_gemini_review.json > previous_gemini_review.txt

          # Extract timestamp for response filtering
          PREV_REVIEW_TIMESTAMP=$(jq -r '.created_at // empty' previous_gemini_review.json)
          echo "prev_review_timestamp=$PREV_REVIEW_TIMESTAMP" >> $GITHUB_OUTPUT

          if [ -s previous_gemini_review.txt ]; then
            REVIEW_SIZE=$(wc -c < previous_gemini_review.txt)
            echo "Found previous Gemini review ($REVIEW_SIZE bytes) at $PREV_REVIEW_TIMESTAMP"
            echo "has_previous_gemini=true" >> $GITHUB_OUTPUT
          else
            echo "No previous Gemini review found on this PR"
            echo "has_previous_gemini=false" >> $GITHUB_OUTPUT
          fi

      - name: Fetch responses to Gemini review
        id: review_responses
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREV_REVIEW_TIMESTAMP: ${{ steps.previous_gemini.outputs.prev_review_timestamp }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          # Fetch responses to THIS bot's review only (not all responses)
          # Uses hybrid approach: timestamp window + marker filter
          echo "Fetching responses to Gemini review from PR #$PR_NUMBER..."

          if [ -z "$PREV_REVIEW_TIMESTAMP" ]; then
            echo "No previous review timestamp, skipping response fetch"
            echo "has_responses=false" >> $GITHUB_OUTPUT
            touch review_responses.txt
            exit 0
          fi

          echo "Looking for responses after: $PREV_REVIEW_TIMESTAMP"

          # Filter: posted AFTER our last review AND contains "Response to Gemini"
          # Note: gh api --jq doesn't support --arg, so pipe to jq separately
          gh api "repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            | jq -r --arg since "$PREV_REVIEW_TIMESTAMP" \
            '[.[] | select(.created_at > $since and (.body | contains("Response to Gemini")))] | .[] | "--- Response from \(.user.login) at \(.created_at) ---\n\(.body)\n"' \
            > review_responses.txt

          if [ -s review_responses.txt ]; then
            RESP_SIZE=$(wc -c < review_responses.txt)
            echo "Found responses to Gemini review ($RESP_SIZE bytes)"
            echo "has_responses=true" >> $GITHUB_OUTPUT
          else
            echo "No responses to Gemini review found"
            echo "has_responses=false" >> $GITHUB_OUTPUT
          fi

      - name: Build prompt
        env:
          PR_TITLE: ${{ steps.pr.outputs.title }}
          REPO_NAME: ${{ github.repository }}
          BRANCH_NAME: ${{ steps.pr.outputs.head_ref }}
          REVIEW_SHA: ${{ steps.diff.outputs.review_sha }}
          REVIEW_SHA_SHORT: ${{ steps.diff.outputs.review_sha_short }}
          HAS_PREVIOUS_GEMINI: ${{ steps.previous_gemini.outputs.has_previous_gemini }}
          HAS_RESPONSES: ${{ steps.review_responses.outputs.has_responses }}
        run: |
          # Configuration
          # Max diff size in LINES - truncate by lines for clean breaks (not bytes which can corrupt)
          # 3000 lines is generous for most PRs, Gemini 3 Pro has 1M context window
          MAX_DIFF_LINES=3000
          MAX_PREVIOUS_GEMINI_SIZE=16000
          MAX_RESPONSES_SIZE=12000

          cat > prompt_header.txt << 'EOF'
          You are an expert code reviewer analyzing a pull request.

          CRITICAL RULE - Diff Interpretation:
          You are reviewing a DIFF, not the full file. The diff only shows CHANGED lines.
          - Lines with "+" are ADDITIONS in this PR
          - Lines with "-" are DELETIONS from this PR
          - Lines without +/- are CONTEXT (they exist but weren't changed)

          NEVER claim something is "missing" unless:
          1. The diff shows it being DELETED (line starts with "-"), OR
          2. The diff shows NEW code that should include it but doesn't

          If unchanged code exists outside the diff, you cannot see it. Do NOT assume
          features are missing just because they don't appear with "+" in the diff.
          If unsure, say "I cannot verify from the diff whether X exists."

          OUTPUT FORMAT - MANDATORY:
          You MUST use structured bullet points and tables. DO NOT write prose paragraphs.
          - Use numbered lists for issues (not narrative paragraphs)
          - Use markdown tables for summaries
          - Be concise: 1-2 sentences per issue maximum
          - Every issue MUST include: file:line, what's wrong, how to fix

          EOF

          # Sanitize and add PR metadata
          echo "Pull Request Title: $PR_TITLE" >> prompt_header.txt
          echo "Repository: $REPO_NAME" >> prompt_header.txt
          echo "Branch: $BRANCH_NAME" >> prompt_header.txt
          echo "Reviewing Commit: $REVIEW_SHA_SHORT" >> prompt_header.txt
          echo "" >> prompt_header.txt
          echo "âš ï¸ Note: This review is for commit $REVIEW_SHA_SHORT. If newer commits exist, this review may be stale." >> prompt_header.txt
          echo "" >> prompt_header.txt

          # Include previous Gemini review from this PR (your own previous feedback)
          if [ "$HAS_PREVIOUS_GEMINI" = "true" ] && [ -s previous_gemini_review.txt ]; then
            echo "## Your Previous Review on This PR" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "You already posted a review on this PR. The code has been updated since then." >> prompt_header.txt
            echo "Use this to:" >> prompt_header.txt
            echo "- Acknowledge issues that were FIXED in the new diff" >> prompt_header.txt
            echo "- Avoid repeating feedback that still applies but hasn't changed" >> prompt_header.txt
            echo "- Focus on NEW changes since your last review" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Your previous review (truncated if large):" >> prompt_header.txt
            echo '```markdown' >> prompt_header.txt
            head -c "$MAX_PREVIOUS_GEMINI_SIZE" previous_gemini_review.txt >> prompt_header.txt
            echo '' >> prompt_header.txt
            echo '```' >> prompt_header.txt
            echo "" >> prompt_header.txt
          fi

          # Include responses explaining what was fixed/skipped
          if [ "$HAS_RESPONSES" = "true" ] && [ -s review_responses.txt ]; then
            echo "## Responses to Review Feedback" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "The developer posted responses explaining which issues were addressed:" >> prompt_header.txt
            echo "- âœ… = Fixed/Implemented" >> prompt_header.txt
            echo "- â­ï¸ = Intentionally skipped (with explanation)" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "ðŸ”´ **CRITICAL RULES FOR RESPONDED ITEMS:**" >> prompt_header.txt
            echo "1. Items marked âœ… Fixed: Do NOT mention again. Verify fix exists in diff, then move on." >> prompt_header.txt
            echo "2. Items marked â­ï¸ Skipped: Do NOT re-raise UNLESS it causes:" >> prompt_header.txt
            echo "   - Security vulnerabilities (authentication bypass, injection, etc.)" >> prompt_header.txt
            echo "   - Runtime crashes or data loss" >> prompt_header.txt
            echo "   - Breaking changes to public APIs" >> prompt_header.txt
            echo "3. If re-raising a skipped item, you MUST explain why it's CRITICAL, not just 'better practice'" >> prompt_header.txt
            echo "4. Acknowledge responded items briefly: 'Acknowledged as addressed/deferred: [list]'" >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Focus your review on genuinely NEW issues in the diff, not previously discussed items." >> prompt_header.txt
            echo "" >> prompt_header.txt
            echo "Responses:" >> prompt_header.txt
            echo '```' >> prompt_header.txt
            head -c "$MAX_RESPONSES_SIZE" review_responses.txt >> prompt_header.txt
            echo '' >> prompt_header.txt
            echo '```' >> prompt_header.txt
            echo "" >> prompt_header.txt
          fi

          cat >> prompt_header.txt << 'EOF'
          NOTE: You are provided with the complete Git diff below. Use this diff to understand all changes in this PR.

          Analyze the diff and provide feedback using THIS EXACT FORMAT:

          ```
          ## Gemini Code Review

          _Reviewed commit: {sha}_

          ### Summary

          | Category | Count |
          |----------|-------|
          | ðŸ”´ Critical | N |
          | ðŸŸ¡ Suggestions | N |
          | âœ… Good Practices | N |

          ### ðŸ”´ Critical Issues (MUST FIX)

          1. **[file:line]** Issue title
             - Problem: What's wrong (1 sentence)
             - Fix: How to fix it (1 sentence)

          ### ðŸŸ¡ Suggestions (SHOULD CONSIDER)

          1. **[file:line]** Suggestion title
             - Current: What the code does now
             - Better: What would be better

          ### âœ… Good Practices Observed

          - [Brief acknowledgment of good patterns]

          ### Updates Since Last Review (if applicable)

          | Previous Issue | Status |
          |----------------|--------|
          | Issue X | âœ… Fixed in this commit |
          | Issue Y | â­ï¸ Acknowledged as deferred |

          ### Already Addressed Items (from prior responses)

          Items below were addressed in prior responses. Listed here for completeness, NOT in main review:

          | Item | Response | Your Assessment |
          |------|----------|-----------------|
          | [file:line] Issue A | â­ï¸ Skipped - by design | Acknowledged - valid reason |
          | [file:line] Issue B | âœ… Fixed | Verified in diff |
          ```

          **CRITICAL RULES:**
          - Use BULLET POINTS, not prose paragraphs
          - Every issue MUST have file:line reference
          - Be CONCISE: max 2 sentences per issue
          - If no issues in a category, write "None found"
          - Start with "## Gemini Code Review" header
          - Items from prior responses go in "Already Addressed Items" table at END, NOT in Critical/Suggestions

          ## Git Diff

          ```diff
          EOF

          # Truncate diff by LINES for clean breaks (not bytes which can corrupt diff blocks)
          DIFF_LINES="$(wc -l < diff.patch 2>/dev/null || echo 0)"
          if [ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ]; then
            echo "" >> prompt_header.txt
            echo "âš ï¸ Note: The diff has been truncated to ${MAX_DIFF_LINES} lines due to size limits." >> prompt_header.txt
            echo "" >> prompt_header.txt
            head -n "$MAX_DIFF_LINES" diff.patch >> prompt_header.txt
          else
            cat diff.patch >> prompt_header.txt
          fi

          cat >> prompt_header.txt << 'EOF'
          ```

          ## Complete Source Files (Current State AFTER Changes)

          The diff above only shows CHANGES. Below are the COMPLETE current versions of key
          modified files, so you can verify what code actually exists (not just what changed).

          âš ï¸ **IMPORTANT**: Use these complete files to verify claims before saying something
          is "missing". If you see code here that wasn't in the diff, it means it already
          existed before this PR (unchanged).

          EOF

          # Include complete source of key files touched in this PR
          # Priority: 1) Agent files (.md in agents/), 2) Scripts (.sh, .ps1, .py), 3) Other code
          # Limits: Agent files get 800 lines (critical), others get 400 lines
          # Increased limits to provide full context (Gemini 3 Pro has 1M context)
          MAX_AGENT_LINES=800
          MAX_SOURCE_LINES=400
          MAX_SOURCE_FILES=8
          SOURCE_COUNT=0

          # Get list of changed files from diff
          CHANGED_FILES=$(grep "^diff --git" diff.patch | sed 's/diff --git a\/\([^ ]*\) b\/.*/\1/' | head -30)

          # Helper function to add a file to the prompt
          add_source_file() {
            local file="$1"
            local lang="$2"
            local max_lines="$3"
            if [ -f "$file" ] && [ "$SOURCE_COUNT" -lt "$MAX_SOURCE_FILES" ]; then
              echo "### Complete file: \`$file\`" >> prompt_header.txt
              echo "" >> prompt_header.txt
              echo "\`\`\`$lang" >> prompt_header.txt
              head -n "$max_lines" "$file" >> prompt_header.txt
              FILE_LINES=$(wc -l < "$file")
              if [ "$FILE_LINES" -gt "$max_lines" ]; then
                echo "" >> prompt_header.txt
                echo "... (truncated, showing first $max_lines of $FILE_LINES lines)" >> prompt_header.txt
              fi
              echo '```' >> prompt_header.txt
              echo "" >> prompt_header.txt
              SOURCE_COUNT=$((SOURCE_COUNT + 1))
            fi
          }

          # Priority 1: Agent files (the heart of this project) - get more lines
          for file in $CHANGED_FILES; do
            if [[ "$file" == *agents/*.md ]]; then
              add_source_file "$file" "markdown" "$MAX_AGENT_LINES"
            fi
          done

          # Priority 2: Scripts (.sh, .ps1, .py)
          for file in $CHANGED_FILES; do
            case "$file" in
              *.sh) add_source_file "$file" "bash" "$MAX_SOURCE_LINES" ;;
              *.ps1) add_source_file "$file" "powershell" "$MAX_SOURCE_LINES" ;;
              *.py) add_source_file "$file" "python" "$MAX_SOURCE_LINES" ;;
            esac
          done

          # Priority 3: TypeScript/JavaScript files
          for file in $CHANGED_FILES; do
            case "$file" in
              *.ts) add_source_file "$file" "typescript" "$MAX_SOURCE_LINES" ;;
              *.js) add_source_file "$file" "javascript" "$MAX_SOURCE_LINES" ;;
            esac
          done

          # Priority 4: Config/workflow files (yml/yaml)
          for file in $CHANGED_FILES; do
            case "$file" in
              *.yml|*.yaml) add_source_file "$file" "yaml" "$MAX_SOURCE_LINES" ;;
            esac
          done

      - name: Call Gemini API
        if: steps.api_key_check.outputs.has_key == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set +x  # Prevent API key from appearing in logs

          # Validate prompt file exists and is non-empty
          if [ ! -s prompt_header.txt ]; then
            echo "âš ï¸ Failed to prepare prompt. Check prompt_header.txt formatting." > review.txt
            exit 0
          fi

          # Build payload using jq with --rawfile to avoid "Argument list too long" error
          # --rawfile reads file content directly without shell variable intermediary
          jq -n --rawfile prompt prompt_header.txt '{
            contents: [{
              parts: [{text: $prompt}]
            }]
          }' > gemini_payload.json

          echo "Calling Gemini API..."
          echo "Payload size: $(wc -c < gemini_payload.json) bytes"

          # Save response to file with extended timeout for Gemini 3 Pro
          # --connect-timeout 30: Allow 30s to establish connection
          # --max-time 360: Allow 6 minutes for complete response (Gemini 3 Pro can be slow)
          # Note: Capture exit code explicitly to prevent bash -e from exiting on curl failure
          set +e
          HTTP_CODE=$(curl -s \
            --connect-timeout 30 \
            --max-time 360 \
            -w "%{http_code}" \
            -o gemini_response.json \
            -X POST \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -d @gemini_payload.json \
            https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-preview:generateContent)
          CURL_EXIT=$?
          set -e

          echo "HTTP Status: $HTTP_CODE"
          echo "Curl exit code: $CURL_EXIT"

          # Handle timeout errors (exit code 28)
          if [ "$CURL_EXIT" -eq 28 ]; then
            echo "Error: API request timed out after 240 seconds"
            echo "## âš ï¸ Gemini API Timeout" > review.txt
            echo "" >> review.txt
            echo "The Gemini 3 Pro model took too long to respond (greater than 4 minutes). This can happen with large diffs or complex analysis." >> review.txt
            echo "" >> review.txt
            echo "**Suggestions:**" >> review.txt
            echo "- Try reducing the diff size" >> review.txt
            echo "- Use a faster model (e.g., gemini-2.5-flash)" >> review.txt
            echo "- Retry the workflow" >> review.txt
            exit 0
          fi

          # Handle other curl errors
          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "Error: Curl failed with exit code $CURL_EXIT"
            echo "## âš ï¸ Network Error" > review.txt
            echo "" >> review.txt
            echo "Failed to connect to Gemini API (curl exit code: $CURL_EXIT)." >> review.txt
            echo "" >> review.txt
            echo "**Please check:**" >> review.txt
            echo "- Network connectivity" >> review.txt
            echo "- API endpoint availability" >> review.txt
            echo "- Retry the workflow" >> review.txt
            exit 0
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Gemini API returned status $HTTP_CODE"
            cat gemini_response.json

            # On 503 (model overloaded), retry with faster fallback model
            if [ "$HTTP_CODE" == "503" ]; then
              echo "Model overloaded. Retrying with gemini-2.5-flash..."
              sleep 5  # Brief pause before retry

              set +e
              HTTP_CODE=$(curl -s \
                --connect-timeout 30 \
                --max-time 180 \
                -w "%{http_code}" \
                -o gemini_response.json \
                -X POST \
                -H "Content-Type: application/json" \
                -H "x-goog-api-key: $GEMINI_API_KEY" \
                -d @gemini_payload.json \
                https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent)
              CURL_EXIT=$?
              set -e

              echo "Fallback HTTP Status: $HTTP_CODE"

              if [ "$HTTP_CODE" == "200" ]; then
                echo "Fallback to gemini-2.5-flash succeeded!"
                # Fall through to response parsing below
              else
                echo "## âš ï¸ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
                echo "" >> review.txt
                echo "_Reviewed commit: ${REVIEW_SHA_SHORT}_" >> review.txt
                echo "" >> review.txt
                echo "Primary model (gemini-3-pro-preview) overloaded (503). Fallback model (gemini-2.5-flash) also failed." >> review.txt
                echo "" >> review.txt
                echo "**Suggestions:**" >> review.txt
                echo "- Wait a few minutes and retry the workflow" >> review.txt
                echo "- Check Google AI status page" >> review.txt
                exit 0
              fi
            elif [ "$HTTP_CODE" == "429" ]; then
              echo "## âš ï¸ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "Rate limit exceeded. Please check your API quota at https://aistudio.google.com/app/apikey" >> review.txt
              exit 0
            elif [ "$HTTP_CODE" == "401" ] || [ "$HTTP_CODE" == "403" ]; then
              echo "## âš ï¸ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "Authentication failed. Please verify GEMINI_API_KEY secret is configured correctly." >> review.txt
              exit 0
            else
              echo "## âš ï¸ Gemini API Error (HTTP $HTTP_CODE)" > review.txt
              echo "" >> review.txt
              echo "API call failed. Check workflow logs for details." >> review.txt
              exit 0
            fi
          fi

          # Parse response with error handling
          if ! jq -e '.candidates[0].content.parts[0].text' gemini_response.json > /dev/null 2>&1; then
            echo "âš ï¸ Gemini API returned an unexpected response format. Response:" > review.txt
            cat gemini_response.json >> review.txt
            exit 0
          fi

          jq -r '.candidates[0].content.parts[0].text' gemini_response.json > review.txt

          if [ ! -s review.txt ]; then
            echo "âš ï¸ Review file is empty. Gemini may have returned no content." > review.txt
            exit 0
          fi

          echo "Review generated successfully ($(wc -c < review.txt) bytes)"
          echo "Preview:"
          head -n 10 review.txt

      - name: Post review comment
        # Run even if API call failed (to post error messages)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REVIEW_SHA_SHORT: ${{ steps.diff.outputs.review_sha_short }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          echo "Preparing to post review comment..."

          if [ ! -f review.txt ]; then
            echo "Review file not found, skipping comment."
            exit 0
          fi

          # Check for meaningful content (not just whitespace)
          CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$CONTENT" ]; then
            echo "Review is empty or whitespace-only, skipping comment."
            exit 0
          fi

          REVIEW_SIZE="$(wc -c < review.txt)"
          echo "Review content length: $REVIEW_SIZE bytes"

          # Add prefix with commit SHA to identify which commit was reviewed
          # This helps identify stale reviews when newer commits exist
          # NOTE: Header must start with "## Gemini Code Review" for marker matching
          if grep -q "^## Gemini Code Review" review.txt; then
            echo "Review already has Gemini header, using as-is"
            cp review.txt prefixed_review.txt
          else
            echo "Adding Gemini header prefix with commit SHA"
            echo "## Gemini Code Review" > prefixed_review.txt
            echo "" >> prefixed_review.txt
            echo "_Reviewed commit: ${REVIEW_SHA_SHORT:-unknown}_" >> prefixed_review.txt
            echo "" >> prefixed_review.txt
            cat review.txt >> prefixed_review.txt
          fi

          echo "Posting comment to PR #$PR_NUMBER..."

          gh pr comment $PR_NUMBER --body-file prefixed_review.txt
          echo "Comment posted successfully!"
