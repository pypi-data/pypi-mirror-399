# Automated PR review workflow using OpenAI API (GPT-5)
name: OpenAI PR Review

on:
  # Manual trigger only - automatic PR triggers disabled
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request number to review'
        required: true
        type: number

permissions:
  contents: read
  pull-requests: write
  issues: write

# Prevent duplicate runs on same PR
concurrency:
  group: openai-pr-review-${{ github.event.inputs.pr_number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest

    steps:
      - name: Fetch PR details
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=${{ inputs.pr_number }}
          echo "Fetching details for PR #$PR_NUMBER..."

          # Fetch PR data
          PR_DATA=$(gh api "repos/${{ github.repository }}/pulls/$PR_NUMBER")

          # Extract needed fields
          echo "head_ref=$(echo "$PR_DATA" | jq -r '.head.ref')" >> $GITHUB_OUTPUT
          echo "base_ref=$(echo "$PR_DATA" | jq -r '.base.ref')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$PR_DATA" | jq -r '.head.sha')" >> $GITHUB_OUTPUT
          echo "title=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

          # Check if PR is from same repo (not a fork)
          HEAD_REPO=$(echo "$PR_DATA" | jq -r '.head.repo.full_name')
          if [ "$HEAD_REPO" != "${{ github.repository }}" ]; then
            echo "::error::PR is from a fork ($HEAD_REPO). Cannot review fork PRs due to secret access restrictions."
            exit 1
          fi

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          # Full history ensures merge base is always available for diff
          fetch-depth: 0
          # Checkout the PR branch by name (not just SHA) to ensure we're on the right branch
          ref: ${{ steps.pr.outputs.head_ref }}

      - name: Verify checkout
        env:
          EXPECTED_SHA: ${{ steps.pr.outputs.head_sha }}
          EXPECTED_REF: ${{ steps.pr.outputs.head_ref }}
        run: |
          ACTUAL_SHA=$(git rev-parse HEAD)
          ACTUAL_BRANCH=$(git branch --show-current || echo "detached")

          echo "Expected branch: $EXPECTED_REF"
          echo "Expected SHA: $EXPECTED_SHA"
          echo "Actual branch: $ACTUAL_BRANCH"
          echo "Actual SHA: $ACTUAL_SHA"

          # Verify we have the right commit (SHA should match or be ancestor if force-pushed)
          if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
            echo "::warning::Checked out SHA ($ACTUAL_SHA) differs from PR head ($EXPECTED_SHA). PR may have been updated."
          fi

          echo "âœ… Checkout verified: reviewing branch '$EXPECTED_REF' at commit ${ACTUAL_SHA:0:7}"

      - name: Compute diff
        id: diff
        env:
          BASE_REF: ${{ steps.pr.outputs.base_ref }}
        run: |
          # Fetch base branch for diff
          git fetch origin "$BASE_REF"

          # Capture the commit SHA being reviewed (important for staleness detection)
          REVIEW_SHA=$(git rev-parse HEAD)
          REVIEW_SHA_SHORT=$(git rev-parse --short HEAD)
          echo "review_sha=$REVIEW_SHA" >> $GITHUB_OUTPUT
          echo "review_sha_short=$REVIEW_SHA_SHORT" >> $GITHUB_OUTPUT
          echo "Reviewing commit: $REVIEW_SHA_SHORT ($REVIEW_SHA)"

          # Exclude package-lock.json (large, auto-generated) from review diff
          git diff "origin/$BASE_REF"...HEAD -- . ':!**/package-lock.json' > diff.patch
          DIFF_LINES=$(wc -l < diff.patch)
          echo "Diff size: $DIFF_LINES lines, $(wc -c < diff.patch) bytes"

          # Check for empty diff
          if [ "$DIFF_LINES" -eq 0 ]; then
            echo "empty=true" >> $GITHUB_OUTPUT
            echo "No changes detected in diff"
          else
            echo "empty=false" >> $GITHUB_OUTPUT
          fi

      - name: Skip if empty diff
        if: steps.diff.outputs.empty == 'true'
        run: |
          echo "No code changes to review. Skipping API call."
          exit 0

      - name: Check API key
        if: steps.diff.outputs.empty != 'true'
        id: api_key_check
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "has_key=false" >> $GITHUB_OUTPUT
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI review skipped: no API key available for this PR context." >> review.txt
          else
            echo "has_key=true" >> $GITHUB_OUTPUT
          fi

      - name: Fetch previous OpenAI reviews from PR
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        id: previous_openai
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          # Use gh CLI to fetch comments (simpler than curl)
          echo "Fetching comments from PR #$PR_NUMBER..."

          # Use precise marker "## OpenAI Code Review" to avoid false matches
          # Fetch previous review for context AND timestamp for response filtering
          # Note: (last // {}) handles case when no previous reviews exist (avoids jq null error)
          gh api "repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            --jq '[.[] | select((.user.login == "github-actions[bot]" or .user.login == "github-actions") and (.body | contains("## OpenAI Code Review")))] | (last // {}) | {body: .body, created_at: .created_at, id: .id}' \
            > previous_openai_review.json

          # Extract body for prompt context
          jq -r '.body // empty' previous_openai_review.json > previous_openai_review.txt

          # Extract timestamp for response filtering
          PREV_REVIEW_TIMESTAMP=$(jq -r '.created_at // empty' previous_openai_review.json)
          echo "prev_review_timestamp=$PREV_REVIEW_TIMESTAMP" >> $GITHUB_OUTPUT

          if [ -s previous_openai_review.txt ]; then
            REVIEW_SIZE=$(wc -c < previous_openai_review.txt)
            echo "Found previous OpenAI review ($REVIEW_SIZE bytes) at $PREV_REVIEW_TIMESTAMP"
            echo "has_previous_openai=true" >> $GITHUB_OUTPUT
          else
            echo "No previous OpenAI review found on this PR"
            echo "has_previous_openai=false" >> $GITHUB_OUTPUT
          fi

      - name: Fetch responses to OpenAI review
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        id: review_responses
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PREV_REVIEW_TIMESTAMP: ${{ steps.previous_openai.outputs.prev_review_timestamp }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          # Fetch responses to THIS bot's review only (not all responses)
          # Uses hybrid approach: timestamp window + marker filter
          echo "Fetching responses to OpenAI review from PR #$PR_NUMBER..."

          if [ -z "$PREV_REVIEW_TIMESTAMP" ]; then
            echo "No previous review timestamp, skipping response fetch"
            echo "has_responses=false" >> $GITHUB_OUTPUT
            touch review_responses.txt
            exit 0
          fi

          echo "Looking for responses after: $PREV_REVIEW_TIMESTAMP"

          # Filter: posted AFTER our last review AND contains "Response to OpenAI"
          # Note: gh api --jq doesn't support --arg, so pipe to jq separately
          gh api "repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
            | jq -r --arg since "$PREV_REVIEW_TIMESTAMP" \
            '[.[] | select(.created_at > $since and (.body | contains("Response to OpenAI")))] | .[] | "--- Response from \(.user.login) at \(.created_at) ---\n\(.body)\n"' \
            > review_responses.txt

          if [ -s review_responses.txt ]; then
            RESP_SIZE=$(wc -c < review_responses.txt)
            echo "Found responses to OpenAI review ($RESP_SIZE bytes)"
            echo "has_responses=true" >> $GITHUB_OUTPUT
          else
            echo "No responses to OpenAI review found"
            echo "has_responses=false" >> $GITHUB_OUTPUT
          fi

      - name: Build prompt
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        env:
          PR_TITLE: ${{ steps.pr.outputs.title }}
          REPO_NAME: ${{ github.repository }}
          BRANCH_NAME: ${{ steps.pr.outputs.head_ref }}
          REVIEW_SHA: ${{ steps.diff.outputs.review_sha }}
          REVIEW_SHA_SHORT: ${{ steps.diff.outputs.review_sha_short }}
          HAS_PREVIOUS_OPENAI: ${{ steps.previous_openai.outputs.has_previous_openai }}
          HAS_RESPONSES: ${{ steps.review_responses.outputs.has_responses }}
        run: |
          # Configuration
          # Max diff size in lines - truncate by lines for clean breaks
          # Increased limits to avoid losing context (GPT-5 has 128k context)
          MAX_DIFF_LINES=3000
          MAX_PREVIOUS_OPENAI_LINES=400
          MAX_RESPONSES_LINES=300

          cat > system_prompt.txt << 'EOF'
          You are an expert code reviewer analyzing a pull request. Your reviews are thorough, constructive, and focus on code quality, potential bugs, and best practices.

          When reviewing:
          - Be specific and actionable in your feedback
          - Prioritize important issues over minor style preferences
          - Acknowledge good practices when you see them
          - Consider security implications
          - Think about maintainability and readability

          CRITICAL RULE - Diff Interpretation:
          You are reviewing a DIFF, not the full file. The diff only shows CHANGED lines.
          - Lines with "+" are ADDITIONS in this PR
          - Lines with "-" are DELETIONS from this PR
          - Lines without +/- are CONTEXT (they exist but weren't changed)

          NEVER claim something is "missing" unless:
          1. The diff shows it being DELETED (line starts with "-"), OR
          2. The diff shows NEW code that should include it but doesn't

          If unchanged code exists outside the diff, you cannot see it. Do NOT assume
          features are missing just because they don't appear with "+" in the diff.
          If unsure, say "I cannot verify from the diff whether X exists."

          OUTPUT FORMAT - MANDATORY:
          You MUST use structured bullet points and tables. DO NOT write prose paragraphs.
          - Use numbered lists for issues (not narrative paragraphs)
          - Use markdown tables for summaries
          - Be concise: 1-2 sentences per issue maximum
          - Every issue MUST include: file:line, what's wrong, how to fix

          Format your response as markdown suitable for a GitHub PR comment.
          EOF

          cat > user_prompt.txt << 'EOF'
          EOF

          # Sanitize and add PR metadata
          echo "# Pull Request Review Request" >> user_prompt.txt
          echo "" >> user_prompt.txt
          echo "**Pull Request Title:** $PR_TITLE" >> user_prompt.txt
          echo "**Repository:** $REPO_NAME" >> user_prompt.txt
          echo "**Branch:** $BRANCH_NAME" >> user_prompt.txt
          echo "**Reviewing Commit:** $REVIEW_SHA_SHORT" >> user_prompt.txt
          echo "" >> user_prompt.txt
          echo "âš ï¸ **Note:** This review is for commit $REVIEW_SHA_SHORT. If newer commits exist, this review may be stale." >> user_prompt.txt
          echo "" >> user_prompt.txt

          # Include previous OpenAI review from this PR (your own previous feedback)
          if [ "$HAS_PREVIOUS_OPENAI" = "true" ] && [ -s previous_openai_review.txt ]; then
            echo "## Your Previous Review on This PR" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "You already posted a review on this PR. The code has been updated since then." >> user_prompt.txt
            echo "Use this to:" >> user_prompt.txt
            echo "- Acknowledge issues that were FIXED in the new diff" >> user_prompt.txt
            echo "- Avoid repeating feedback that still applies but hasn't changed" >> user_prompt.txt
            echo "- Focus on NEW changes since your last review" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "Your previous review (truncated if large):" >> user_prompt.txt
            echo '```markdown' >> user_prompt.txt
            head -n "$MAX_PREVIOUS_OPENAI_LINES" previous_openai_review.txt >> user_prompt.txt
            echo '' >> user_prompt.txt
            echo '```' >> user_prompt.txt
            echo "" >> user_prompt.txt
          fi

          # Include responses explaining what was fixed/skipped
          if [ "$HAS_RESPONSES" = "true" ] && [ -s review_responses.txt ]; then
            echo "## Responses to Review Feedback" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "The developer posted responses explaining which issues were addressed:" >> user_prompt.txt
            echo "- âœ… = Fixed/Implemented" >> user_prompt.txt
            echo "- â­ï¸ = Intentionally skipped (with explanation)" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "ðŸ”´ **CRITICAL RULES FOR RESPONDED ITEMS:**" >> user_prompt.txt
            echo "1. Items marked âœ… Fixed: Do NOT mention again. Verify fix exists in diff, then move on." >> user_prompt.txt
            echo "2. Items marked â­ï¸ Skipped: Do NOT re-raise UNLESS it causes:" >> user_prompt.txt
            echo "   - Security vulnerabilities (authentication bypass, injection, etc.)" >> user_prompt.txt
            echo "   - Runtime crashes or data loss" >> user_prompt.txt
            echo "   - Breaking changes to public APIs" >> user_prompt.txt
            echo "3. If re-raising a skipped item, you MUST explain why it's CRITICAL, not just 'better practice'" >> user_prompt.txt
            echo "4. Acknowledge responded items briefly: 'Acknowledged as addressed/deferred: [list]'" >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "Focus your review on genuinely NEW issues in the diff, not previously discussed items." >> user_prompt.txt
            echo "" >> user_prompt.txt
            echo "Responses:" >> user_prompt.txt
            echo '```' >> user_prompt.txt
            head -n "$MAX_RESPONSES_LINES" review_responses.txt >> user_prompt.txt
            echo '' >> user_prompt.txt
            echo '```' >> user_prompt.txt
            echo "" >> user_prompt.txt
          fi

          cat >> user_prompt.txt << 'EOF'

          ## Review Instructions

          Analyze the diff and provide feedback using THIS EXACT FORMAT:

          ```
          ## OpenAI Code Review

          _Reviewed commit: {sha}_

          ### Summary

          | Category | Count |
          |----------|-------|
          | ðŸ”´ Critical | N |
          | ðŸŸ¡ Suggestions | N |
          | âœ… Good Practices | N |

          ### ðŸ”´ Critical Issues (MUST FIX)

          1. **[file:line]** Issue title
             - Problem: What's wrong (1 sentence)
             - Fix: How to fix it (1 sentence)

          ### ðŸŸ¡ Suggestions (SHOULD CONSIDER)

          1. **[file:line]** Suggestion title
             - Current: What the code does now
             - Better: What would be better

          ### âœ… Good Practices Observed

          - [Brief acknowledgment of good patterns]

          ### Updates Since Last Review (if applicable)

          | Previous Issue | Status |
          |----------------|--------|
          | Issue X | âœ… Fixed in this commit |
          | Issue Y | â­ï¸ Acknowledged as deferred |

          ### Already Addressed Items (from prior responses)

          Items below were addressed in prior responses. Listed here for completeness, NOT in main review:

          | Item | Response | Your Assessment |
          |------|----------|-----------------|
          | [file:line] Issue A | â­ï¸ Skipped - by design | Acknowledged - valid reason |
          | [file:line] Issue B | âœ… Fixed | Verified in diff |
          ```

          **CRITICAL RULES:**
          - Use BULLET POINTS, not prose paragraphs
          - Every issue MUST have file:line reference
          - Be CONCISE: max 2 sentences per issue
          - If no issues in a category, write "None found"
          - Start with "## OpenAI Code Review" header
          - Items from prior responses go in "Already Addressed Items" table at END, NOT in Critical/Suggestions

          ## Git Diff

          ```diff
          EOF

          # Truncate diff by lines for clean breaks (not bytes which can corrupt)
          DIFF_LINES="$(wc -l < diff.patch 2>/dev/null || echo 0)"
          if [ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ]; then
            echo "" >> user_prompt.txt
            echo "Note: The diff has been truncated to ${MAX_DIFF_LINES} lines due to size limits." >> user_prompt.txt
            echo "" >> user_prompt.txt
            head -n "$MAX_DIFF_LINES" diff.patch >> user_prompt.txt
          else
            cat diff.patch >> user_prompt.txt
          fi

          cat >> user_prompt.txt << 'EOF'
          ```

          ## Complete Source Files (Current State AFTER Changes)

          The diff above only shows CHANGES. Below are the COMPLETE current versions of key
          modified files, so you can verify what code actually exists (not just what changed).

          âš ï¸ **IMPORTANT**: Use these complete files to verify claims before saying something
          is "missing". If you see code here that wasn't in the diff, it means it already
          existed before this PR (unchanged).

          EOF

          # Include complete source of key files touched in this PR
          # Priority: 1) Agent files (.md in agents/), 2) Scripts (.sh, .ps1, .py), 3) Other code
          # Limits: Agent files get 800 lines (critical), others get 400 lines
          # Increased limits to provide full context (GPT-5 has 128k context)
          MAX_AGENT_LINES=800
          MAX_SOURCE_LINES=400
          MAX_SOURCE_FILES=8
          SOURCE_COUNT=0

          # Get list of changed files from diff
          CHANGED_FILES=$(grep "^diff --git" diff.patch | sed 's/diff --git a\/\([^ ]*\) b\/.*/\1/' | head -30)

          # Helper function to add a file to the prompt
          add_source_file() {
            local file="$1"
            local lang="$2"
            local max_lines="$3"
            if [ -f "$file" ] && [ "$SOURCE_COUNT" -lt "$MAX_SOURCE_FILES" ]; then
              echo "### Complete file: \`$file\`" >> user_prompt.txt
              echo "" >> user_prompt.txt
              echo "\`\`\`$lang" >> user_prompt.txt
              head -n "$max_lines" "$file" >> user_prompt.txt
              FILE_LINES=$(wc -l < "$file")
              if [ "$FILE_LINES" -gt "$max_lines" ]; then
                echo "" >> user_prompt.txt
                echo "... (truncated, showing first $max_lines of $FILE_LINES lines)" >> user_prompt.txt
              fi
              echo '```' >> user_prompt.txt
              echo "" >> user_prompt.txt
              SOURCE_COUNT=$((SOURCE_COUNT + 1))
            fi
          }

          # Priority 1: Agent files (the heart of this project) - get more lines
          for file in $CHANGED_FILES; do
            if [[ "$file" == *agents/*.md ]]; then
              add_source_file "$file" "markdown" "$MAX_AGENT_LINES"
            fi
          done

          # Priority 2: Scripts (.sh, .ps1, .py)
          for file in $CHANGED_FILES; do
            case "$file" in
              *.sh) add_source_file "$file" "bash" "$MAX_SOURCE_LINES" ;;
              *.ps1) add_source_file "$file" "powershell" "$MAX_SOURCE_LINES" ;;
              *.py) add_source_file "$file" "python" "$MAX_SOURCE_LINES" ;;
            esac
          done

          # Priority 3: TypeScript/JavaScript files
          for file in $CHANGED_FILES; do
            case "$file" in
              *.ts) add_source_file "$file" "typescript" "$MAX_SOURCE_LINES" ;;
              *.js) add_source_file "$file" "javascript" "$MAX_SOURCE_LINES" ;;
            esac
          done

          # Priority 4: Config/workflow files (yml/yaml)
          for file in $CHANGED_FILES; do
            case "$file" in
              *.yml|*.yaml) add_source_file "$file" "yaml" "$MAX_SOURCE_LINES" ;;
            esac
          done

      - name: Call OpenAI API
        if: steps.diff.outputs.empty != 'true' && steps.api_key_check.outputs.has_key == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set +x  # Prevent API key from appearing in logs

          # Validate prompt files exist and are non-empty
          if [ ! -s system_prompt.txt ] || [ ! -s user_prompt.txt ]; then
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "Failed to prepare prompts. Check prompt file formatting." >> review.txt
            exit 1
          fi

          # GPT-5 is a reasoning model - temperature is fixed at 1 (not configurable)
          # Needs high max_completion_tokens because reasoning tokens count against the limit
          # Build payload using jq with --rawfile to avoid "Argument list too long" error
          # --rawfile reads file content directly without shell variable intermediary
          jq -n \
            --rawfile system system_prompt.txt \
            --rawfile user user_prompt.txt \
            '{
              model: "gpt-5",
              messages: [
                {role: "system", content: $system},
                {role: "user", content: $user}
              ],
              max_completion_tokens: 49152
            }' > openai_payload.json

          echo "Calling OpenAI API (GPT-5)..."
          echo "Payload size: $(wc -c < openai_payload.json) bytes"

          # Retry logic for transient errors (timeout, 429, 5xx)
          MAX_RETRIES=3
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES..."

            HTTP_CODE=$(curl -s \
              --connect-timeout 30 \
              --max-time 360 \
              -w "%{http_code}" \
              -o openai_response.json \
              -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d @openai_payload.json \
              https://api.openai.com/v1/chat/completions)

            CURL_EXIT=$?

            echo "HTTP Status: $HTTP_CODE, Curl exit: $CURL_EXIT"

            # Check for transient errors that warrant retry
            if [ "$CURL_EXIT" -eq 28 ] || [ "$HTTP_CODE" = "429" ] || [ "$HTTP_CODE" = "500" ] || [ "$HTTP_CODE" = "502" ] || [ "$HTTP_CODE" = "503" ]; then
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                SLEEP_TIME=$((attempt * 10))
                echo "Transient error, retrying in ${SLEEP_TIME}s..."
                sleep $SLEEP_TIME
                continue
              fi
            fi
            break
          done

          # Handle timeout errors (exit code 28) after all retries
          if [ "$CURL_EXIT" -eq 28 ]; then
            echo "Error: API request timed out after all retries"
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "The OpenAI GPT-5 API took too long to respond. Please retry the workflow." >> review.txt
            exit 1
          fi

          # Handle other curl errors
          if [ "$CURL_EXIT" -ne 0 ]; then
            echo "Error: Curl failed with exit code $CURL_EXIT"
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "Failed to connect to OpenAI API. Please retry the workflow." >> review.txt
            exit 1
          fi

          if [ "$HTTP_CODE" != "200" ]; then
            # Extract just the error message, not full response (reduces log verbosity)
            ERROR_MSG=$(jq -r '.error.message // "Unknown error"' openai_response.json 2>/dev/null || echo "Unknown error")
            echo "Error: OpenAI API returned status $HTTP_CODE - $ERROR_MSG"

            # Build error message based on HTTP status
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            if [ "$HTTP_CODE" == "429" ]; then
              echo "Rate limit exceeded. Please check your API quota at https://platform.openai.com/usage" >> review.txt
            elif [ "$HTTP_CODE" == "401" ]; then
              echo "Authentication failed. Please verify OPENAI_API_KEY secret is configured correctly." >> review.txt
            elif [ "$HTTP_CODE" == "403" ]; then
              echo "Access denied. Please check your API key permissions and organization settings." >> review.txt
            elif [ "$HTTP_CODE" == "500" ] || [ "$HTTP_CODE" == "502" ] || [ "$HTTP_CODE" == "503" ]; then
              echo "OpenAI service is temporarily unavailable (HTTP $HTTP_CODE). Please retry the workflow." >> review.txt
            else
              echo "API call failed (HTTP $HTTP_CODE): $ERROR_MSG" >> review.txt
            fi

            exit 1
          fi

          # Parse response with error handling
          if ! jq -e '.choices[0].message.content' openai_response.json > /dev/null 2>&1; then
            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI API returned an unexpected response format. Response:" >> review.txt
            cat openai_response.json >> review.txt
            exit 1
          fi

          jq -r '.choices[0].message.content' openai_response.json > review.txt

          # Check for meaningful content (not just whitespace/newlines)
          REVIEW_CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$REVIEW_CONTENT" ]; then
            # Log finish_reason for debugging (not full response)
            FINISH_REASON=$(jq -r '.choices[0].finish_reason // "unknown"' openai_response.json 2>/dev/null)
            REASONING_TOKENS=$(jq -r '.usage.completion_tokens_details.reasoning_tokens // 0' openai_response.json 2>/dev/null)
            echo "Warning: Empty content. finish_reason=$FINISH_REASON, reasoning_tokens=$REASONING_TOKENS"

            echo "## OpenAI Code Review" > review.txt
            echo "" >> review.txt
            echo "OpenAI returned no content (finish_reason: $FINISH_REASON). This may indicate the model used all tokens for reasoning." >> review.txt
            echo "" >> review.txt
            echo "Please retry the workflow." >> review.txt
            exit 1
          fi

          echo "Review generated successfully ($(wc -c < review.txt) bytes)"
          echo "Preview:"
          head -n 10 review.txt

      - name: Post or update review comment
        # Run even if API call failed (to post error messages)
        if: always() && steps.diff.outputs.empty != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REVIEW_SHA_SHORT: ${{ steps.diff.outputs.review_sha_short }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        run: |
          echo "Preparing to post review comment..."

          # Check for meaningful content (not just whitespace)
          if [ ! -f review.txt ]; then
            echo "Review file not found, skipping comment."
            exit 0
          fi

          CONTENT=$(cat review.txt | tr -d '[:space:]')
          if [ -z "$CONTENT" ]; then
            echo "Review is empty or whitespace-only, skipping comment."
            exit 0
          fi

          echo "Review content length: $(wc -c < review.txt) bytes"

          # Add prefix with commit SHA to identify which commit was reviewed
          # This helps identify stale reviews when newer commits exist
          # NOTE: Header must start with "## OpenAI Code Review" for marker matching
          if grep -q "^## OpenAI Code Review" review.txt; then
            echo "Review already has OpenAI header, using as-is"
            cp review.txt prefixed_review.txt
          else
            echo "Adding OpenAI header prefix with commit SHA"
            echo "## OpenAI Code Review" > prefixed_review.txt
            echo "" >> prefixed_review.txt
            echo "_Reviewed commit: ${REVIEW_SHA_SHORT:-unknown}_" >> prefixed_review.txt
            echo "" >> prefixed_review.txt
            cat review.txt >> prefixed_review.txt
          fi

          # Always post new comment (don't update existing)
          # This ensures new feedback is visible and not hidden in updated comments
          echo "Posting new comment to PR #$PR_NUMBER..."
          gh pr comment $PR_NUMBER --body-file prefixed_review.txt
          echo "Comment posted successfully!"
