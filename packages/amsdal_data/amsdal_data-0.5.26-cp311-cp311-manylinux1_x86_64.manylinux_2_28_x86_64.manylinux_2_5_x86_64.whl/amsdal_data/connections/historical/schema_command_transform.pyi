import amsdal_glue as glue
from _typeshed import Incomplete
from amsdal_data.connections.async_sqlite_historical import AsyncSqliteHistoricalConnection as AsyncSqliteHistoricalConnection
from amsdal_data.connections.constants import METADATA_KEY as METADATA_KEY, METADATA_TABLE as METADATA_TABLE, REFERENCE_TABLE as REFERENCE_TABLE, SCHEMA_TABLE_NAME_FIELD as SCHEMA_TABLE_NAME_FIELD, SECONDARY_PARTITION_KEY as SECONDARY_PARTITION_KEY, TRANSACTION_TABLE as TRANSACTION_TABLE
from amsdal_data.connections.historical.command_builder import TABLE_NAME_VERSION_SEPARATOR as TABLE_NAME_VERSION_SEPARATOR, format_historical_table_name as format_historical_table_name
from amsdal_data.connections.historical.data_query_transform import METADATA_TABLE_ALIAS as METADATA_TABLE_ALIAS, META_CLASS_NAME as META_CLASS_NAME, META_NEW_CLASS_VERSION as META_NEW_CLASS_VERSION, META_PRIMARY_KEY_FIELDS as META_PRIMARY_KEY_FIELDS, META_SCHEMA_FOREIGN_KEYS as META_SCHEMA_FOREIGN_KEYS, NEXT_VERSION_FIELD as NEXT_VERSION_FIELD, build_simple_query_statement_with_metadata as build_simple_query_statement_with_metadata
from amsdal_data.connections.historical.schema_version_manager import AsyncHistoricalSchemaVersionManager as AsyncHistoricalSchemaVersionManager, HistoricalSchemaVersionManager as HistoricalSchemaVersionManager
from amsdal_data.connections.postgresql_historical import AsyncPostgresHistoricalConnection as AsyncPostgresHistoricalConnection, PostgresHistoricalConnection as PostgresHistoricalConnection
from amsdal_data.connections.sqlite_historical import SqliteHistoricalConnection as SqliteHistoricalConnection
from amsdal_data.query import AsyncMetadataInfoQuery as AsyncMetadataInfoQuery
from amsdal_data.services.historical_table_schema import AsyncHistoricalTableSchema as AsyncHistoricalTableSchema, HistoricalTableSchema as HistoricalTableSchema
from amsdal_data.services.table_schema_manager import BaseTableSchemasManager as BaseTableSchemasManager
from amsdal_data.utils import FOREIGN_KEYS_PROPERTY as FOREIGN_KEYS_PROPERTY, validate_data_by_schema as validate_data_by_schema
from amsdal_glue_core.common.data_models.constraints import BaseConstraint as BaseConstraint
from amsdal_glue_core.common.operations.mutations.data import DataMutation as DataMutation
from amsdal_utils.models.enums import Versions
from typing import Any, TypeVar

SchemaT = TypeVar('SchemaT', bound=glue.RegisterSchema | glue.DeleteSchema)

class _BaseSchemaCommandExecutor:
    DATA_TRANSFORM_BATCH_SIZE: int
    _schemas_cache: dict[tuple[str, str], glue.Schema]
    def __init__(self) -> None: ...
    @staticmethod
    def _check_single_mutation(mutations: list[glue.SchemaMutation]) -> None: ...
    @staticmethod
    def _adjust_to_historical_properties(mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @classmethod
    def adjust_references_in_data(cls, data: Any, target_class_name: str, target_object_id: Any, target_object_version: str, replace_object_version: str, replace_class_version: str) -> bool: ...
    def _set_schema_version(self, mutation: SchemaT, *, force_new_version: bool = False) -> SchemaT: ...
    @staticmethod
    def _exclude_unique_constraints(mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @classmethod
    def _adjust_pk_constraints(cls, mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @classmethod
    def _adjust_fk_constraints(cls, mutation: glue.RegisterSchema) -> glue.RegisterSchema: ...
    @staticmethod
    def _adjust_pk_constraint(constraint: BaseConstraint) -> None: ...

class SchemaCommandExecutor(_BaseSchemaCommandExecutor):
    connection: Incomplete
    schema_command: Incomplete
    schema_version_manager: Incomplete
    _historical_table_schema: Incomplete
    def __init__(self, connection: SqliteHistoricalConnection | PostgresHistoricalConnection, schema_command: glue.SchemaCommand, historical_table_schema: HistoricalTableSchema) -> None: ...
    @property
    def historical_table_schema(self) -> HistoricalTableSchema: ...
    def execute(self) -> list[glue.Schema | None]: ...
    def _transform_mutations(self) -> tuple[list[glue.RegisterSchema], list[tuple[glue.SchemaReference, glue.SchemaReference]]]: ...
    def _execute_mutation(self, mutation: glue.RegisterSchema) -> list[glue.Schema | None]: ...
    def _transform_change_mutations_to_register(self, mutations: list[glue.ChangeSchema]) -> tuple[glue.RegisterSchema, glue.SchemaReference]: ...
    def _get_existing_schema(self, schema_name: str, schema_version: glue.Version | Versions | str = ...) -> glue.Schema: ...
    def _transfer_data(self, old_schema_ref: glue.SchemaReference, new_schema_ref: glue.SchemaReference) -> None: ...
    def _fetch_and_generate_m2m_inserts(self, new_schema_ref: glue.SchemaReference, data: glue.Data) -> list[glue.InsertData]: ...

class AsyncSchemaCommandExecutor(_BaseSchemaCommandExecutor):
    connection: Incomplete
    schema_command: Incomplete
    schema_version_manager: Incomplete
    _historical_table_schema: Incomplete
    def __init__(self, connection: AsyncSqliteHistoricalConnection | AsyncPostgresHistoricalConnection, schema_command: glue.SchemaCommand, historical_table_schema: AsyncHistoricalTableSchema | None = None) -> None: ...
    @property
    def historical_table_schema(self) -> AsyncHistoricalTableSchema: ...
    async def execute(self) -> list[glue.Schema | None]: ...
    async def _transform_mutations(self) -> tuple[list[glue.RegisterSchema | glue.DeleteSchema], list[tuple[glue.SchemaReference, glue.SchemaReference]]]: ...
    async def _execute_mutation(self, mutation: glue.RegisterSchema) -> list[glue.Schema | None]: ...
    async def _transform_change_mutations_to_register(self, mutations: list[glue.ChangeSchema]) -> tuple[glue.RegisterSchema, glue.SchemaReference]: ...
    async def _get_existing_schema(self, schema_name: str, schema_version: glue.Version | Versions | str = ...) -> glue.Schema: ...
    async def _transfer_data(self, old_schema_ref: glue.SchemaReference, new_schema_ref: glue.SchemaReference) -> None: ...
    async def _fetch_and_generate_m2m_inserts(self, new_schema_ref: glue.SchemaReference, data: glue.Data) -> list[glue.InsertData]: ...
    @staticmethod
    def _compare_property_names(existing_name: str, target_name: str, fks_meta: dict[str, Any]) -> bool: ...
