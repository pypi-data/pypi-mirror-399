[
  {
    "content": "Writing Custom Actions | Rasa Documentation\n# Writing Custom Actions\nA Rasa assistant can execute different types of actions to respond to the user or update conversation state:\n  * **Responses** _User-facing messages_ defined in your assistant. This is what you will use most frequently to send text, images, buttons, etc.\n  * **Default Actions** _Built-in actions_ that handle certain events or conversation situations out-of-the-box (e.g., `action_restart`, `action_session_start`). These can be overridden with your own custom logic if needed.\n  * **Custom Actions** _User-defined actions_ that can run any code you want (e.g., call external APIs, query databases, or retrieve specific data). Custom actions are the focus of this page.\n## What Are Custom Actions?\u200b\nA **custom action** lets you execute arbitrary logic within your assistant\u2014for example, retrieving data from an external API or performing a complex database query. Because you can run any code, custom actions offer maximum flexibility.\nKeep Logic Out of Custom Actions and Inside Flows\nYou should avoid hiding your core business logic inside a custom action. Flows (in YAML or via the Studio UI) define how the conversation should proceed in a transparent, maintainable way. A custom action should do just the \u201craw work\u201d\u2014for example, fetching an API response or returning a database record\u2014and let your flow decide what happens next based on that result.\n**Example of \u201cflow-first\u201d design** :\nflows.yml\n    \n    \n```\nflows:  \n restaurant_booking:  \n description: \"Book a table at a restaurant\"  \n steps:  \n ///# ...  \n - action: check_restaurant_availability  \n next:  \n - if: has_availability  \n then:  \n - action: utter_has_availability  \n - else:  \n - action: utter_no_availability  \n```\nactions.py\n    \n    \n```\n///# Minimal custom action code  \nclass CheckRestaurantAvailability(Action):  \n def name(self):  \n return \"check_restaurant_availability\"  \n  \ndef run(self, dispatcher, tracker, domain):  \n ///# Example: call an API to see if there's availability  \n has_availability = True  \n ///# Return the result in a slot so the flow can branch deterministically  \n return [SlotSet(\"has_availability\", has_availability)]  \n```\nBy keeping the branching logic in the flow, anyone inspecting it can quickly understand how your assistant behaves.\n## Rasa Action Server\u200b\nWhen your assistant predicts a custom action, it needs to run your custom code. You can do this in two ways:\n  1. **Use a standalone Action Server**\n    * The Rasa server calls the Action Server with information about the conversation.\n    * The Action Server executes your code and returns any responses or events to Rasa.\n    * This keeps your custom code isolated from the main assistant server (helpful for security or scaling).\n  2. **Run custom actions directly on the Rasa Assistant**\n    * Write your custom actions in Python and configure them to run directly in the same process as the assistant.\n    * This may simplify deployment and reduce latency but requires that your Rasa environment be set up securely to handle sensitive credentials.\nRun custom actions directly on the Rasa Assistant if you want simpler deployment, lower latency, and a unified environment for faster development. However, if you need to secure sensitive credentials or prefer isolating resource-intensive components, an external action server gives you greater flexibility, control, and security.\nFor more details on either approach, see the Reference section on the [Action Server](/docs/pro/build/custom-actions??) and [Custom Actions](/docs/reference/primitives/custom-actions).",
    "title": "Writing Custom Actions",
    "url": "https://rasa.com/docs/pro/build/custom-actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "* **Send messages** : Send messages directly back to the user through the dispatcher (note: we recommend to leverage responses rather than using this method for better validation support)\n#### Example\u200b\nIn this example, the assistant supports the user in booking a restaurant. It first asks for some details about the user's preference and then uses that input to query an API for availability based on the user's preferences. The custom action might look something like this:\n  * Pro\n  * Studio\nactions.py\n    \n    \n```\nfrom typing import Any, Text, Dict, List  \nfrom rasa_sdk import Action, Tracker  \nfrom rasa_sdk.executor import CollectingDispatcher  \n  \nclass ActionCheckRestaurants(Action):  \n def name(self) -> Text:  \n return \"action_check_restaurants\"  \n  \n def run(self, dispatcher: CollectingDispatcher,  \n tracker: Tracker,  \n domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:  \n   \n cuisine = tracker.get_slot('cuisine') ///# Get what cuisine the user wants from the tracker  \n results = search_database(cuisine) ///# Do something with that information  \n return [SlotSet(\"matches\", results)] ///# Store the results in a slot  \n```\nYou can also reference actions in the Studio flow builder:\n### Storing response values\u200b",
    "title": "Custom Actions in Rasa",
    "url": "https://rasa.com/docs/learn/guides/adding-custom-actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "This configuration is mutually exclusive with the `url` field, which you would typically use for pointing to an external Action Server. If both `url` and `actions_module` are specified, `actions_module` will be prioritized.\ninfo\nEvery time you update the custom actions code, you must restart the Rasa Assistant to reflect the changes via the `rasa run` or `rasa inspect` commands.",
    "title": "Custom Actions",
    "url": "https://rasa.com/docs/reference/primitives/custom-actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Actions | Rasa Documentation\n# Actions\nThe `Action` class is the base class for any custom action. To define a custom action, create a subclass of the `Action` class and overwrite the two required methods, `name` and `run`. The action server will call an action according to the return value of its `name` method when it receives a request to run an action.\nA skeleton custom action looks like this:\n    \n    \n```\nclass MyCustomAction(Action):  \n  \n def name(self) -> Text:  \n  \n return \"action_name\"  \n  \n async def run(  \n self, dispatcher, tracker: Tracker, domain: Dict[Text, Any],  \n ) -> List[Dict[Text, Any]]:  \n  \n return []  \n```\n## Methods\u200b\n### Action.name\u200b\nDefines the action's name. The name returned by this method is the one used in your bot's domain.\n  * **Returns** :\nName of action\n  * **Return type** :\n`str`\n### Action.run\u200b\n    \n    \n```\nasync Action.run(dispatcher, tracker, domain)  \n```\nThe `run` method executes the side effects of the action.\n#### **Parameters**\u200b\n  * **dispatcher** \u2013 the dispatcher which is used to send messages back to the user. Use `dispatcher.utter_message()` or any other `rasa_sdk.executor.CollectingDispatcher` method. See the [documentation for the dispatcher](/docs/reference/integrations/action-server/sdk-dispatcher)\n  * **tracker** \u2013 the state tracker for the current user. You can access slot values using `tracker.get_slot(slot_name)`, the most recent user message is `tracker.latest_message.text` and any other `rasa_sdk.Tracker` property. See the [documentation for the tracker](/docs/reference/integrations/action-server/sdk-tracker).\n  * **domain** \u2013 the bot's domain\n#### **Returns**\u200b\nA list of `rasa_sdk.events.Event` instances. See the [documentation for events](/docs/reference/integrations/action-server/sdk-events).\n#### **Return type**\u200b\n`List`[`Dict`[`str`, `Any`]]\n## Example\u200b",
    "title": "Actions",
    "url": "https://rasa.com/docs/reference/integrations/action-server/sdk-actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Rasa Tutorial | Rasa Documentation\n# Rasa Tutorial\n **Welcome!** In this tutorial, you'll learn how to build a reliable, scalable AI agent using **CALM** , Rasa's LLM-powered dialogue engine. You\u2019ll define a simple process (called a _flow_ in Rasa), and see first-hand how [**Process Calling**](https://rasa.com/blog/process-calling-agentic-tools-need-state/) with **Conversation Patterns** enable you to build steerable conversational experiences, without the risks of ungrounded LLM reasoning and answer generation.\n## What are you building?\u200b\nIn this tutorial, you will build an LLM-powered assistant that can complete a money transfer, reliably executing your business logic while allowing for fluid conversation.\nHere are some of the conversations your assistant will be able to handle, just by defining the money transfer process:\n  * Happy path\n  * All at once\n  * Change of mind\nUser: I want to send money\nBot: Who would you like to send money to?\nUser: to Jen\nBot: How much would you like to send?\nUser: $50\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: yes\nBot: All done. $50.0 has been sent to Jen.\nBot: Is there anything else I can help you with?!\nhappy path\nUser: I want to send 100 dollars to Joe\nBot: \nPlease confirm: you want to transfer $100.0 to Joe?\nUser: yes.\nBot: All done. $100.00 has been sent to Joe.\nBot: Is there anything else I can help you with?\nAll info given\nUser: I need to send $50\nBot: Who would you like to send money to?\nUser: Jen\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: actually no 60\nBot: Ok, I corrected the amount.\nBot: \nPlease confirm: you want to transfer $60.0 to Jen?\nUser: yes.\nBot: All done. $60.00 has been sent to Jen.\nBot: Is there anything else I can help you with?\nChange of mind\n## Following This Tutorial\u200b\nYou'll need a free Rasa [Developer Edition license](/docs/pro/intro)",
    "title": "Rasa Tutorial",
    "url": "https://rasa.com/docs/pro/tutorial",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Actions | Rasa Documentation\n# Actions\n## Responses\u200b\nA [response](/docs/reference/primitives/responses) is a message the assistant will send back to the user. This is the action you will use most often, when you want the assistant to send text, images, buttons or similar to the user.\n## Custom Actions\u200b\nA [custom action](/docs/reference/primitives/custom-actions) is an action that can run any code you want. This can be used to make an API call, or to query a database for example.\n## Default Actions\u200b\n[Default actions](/docs/reference/primitives/default-actions) are actions that are built into the dialogue manager by default. Most of these are automatically predicted based on certain conversation situations. You may want to customize these to personalize your assistant.",
    "title": "Actions",
    "url": "https://rasa.com/docs/reference/primitives/actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "A step with a `collect` key instructs your assistant to request information from the user to fill a slot. For example:\n    \n    \n```\n- collect: account_type ///# slot name  \n```\nYour assistant will not proceed to the next step in the flow until the slot `account_type` has been filled. See the [tutorial](/docs/pro/tutorial#collecting-information-in-slots) for more information about slot filling and defining slots in your domain file.\nInstead of a `response` you can also define a [custom action](/docs/reference/primitives/custom-actions) called `action_ask_recipient` to phrase the question along with, for example, some buttons to the user. Make sure to add the custom action to your domain file.\ndomain.yml\n    \n    \n```\nactions:  \n - action_ask_recipient  \n```\ninfo\nYou can define either a `response` or a `custom action` for your collect step. It is not possible to define both. A validation error will be thrown by Rasa if both are defined.\n#### Slot Descriptions\u200b\nAn optional `description` field can be added to the `collect` step to guide the language model in extracting slot values.\n    \n    \n```\n- collect: account_type  \n description: \"Account type is one of checking, savings, money market, or IRA.\"  \n```\ninfo\nThe description field can be used to perform slot validation:\n    \n    \n```\n- collect: zip_code  \n description: |  \n A US postal code, having either 5 or 9 digits.  \n For example, \"60613\" or \"60613-1060\".  \n```\n#### Always Asking Questions\u200b",
    "title": "Business Logic with Flows",
    "url": "https://rasa.com/docs/reference/primitives/flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "For purely language-level customization (i.e., to keep brand voice consistent), consider using the Response Rephraser to automatically adapt the text in the pattern\u2019s default responses. You can find more information on customizing the tone of your assistant [here](/docs/pro/customize/assistant-tone).\n## How to Customise Patterns\u200b\n### 1\\. Override a Pattern Flow\u200b\nTo customise a pattern, create a flow in your `flows.yml` file **with the same name** as the pattern. For instance, if you want to change how a cancellation is handled, create a flow named `pattern_cancel_flow`:\nflows.yml\n    \n    \n```\nflows:  \n pattern_cancel_flow:  \n description: Custom cancellation flow  \n steps:  \n - action: action_cancel_flow  \n - action: utter_flow_cancelled_rasa  \n```\nWhen your assistant sees a user cancellation, it will **use your new`pattern_cancel_flow`** instead of the default one.\nFor existing default pattern implementations see to the Reference section on [Patterns](/docs/reference/primitives/patterns#reference-default-pattern-configuration).\n_Keep pattern overrides concise. Most patterns interrupt an ongoing flow, so it\u2019s best to return the user to the main conversation quickly._\n### 2\\. Override Default Actions or Responses\u200b\nSome patterns make use of **default actions** , like `action_correct_flow_slot` or `action_trigger_chitchat`. If you need more control over the logic:\n  1. Create a custom action in your `actions.py`.\n  2. Reference it in your custom pattern flow and your `domain.yml`.\nLikewise, the default text responses are in your domain\u2019s `responses:` section. Override them with your own text or tie them into the Rephraser if needed.",
    "title": "Customizing Patterns",
    "url": "https://rasa.com/docs/pro/customize/patterns",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Introduction to Rasa Action Server | Rasa Documentation\n# Introduction to Rasa Action Server\nA Rasa action server runs [custom actions](/docs/reference/primitives/custom-actions) for a Rasa conversational assistant.\n## How it works\u200b\nWhen your assistant predicts a custom action, the Rasa server sends a `POST` request to the action server with a json payload including the name of the predicted action, the conversation ID, the contents of the tracker and the contents of the domain.\nWhen the action server finishes running a custom action, it returns a json payload of [responses](/docs/reference/primitives/responses) and [events](/docs/reference/integrations/action-server/events). See the [API spec](/docs/reference/api/pro/action-server-api) for details about the request and response payloads.\nThe Rasa server then returns the responses to the user and adds the events to the conversation tracker.\nTo optimise the network traffic, the rasa server will not send a domain with each request to the action server. Instead, it will first send the digest of the domain to the action server and if action server does not have the domain with the given digest cached, it will reply to the action server with code 449 (HTTP retry) or in case of gRPC it will send error code NOT_FOUND and in the details it will outline that domain was not found. This indicates that the rasa server must resend the request with domain included. [See more](/docs/reference/integrations/action-server/actions#domain_digest).\n## SDKs for Custom Actions\u200b\nYou can use an action server written in any language to run your custom actions, as long as it implements the [required APIs](/docs/reference/api/pro/action-server-api).\n### Rasa SDK (Python)\u200b\n\nRasa SDK is a Python SDK for running custom actions. Besides implementing the required APIs, it offers methods for interacting with the conversation tracker and composing events and responses. If you don't yet have an action server and don't need it to be in a language other than Python, using the Rasa SDK will be the easiest way to get started.\n### Other Action Servers\u200b\nIf you have legacy code or existing business logic in another language, you may not want to use the Rasa SDK. In this case you can write your own action server in any language you want. The only requirement for the action server is that it provide a `/webhook` endpoint which accepts HTTP `POST` requests from the Rasa server and returns a payload of [events](/docs/reference/integrations/action-server/events) and responses. See the [API spec](/docs/reference/api/pro/action-server-api) for details about the required `/webhook` endpoint.\n### Running Custom Actions Directly by the Assistant\u200b\nFor users looking to streamline their architecture by eliminating the need for an Action Server, you can explore how to run custom actions directly on the Rasa Assistant by following the guidelines [here](/docs/reference/primitives/custom-actions#running-custom-actions-directly-by-the-assistant).",
    "title": "Introduction to Rasa Action Server",
    "url": "https://rasa.com/docs/action-server",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Actions | Rasa Documentation\n# Actions\nWhen a Rasa assistant calls a custom action, it sends a request to the action server. Rasa only knows about whatever events and responses come back in the request response; it's up to the action server to call the correct code based on the action name that Rasa provides.\nTo better understand what happens when Rasa calls a custom action, consider the following example:\nYou have deployed a weather bot to both Facebook and Slack. The user can ask for the weather with the intent `ask_weather`. There is a slot `location` which will be filled if the user has specified a location. The action `action_tell_weather` will use an API to get the weather forecast , using a default location if the user doesn't specify one. The action will set the `temperature` to the maximum temperature of the weather forecast. The message returned will differ according to the channel they are using.\n## Protocols supported by the action server\u200b\nAction server supports two protocols for communication with Rasa server:\n  * HTTP API\n  * gRPC\n### HTTP(S) Protocol\u200b\nAPI specification for HTTP protocol can be found [here](/docs/reference/api/pro/action-server-api).\nCompressed body in HTTP requests\nRasa has the capability to compress the HTTP request body for custom actions. By default, this option is off to keep backward compatibility with older versions of custom action servers which did not receive the compressed body in the HTTP request for custom actions. To enable this option, set environment variable COMPRESS_ACTION_SERVER_REQUEST to `True`.\nRasa SDK versions `3.2.2`, `3.3.1`, `3.4.1` and upwards, support both compressed and non-compressed body in the HTTP request for running custom action server. There is no additional setup required.\n#### HTTP Protocol\u200b\n\nTo connect to the action server using the HTTP protocol, you need to set protocol schema to `http` in the `url` of the `action_endpoint` in your `endpoints.yml` file:\n    \n    \n```\naction_endpoint:  \n url: \"http://localhost:5055/webhook\"  \n```\nWhen using the HTTP protocol, make sure that [the action server is started with HTTP enabled](/docs/reference/integrations/action-server/running-action-server#http-protocol).\n#### HTTPS Protocol\u200b\nTo use the HTTPS protocol to connect to action server, set the protocol schema to `https` in the `url` of the `action_endpoint` and provide CA certificate in `cafile` field in your `endpoints.yml` file:\n    \n    \n```\naction_endpoint:  \n url: \"https://localhost:5055/webhook\"  \n cafile: \"/path/to/ssl_ca_certificate\"  \n```\nWhen using the HTTPS protocol, make sure that:\n  * [the action server is started with HTTPS enabled](/docs/reference/integrations/action-server/running-action-server#https-protocol)\n  * the certificate is signed by a trusted CA\n  * the server certificate has a list of hosts set correctly\n### GRPC Protocol\u200b\nNew in 3.9\nAPI specification for gRPC protocol can be found [here](/docs/reference/integrations/action-server/action-server-grpc-api). Data schema for gRPC protocol is closely aligned with the HTTP protocol.\nWe use compression by default in gRPC protocol. It cannot be disabled.\nWe support both secure (TLS) and insecure gRPC connections.\n#### Insecure gRPC connection\u200b\nTo connect to the action server over insecure gRPC connection, you need to set the protocol schema to `grpc` in the `url` field of the `action_endpoint` in your `endpoints.yml` file:\n    \n    \n```\naction_endpoint:  \n url: \"grpc://localhost:5055\"  \n```\n\nWhen using an insecure gRPC connection, make sure that [the action server is started with insecure connection enabled](/docs/reference/integrations/action-server/running-action-server#insecure-grpc-connection).\n#### Secure (TLS) gRPC connection\u200b\nTo connect to the action server over a secure gRPC connection, you need to provide the path to the SSL CA certificate, in the `cafile` field in your `endpoints.yml` file:\n    \n    \n```\naction_endpoint:  \n url: \"grpc://localhost:5055\"  \n cafile: \"/path/to/ssl_ca_certificate\"  \n```\nWhen using a secure gRPC connection, make sure that:\n  * [the action server is started with secure connection enabled](/docs/reference/integrations/action-server/running-action-server#secure-grpc-connection)\n  * the certificate is signed by a trusted CA\n  * the server certificate has list of hosts set correctly\n## Custom Action Input\u200b\nNote: HTTP protocol is used in the example below. The input format for gRPC protocol follows a similar data layout. For example, the json payload below can be serialized to the gRPC request object and send it to the action server over gRPC protocol.\n  * Input Layout\n  * JSON Example\nYour action server receives the following payload from the Rasa server:\nSome fields in the payload are optional and may not be present in all requests. Fields marked as `object` have a very complex structure and are not shown here.\n    \n    \n```\n///# pseudo code  \nrequest {  \n next_action: { type: string }  \n sender_id: { type: string }  \n tracker: { type: object }  \n domain: { type: optional[object] }  \n domain_digest: { type: optonal[string] }  \n version: { type: string }  \n}  \n  \ndomain {  \n config: { type: object }  \n session_config: { type: object }  \n intents: { type: object }  \n entities: { type: object }  \n slots: { type: object }  \n responses: { type: object }  \n actions: { type: object }  \nforms: { type: object }  \n e2e_actions: { type: object }  \n}  \n  \ntracker {  \n sender_id: { type: string }  \n slots: { type: object }  \n latest_message: { type: object }  \n events: { type: array_of_objects }  \n paused: { type: bool }  \n followup_action: { type: optional[string] }  \n active_loop: { type: map }  \n latest_action_name: { type: string }  \n stack: { type: array_of_objects }  \n}  \n```\n    \n    \n```\n {  \n \"next_action\": \"action_tell_weather\",  \n \"sender_id\": \"2687378567977106\",  \n \"tracker\": {  \n \"sender_id\": \"2687378567977106\",  \n \"slots\": {  \n \"location\": null,  \n \"temperature\": null  \n },  \n \"latest_message\": {  \n \"text\": \"/ask_weather\",  \n \"intent\": {  \n \"name\": \"ask_weather\",  \n \"confidence\": 1  \n },  \n \"intent_ranking\": [  \n {  \n \"name\": \"ask_weather\",  \n \"confidence\": 1  \n }  \n ],  \n \"entities\": []  \n },  \n \"followup_action\": null,  \n \"paused\": false,  \n \"events\": [  \n {  \n \"event\": \"action\",  \n \"timestamp\": 1599850576.654908,  \n \"name\": \"action_session_start\",  \n \"policy\": null,  \n \"confidence\": null  \n },  \n {  \n \"event\": \"session_started\",  \n \"timestamp\": 1599850576.654916  \n },  \n {  \n \"event\": \"action\",  \n \"timestamp\": 1599850576.654928,  \n \"name\": \"action_listen\",  \n \"policy\": null,  \n \"confidence\": null  \n },  \n {  \n \"event\": \"user\",  \n \"timestamp\": 1599850576.655345,  \n \"text\": \"/ask_weather\",  \n \"parse_data\": {  \n \"text\": \"/ask_weather\",  \n \"intent\": {  \n \"name\": \"ask_weather\",  \n \"confidence\": 1  \n },  \n \"intent_ranking\": [  \n {  \n \"name\": \"ask_weather\",  \n \"confidence\": 1  \n }  \n ],  \n \"entities\": []  \n },  \n \"input_channel\": \"facebook\",  \n \"message_id\": \"3f2f2317dada4908b7a841fd3eab6bf9\",  \n \"metadata\": {}  \n }  \n ],  \n \"active_form\": {},  \n \"latest_action_name\": \"action_listen\"  \n },  \n \"domain\": {  \n\"config\": {  \n \"store_entities_as_slots\": true  \n },  \n \"session_config\": {  \n \"session_expiration_time\": 60,  \n \"carry_over_slots_to_new_session\": true  \n },  \n \"intents\": [  \n {  \n \"greet\": {  \n \"use_entities\": true  \n }  \n },  \n {  \n \"ask_weather\": {  \n \"use_entities\": true  \n }  \n }  \n ],  \n \"entities\": [],  \n \"slots\": {  \n \"location\": {  \n \"type\": \"rasa.core.slots.UnfeaturizedSlot\",  \n \"initial_value\": null,  \n \"auto_fill\": true  \n },  \n \"temperature\": {  \n \"type\": \"rasa.core.slots.UnfeaturizedSlot\",  \n \"initial_value\": null,  \n \"auto_fill\": true  \n }  \n },  \n \"responses\": {  \n \"utter_greet\": [  \n {  \n \"text\": \"Hey! How are you?\"  \n }  \n ]  \n },  \n \"actions\": [\"action_tell_weather\", \"utter_greet\"],  \n \"forms\": []  \n },  \n \"version\": \"2.0.0\"  \n }  \n```\n## Fields in the payload\u200b\nFollowing is the description of the fields in the payload.\n### `next_action`\u200b\nThe `next_action` field tells your action server what action to run. Your actions don't have to be implemented as classes, but they do have to be callable by name.\nIn the example case, your action server should run the action `action_tell_weather`.\n### `sender_id`\u200b\nThe `sender_id` tells you the unique ID of the user having the conversation. Its format varies according to the input channel. What it tells you about the user also depends on the input channel and how the user is identified by the channel.\nIn the example case, the `sender_id` is not used for anything.\n### `tracker`\u200b\nThe `tracker` contains information about the conversation, including a history of events and a record of all slots:\n  * `sender_id`: The same `sender_id` as is available in the top level of the payload\n  * `slots`: Each slot in your bot's domain and its value at the current time\n\n  * `latest_message`: The attributes of the latest message\n  * `followup_action`: The action called was a forced follow up action\n  * `paused`: Whether the conversation is currently paused\n  * `events`: A list of all previous [events](/docs/reference/integrations/action-server/events)\n  * `active_loop`: The name of the currently active form, if any\n  * `active_form`: (Deprecated, replaced by `active_loop`) The name of the currently active form, if any\n  * `latest_action_name`: The name of the last action the bot executed\n  * `stack`: Current dialogue stack\nIn the example case, your custom action uses the value of the `location` slot (if it is set) to get the weather forecast.\n### `domain`\u200b\nThe `domain` is a json representation of your `domain.yaml` file. It is unlikely that a custom action will refer to its contents, as they are static and do not indicate the state of the conversation.\nYou can control if an action should receive a domain or not. Visit [selective-domain](/docs/reference/config/domain#select-which-actions-should-receive-domain)\nCaching the domain object for improved performance\nFrom version `3.9.0` onwards, Rasa action server caches the domain object in the action server. This is done to avoid sending the domain object over the network for every request. Check the `domain_digest` field to learn more about the domain file used to generate the domain object.\n### `domain_digest`\u200b\nUsed to check if the cached domain object in the action server is up-to-date. Contains the name of the trained model file which is loaded by Rasa.\n\nStarting from version `3.9.0`, Rasa SDK caches the domain object in the action server, so that it does not need to be sent with every request. To make sure that the action server is aware of the latest domain changes, you can send the `domain_digest` field in the request. Alongside `domain_digest`, you can also send the domain object in the request. The action server will compare the digest with the one it has cached. In case the digests (the one retained in Action server and the one sent over network) do not match, the Action server will act as follows:\n  * If `domain` was not sent in the request, it will respond with a `RETRY (449)` response code in case of HTTP protocol or a `NOT_FOUND` error code with `DOMAIN_NOT_FOUND` error detail in case of gRPC protocol. In the next request, Rasa server will send the domain object.\n  * If `domain` was sent in the request, the action server will update the cached domain object with the new domain object sent in the request.\n### `version`\u200b\nThis is the version of the Rasa server. A custom action is also unlikely to refer to this, although you might use it in a verification step if your action server is only compatible with certain Rasa versions.\n## Custom Action Output\u200b\nThe Rasa server expects a dictionary of `events` and `responses` as a response to a custom action call.\n### `events`\u200b",
    "title": "Actions",
    "url": "https://rasa.com/docs/reference/integrations/action-server/actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  }
]