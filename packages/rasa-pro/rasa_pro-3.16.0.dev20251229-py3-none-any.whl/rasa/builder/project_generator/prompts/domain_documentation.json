[
  {
    "content": "Domain | Rasa Documentation\n# Domain\nIn Rasa, your `domain` defines the universe in which your assistant operates. Specifically, it lists:\n  * The `responses` that can be used as templated messages to send to a user.\n  * The custom `actions` that can be predicted by dialogue policies.\n  * The `slots` that act as your assistant's memory throughout a conversation.\n  * Session configuration parameters including inactivity timeout.\nIf you are building an NLU-based assistant, refer to the [Domain documentation](https://legacy-docs-oss.rasa.com/docs/rasa/domain) to see how intents, entities, slot mappings, and slot featurization can be configured in your domain.\n## Multiple Domain Files\u200b\nThe domain can be defined as a single YAML file or split across multiple files in a directory. When split across multiple files, the domain contents will be read and automatically merged together. You can also manage your responses, slots, custom actions in [Rasa Studio](/docs/studio/intro).\nUsing the [command line interface](/docs/reference/api/command-line-interface#rasa-train), you can train a model with split domain files by running:\n    \n    \n```\nrasa train --domain path_to_domain_directory  \n```\n## Responses\u200b\nResponses are templated messages that your assistant can send to your user. Responses can contain rich content like buttons, images, and custom json payloads. Every response is also an action, meaning that it can be used directly in an `action` step in a flow. Responses can be defined directly in the domain file under the `responses` key. For more information on responses and how to define them, see [Responses](/docs/reference/primitives/responses).\n## Actions\u200b\n[Actions](/docs/reference/primitives/actions) are the things your bot can do. For example, an action could:\n  * respond to a user,\n  * make an external API call,\n  * query a database, or\n  * just about anything!\n\nAll [custom actions](/docs/reference/primitives/custom-actions) should be listed in your domain.\nRasa also has [default actions](/docs/reference/primitives/default-actions) which you do not need to list in your domain.\n## Slots\u200b\nSlots are your assistant's memory. They act as a key-value store which can be used to store information the user provided (e.g. their home city) as well as information gathered about the outside world (e.g. the result of a database query). Check out the [Slots reference](/docs/reference/primitives/slots) for more information.\n## Session configuration\u200b\nA conversation session represents the dialogue between the assistant and the user. Conversation sessions can begin in three ways:\n  1. the user begins the conversation with the assistant,\n  2. the user sends their first message after a configurable period of inactivity, or\n  3. a manual session start is triggered with the `/session_start` intent message.\nYou can define the period of inactivity after which a new conversation session is triggered in the domain under the `session_config` key.\nAvailable parameters are:\n  * `session_expiration_time` defines the time of inactivity in minutes after which a new session will begin.\n  * `carry_over_slots_to_new_session` determines whether existing set slots should be carried over to new sessions.\nThe default session configuration looks as follows:\n    \n    \n```\nsession_config:  \n session_expiration_time: 60 ///# value in minutes, 0 means infinitely long  \n carry_over_slots_to_new_session: true ///# set to false to forget slots between sessions  \n```",
    "title": "Domain",
    "url": "https://rasa.com/docs/reference/config/domain",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Assistant Memory (Slots) | Rasa Documentation\n# Assistant Memory (Slots)\nIn a conversational experience, context matters just as much as the latest user message. Information derived either from the situational context, user profiles or user provided information\u2014like a user\u2019s age, an appointment date, or a selected product\u2014often influences how the assistant behaves later on.\n**Slots** provide this memory in CALM. They preserve data about the user or the external world so that your assistant can leverage it for business logic, personalization, or simply to maintain continuity. If a user provides their email address once, you don\u2019t want them to repeat it in every subsequent interaction. Slots let you store that information and use it across the entire conversation.\nSlots in CALM are key-value pairs that represent stateful information your assistant has collected or inferred. Each slot has:\n  * A **name** (e.g., `phone_number` or `user_name`)\n  * A **type** (e.g., `text`, `boolean`, `categorical`, etc.)\n  * (Optionally) a **default** or **initial** value\nCALM primarily depends on an [LLM-based **Command Generator**](/docs/reference/config/components/llm-command-generators) to decide what to do next\u2014 **including** issuing commands that set slot values. However, you can still configure slot mappings to rely on an NLU pipeline if you choose to combine NLU-based extraction with CALM. In that case, the `NLUCommandAdapter` can issue `set slot` commands based on extracted entities or intents.\nWhen building flows, you\u2019ll often see [collect steps](/docs/reference/primitives/flows#collect) that explicitly request slot values from users. But at any point in the conversation, the LLM can also set or update slots\u2014if you permit it via the slot\u2019s configuration.\n## How to Write Slots\u200b\n\nSlots are defined in your **domain** file under the `slots:` key. Each slot entry includes at least:\n  * The slot **name**\n  * The slot **type** (e.g., `text`, `bool`, `float`, `categorical`, `any`, etc.)\n  * (Optionally) `mappings` that specify how the slot should be filled\nBelow is a minimal example of a slot definition using LLM-based filling:\ndomain.yml\n    \n    \n```\nslots:  \n user_name:  \n type: text  \n mappings:  \n - type: from_llm  \n```\nIn this example:\n  * `user_name` is a `text` slot.\n  * It will be **filled by the LLM** at any point in the conversation, if the LLM issues the correct `set slot` command.\nYou can also combine an NLU pipeline (for classic intent/entity extraction) with CALM by giving the slot an NLU-based mapping as well, for example:\ndomain.yml\n    \n    \n```\nslots:  \n user_name:  \n type: text  \n mappings:  \n - type: from_entity  \n entity: person  \n - type: from_llm  \n```\nIn this case, the `NLUCommandAdapter` uses the recognized `person` entity to set the `user_name` slot. However, if no value is extracted for the `person` entity, then the LLM gets a chance to issue a value for it.\nYou can read more [here](/docs/reference/primitives/slots#impact-of-slot-mappings-in-different-scenarios) about how a combination of NLU-based extractors and LLMs can be used to efficiently extract slots.\n### Defining Slots in Flows\u200b\nWithin a flow, you often collect slot values using the `collect` step:\nflows.yml\n    \n    \n```\nflows:  \n my_flow:  \n description: My flow  \n steps:  \n ///# ...  \n - collect: user_name  \n description: \"The user\u2019s full name\"  \n```\nThis step instructs the LLM that you want to retrieve `user_name` from the user. If the user\u2019s response is accepted, the LLM issues a `set slot` command, and `user_name` gets stored in the conversation state.\n## How Does Slot Validation Work in CALM?\u200b\n\nSlot validation ensures that the values you store are meaningful or properly formatted for your use case. CALM offers three paths for validating slots:\n  1. **Global slot validation defined on a domain level**\nDomain-level slot validation lives in the domain.yml file under each slot definition and it enforces universal, technical constraints (e.g., correct formatting, correct data type) whenever a slot is set or updated during the conversation, which ensures that if the user or the LLM tries to set a slot that doesn\u2019t meet the condition, the assistant rejects it right away\u2014before continuing the conversation. This behaviour is controlled by the `refill_utter` property.\nExample:\ndomain.yml\n    \n    \n```\n slots:  \n phone_number:  \n type: text  \n mappings:  \n - type: from_llm  \n validation:  \n rejections:  \n - if: not (slots.phone_number matches \"^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$\")  \n utter: utter_invalid_phone_number  \n refill_utter: \"utter_refill_phone_number\"  \n```\nThis domain-level validation is strictly for basic data correctness\u2014things like format, range, or type checks. It\u2019s not meant to handle more advanced, contextual logic (like checking if the phone number is already associated with an account in your database).\n  2. **Lightweight validations with rejections on a flow-level**\nIn the flow\u2019s `collect` step, you can define `rejections` that check the format or basic conditions on the extracted slot value. If the condition is not met, the assistant rejects the slot value and prompts the user again.\nflows.yml\n    \n```\nflows:  \n my_flow:  \n description: My flow  \n steps:  \n ///# ...  \n - collect: phone_number  \n description: \"User's phone number in (xxx) xxx-xxxx format\"  \n rejections:  \n - if: not ( slots.phone_number matches \"^\\([0-9]{3}\\) [0-9]{3}-[0-9]{4}$\" )  \n utter: utter_invalid_phone_number  \n```",
    "title": "Assistant Memory (Slots)",
    "url": "https://rasa.com/docs/pro/build/assistant-memory",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "The description field can be used to perform slot validation:\n    \n    \n```\n- collect: zip_code  \n description: |  \n A US postal code, having either 5 or 9 digits.  \n For example, \"60613\" or \"60613-1060\".  \n```\n#### Always Asking Questions\u200b\nBy default, a `collect` step is skipped if the corresponding slot is already filled. If a `collect` step should always be asked, no matter if the underlying slot is already filled, you can set `ask_before_filling: true` on the `collect` step:\n    \n    \n```\n- collect: final_confirmation # slot name  \n ask_before_filling: true  \n```\nIf the \"final_confirmation\" slot is already filled, the assistant will clear it and proceed to ask the `collect` step, then fill the slot again. This ensures the confirmation `collect` step is always asked.\n#### Resetting slots at the End of a Flow\u200b\nBy default, all slots filled via `collect` steps are reset when a flow completes. Once the flow ends, the slot's value is either reset to `null` or to the slot's [initial value](/docs/reference/primitives/slots#initial-slot-values) (if provided in the domain file under `slots`).\nIf you want to retain the value of a slot after the flow completes, set the `reset_after_flow_ends` property to `false`. For example:\n    \n    \n```\n- collect: user_name  \n reset_after_flow_ends: false  \n```\nDeprecation Warning\nConfiguring `reset_after_flow_ends` in collect steps is deprecated in version `3.11.0` and will be removed in Rasa Pro `4.0.0`. Please use the `persisted_slots` property at the flow level instead.\nIn [coexistence mode](/docs/pro/calm-with-nlu/coexistence), this behavior has to be enforced by annotating the slot definition with the property [`shared_for_coexistence: True`](/docs/reference/primitives/slots#persistence-of-slots-during-coexistence).",
    "title": "Business Logic with Flows",
    "url": "https://rasa.com/docs/reference/primitives/flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Rasa Tutorial | Rasa Documentation\n# Rasa Tutorial\n **Welcome!** In this tutorial, you'll learn how to build a reliable, scalable AI agent using **CALM** , Rasa's LLM-powered dialogue engine. You\u2019ll define a simple process (called a _flow_ in Rasa), and see first-hand how [**Process Calling**](https://rasa.com/blog/process-calling-agentic-tools-need-state/) with **Conversation Patterns** enable you to build steerable conversational experiences, without the risks of ungrounded LLM reasoning and answer generation.\n## What are you building?\u200b\nIn this tutorial, you will build an LLM-powered assistant that can complete a money transfer, reliably executing your business logic while allowing for fluid conversation.\nHere are some of the conversations your assistant will be able to handle, just by defining the money transfer process:\n  * Happy path\n  * All at once\n  * Change of mind\nUser: I want to send money\nBot: Who would you like to send money to?\nUser: to Jen\nBot: How much would you like to send?\nUser: $50\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: yes\nBot: All done. $50.0 has been sent to Jen.\nBot: Is there anything else I can help you with?!\nhappy path\nUser: I want to send 100 dollars to Joe\nBot: \nPlease confirm: you want to transfer $100.0 to Joe?\nUser: yes.\nBot: All done. $100.00 has been sent to Joe.\nBot: Is there anything else I can help you with?\nAll info given\nUser: I need to send $50\nBot: Who would you like to send money to?\nUser: Jen\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: actually no 60\nBot: Ok, I corrected the amount.\nBot: \nPlease confirm: you want to transfer $60.0 to Jen?\nUser: yes.\nBot: All done. $60.00 has been sent to Jen.\nBot: Is there anything else I can help you with?\nChange of mind\n## Following This Tutorial\u200b\nYou'll need a free Rasa [Developer Edition license](/docs/pro/intro)\n\nRemember to replace `your-rasa-license-key` with the your actual license key.\n## Overview\u200b\nOpen up the project folder in your IDE to see the files that make up your new project. In this tutorial you will primarily work with the following files:\n  * `data/flows.yml`\n  * `domain.yml`\n  * `actions/actions.py`\n## Testing your money transfer flow\u200b\nAction Required\nTrain your assistant by running:\n    \n    \n```\nrasa train  \n```\nNow, try telling the assistant that you'd like to transfer some money to a friend. Start talking to it in the browser by running:\n    \n    \n```\nrasa inspect  \n```\ninfo\nWhen you run the `rasa inspect` command in a GitHub Codespace, you'll see a notification that your application is available on port 5005. Click 'Open in Browser' to access the inspector and start chatting. \ninfo\nThis template bot responds to chitchat by generating a response. If you want to disable this, delete the file `data/patterns.yml` and re-train.\n## Understanding your money transfer flow.\u200b\nThe file `data/flows.yml` contains the definition of a `flow` called `transfer_money`. Let's look at this definition to see what is going on:\nflows.yml\n    \n    \n```\nflows:  \n transfer_money:  \n description: Help users send money to friends and family.  \n steps:  \n - collect: recipient  \n - collect: amount  \n description: the number of US dollars to send  \n - action: utter_transfer_complete  \n```\n\n## Branching Logic\u200b\nSlots are also used to build branching logic in flows.\nAction Required\nYou're going to introduce an extra step to your flow, asking the user to confirm the amount and the recipient before sending the transfer. Since you are asking a yes/no question, you can store the result in a boolean `slot` which you will call `final_confirmation`.\nIn your domain file, add the definition of the `final_confirmation` slot and the corresponding response: `utter_ask_final_confirmation`. Also add a response to confirm the transfer has been cancelled.\ndomain.yml\n    \n    \n```\nslots:  \n recipient:  \n type: Text  \n mappings:  \n - type: from_llm  \n ///# ...  \n final_confirmation:  \n type: bool  \n mappings:  \n - type: from_llm  \n```\ndomain.yml\n    \n    \n```\nresponses:  \n utter_ask_recipient:  \n - text: \"Who would you like to send money to?\"  \n ///# ...  \n utter_ask_final_confirmation:  \n - text: \"Please confirm: you want to transfer {amount} to {recipient}?\"  \n utter_transfer_cancelled:  \n - text: \"Your transfer has been cancelled.\"  \n```\nNotice that your confirmation question uses curly brackets `{}` to include slot values in your response.",
    "title": "Rasa Tutorial",
    "url": "https://rasa.com/docs/pro/tutorial",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Writing Custom Actions | Rasa Documentation\n# Writing Custom Actions\nA Rasa assistant can execute different types of actions to respond to the user or update conversation state:\n  * **Responses** _User-facing messages_ defined in your assistant. This is what you will use most frequently to send text, images, buttons, etc.\n  * **Default Actions** _Built-in actions_ that handle certain events or conversation situations out-of-the-box (e.g., `action_restart`, `action_session_start`). These can be overridden with your own custom logic if needed.\n  * **Custom Actions** _User-defined actions_ that can run any code you want (e.g., call external APIs, query databases, or retrieve specific data). Custom actions are the focus of this page.\n## What Are Custom Actions?\u200b\nA **custom action** lets you execute arbitrary logic within your assistant\u2014for example, retrieving data from an external API or performing a complex database query. Because you can run any code, custom actions offer maximum flexibility.\nKeep Logic Out of Custom Actions and Inside Flows\nYou should avoid hiding your core business logic inside a custom action. Flows (in YAML or via the Studio UI) define how the conversation should proceed in a transparent, maintainable way. A custom action should do just the \u201craw work\u201d\u2014for example, fetching an API response or returning a database record\u2014and let your flow decide what happens next based on that result.\n**Example of \u201cflow-first\u201d design** :\nflows.yml\n    \n    \n```\nflows:  \n restaurant_booking:  \n description: \"Book a table at a restaurant\"  \n steps:  \n ///# ...  \n - action: check_restaurant_availability  \n next:  \n - if: has_availability  \n then:  \n - action: utter_has_availability  \n - else:  \n - action: utter_no_availability  \n```\nactions.py\n    \n    \n```\n///# Minimal custom action code  \nclass CheckRestaurantAvailability(Action):  \n def name(self):  \n return \"check_restaurant_availability\"",
    "title": "Writing Custom Actions",
    "url": "https://rasa.com/docs/pro/build/custom-actions",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Slots | Rasa Documentation\n# Slots\n## Slots\u200b\nSlots are your assistant's memory. They act as a key-value store which can be used to store information the user provided (e.g. their home city) as well as information gathered about the outside world (e.g. the result of a database query).\nSlots are defined in the slots section of your domain with their name, type and default value. Different slot types exist to restrict the possible values a slot can take.\nnote\nIf you decide to fill slots through [response buttons](/docs/reference/primitives/responses#buttons) where the [payload syntax](/docs/reference/primitives/responses#payload-syntax) issues `SetSlot` command(s), note that the slot name must not include certain characters such as `(`, `)`, `=` or `,`.\n### Slot Types\u200b\n#### Text Slot\u200b\nA text slot can take on any string value.\n  * **Example**\n    \n```\nslots:  \n cuisine:  \n type: text  \n```\n  * **Allowed Values**\nAny string\n#### Boolean Slot\u200b\nA boolean slot can only take on the values `true` or `false`. This is useful when you want to store a binary value.\n  * **Example**\n    \n```\nslots:  \n confirmation:  \n type: bool  \n```\n  * **Allowed Values**\n`true` or `false`\n#### Categorical Slot\u200b\nA categorical slot can only take on values from a predefined set. This is useful when you want to restrict the possible values a slot can take.\nIf the user provides a value where the casing does not match the casing of the values defined in the domain, the value will be coerced to the correct casing. For example, if the user provides the value `LOW` for a slot with values `low`, `medium`, `high`, the value will be converted to `low` and stored in the slot.\n\nWhen building an assistant with [CALM](/docs/learn/concepts/calm), you can configure slot filling to either use nlu-based predefined slot mappings or the newly introduced `from_llm` slot mapping type.\n#### NLU-based predefined slot mappings\u200b\nYou can continue using the [nlu-based predefined](https://legacy-docs-oss.rasa.com/docs/rasa/domain#slot-mappings) slot mappings such as [`from_entity`](https://legacy-docs-oss.rasa.com/docs/rasa/domain#from_entity) or [`from_intent`](https://legacy-docs-oss.rasa.com/docs/rasa/domain#from_intent) when building an assistant with CALM. In addition to including tokenizers, featurizers, intent classifiers, and entity extractors to your pipeline, you must also add the [`NLUCommandAdapter`](/docs/reference/config/components/nlu-command-adapter) to the `config.yml` file. The `NLUCommandAdapter` will match the output of the NLU pipeline (intents and entities) against the slot mappings defined in the domain file. If the slot mappings are satisfied, the `NLUCommandAdapter` will issue [`set slot` commands](/docs/reference/config/components/llm-command-generators#command-reference) to fill the slots.\nRecommendations\n  1. We recommend adding the [`FallbackClassifier`](https://legacy-docs-oss.rasa.com/docs/rasa/components#fallbackclassifier) to the nlu pipeline to guard against low confidence scores for intents when these are used in `from_intent` slot mappings.\nYou can define conditions for slot mappings to be satisfied before the slot is filled. The conditions are defined as a list of conditions under the `conditions` key. Each condition can specify the flow id that must be active to the `active_flow` property.\nThis is particularly useful if you define several slots mapped to the same entity, but you do not want to fill all of them when the entity is extracted.\nFor example:\n    \n    \n```\nentities:  \n- person  \n  \nslots:  \n first_name:  \n type: text  \n mappings:  \n - type: from_entity  \n entity: person  \n conditions:  \n - active_flow: greet_user  \n  \n last_name:  \n type: text  \n mappings:  \n - type: from_entity  \n entity: person  \n conditions:  \n - active_flow: issue_invoice  \n```\n#### Controlled Slot Mappings\u200b\nNew in 3.12\nThe `controlled` slot mapping type can be used to define slots that should be filled by a custom action, [response button payload](/docs/reference/primitives/responses#payload-syntax), or a [`set_slots` flow step](/docs/reference/primitives/flows#set-slots).\nYou can use the `controlled` mapping type to define slots that should be filled with values in a controlled manner. Slots that capture state or context necessary for the assistant to function are good examples of such slots.\nFor example:\n    \n    \n```\nslots:  \n is_logged_in:  \n type: bool  \n mappings:  \n - type: controlled  \n```\nSlots that only define the new `controlled` slot mapping will not be available to be filled by the NLU or LLM components. Note that this slot mapping can still be used alongside these other slot mapping types, however this comes with the risk of the slot being filled by the NLU or LLM components in a probabilistic manner.\nIn [Coexistence of NLU-based and CALM systems](/docs/pro/calm-with-nlu/migrating-from-nlu) the action [`action_reset_routing`](/docs/reference/primitives/default-actions#action_reset_routing) resets all slots and hides events from featurization for the NLU-based system policies to prevent them from seeing events that originated while CALM was active. However, you might want to share some slots that both CALM and the NLU-based system should be able to use. One use case for these slots are basic user profile slots. Both the NLU-based system and CALM should likely be able to know whether a user is logged in or not, what their username is, or what channel they are using. If you are storing this kind of data in slots you can annotate those slot definitions with the option `shared_for_coexistence: True`.\n    \n    \n```\nversion: \"3.1\"  \n  \nslots:  \n user_channel:  \n type: categorical  \n values:  \n - web  \n - teams  \n shared_for_coexistence: True  \n  \n user_name:  \n type: text  \n shared_for_coexistence: True  \n```\nIn the coexistence mode, if the option `shared_for_coexistence` is NOT set to `true`, it invalidates the [`reset_after_flow_ends: False` property](/docs/reference/primitives/flows#resetting-slots-at-the-end-of-a-flow) in the flow definition. In order for the slot value to be retained throughout the conversation, the `shared_for_coexistence` must be set to `true`.\n### Real-Time Slot validation\u200b\nNew in 3.12\nYou can now define validation rules that are strictly independent of business logic directly in the domain file. These rules enforce constraints on slot values when they are collected during the conversation in real time.\n\n  * **Regex Matching** : Validate inputs against specific patterns (e.g email addresses, phone numbers, zip codes, registration numbers, etc.)\n  * **Length Validation** : Ensure input text meets minimum and maximum length requirements (e.g usernames, passwords, IDs)\n  * **Data Type Validation** : Ensure inputs conform to specific type categories (integers only, numerical values, alphanumeric strings)\n  * **Range Checks** : For numerical inputs, verify that values fall within a specified range (e.g 18-65 for age, 1-100 for quantity, minimum/maximum thresholds)\n  * **Date Format Validation** : Validate date inputs against specific formats and logical constraints (e.g YYYY-MM-DD, no future birth dates)\n  * **List or Enumeration Matching** : Check if inputs match predefined valid options (e.g colors, sizes, categories)\n  * **Prefix/Suffix Checks** : Verify inputs begin or end with required characters or strings (e.g product codes, reference numbers)\n  * **Case Sensitivity Checks** : Ensure inputs follow case requirements (e.g lowercase usernames, uppercase codes)\n  * **Whitespace Validation** : Check for improper spacing patterns in inputs (e.g unwanted leading, trailing, or excessive internal spaces)\n  * **Special Character Filtering** : Restrict or validate special characters to maintain data integrity and security",
    "title": "Slots",
    "url": "https://rasa.com/docs/reference/primitives/slots",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Knowledge Base Actions | Rasa Documentation\n# Knowledge Base Actions\ncaution\nThis feature is experimental. We introduce experimental features to get feedback from our community, so we encourage you to try it out! However, the functionality might be changed or removed in the future. If you have feedback (positive or negative) please share it with us on the [forum](https://forum.rasa.com).\nA common problem in conversational AI is that users do not only refer to certain objects by their names, but also use reference terms such as \u201cthe first one\u201d or \u201cit\u201d. We need to keep track of the information that was presented to resolve these mentions to the correct object.\nIn addition, users may want to obtain detailed information about objects during a conversation \u2013 for example, whether a restaurant has outside seating, or how expensive it is. In order to respond to those user requests, knowledge about the restaurant domain is needed. Since the information is subject to change, hard-coding the information isn't the solution.\nTo handle the above challenges, Rasa can be integrated with knowledge bases. To use this integration, you can create a custom action that inherits from `ActionQueryKnowledgeBase`, a pre-written custom action that contains the logic to query a knowledge base for objects and their attributes.\nYou can find a complete example in `examples/knowledgebasebot` ([knowledge base bot](https://github.com/RasaHQ/rasa/tree/main/examples/knowledgebasebot/)), as well as instructions for implementing this custom action below.\n## Using `ActionQueryKnowledgeBase`\u200b\n### Create a Knowledge Base\u200b\n\nThe data used to answer the user's requests will be stored in a knowledge base. A knowledge base can be used to store complex data structures. We suggest you get started by using the `InMemoryKnowledgeBase`. Once you want to start working with a large amount of data, you can switch to a custom knowledge base (see [Creating Your Own Knowledge Base](/docs/reference/integrations/action-server/knowledge-bases#create-a-knowledge-base)).\nTo initialize an `InMemoryKnowledgeBase`, you need to provide the data in a json file. The following example contains data about restaurants and hotels. The json structure should contain a key for every object type, i.e. `\"restaurant\"` and `\"hotel\"`. Every object type maps to a list of objects \u2013 here we have a list of 3 restaurants and a list of 3 hotels.\n    \n    \n```\n{  \n \"restaurant\": [  \n {  \n \"id\": 0,  \n \"name\": \"Donath\",  \n \"cuisine\": \"Italian\",  \n \"outside-seating\": true,  \n \"price-range\": \"mid-range\"  \n },  \n {  \n \"id\": 1,  \n \"name\": \"Berlin Burrito Company\",  \n \"cuisine\": \"Mexican\",  \n \"outside-seating\": false,  \n \"price-range\": \"cheap\"  \n },  \n {  \n \"id\": 2,  \n \"name\": \"I due forni\",  \n \"cuisine\": \"Italian\",  \n \"outside-seating\": true,  \n \"price-range\": \"mid-range\"  \n }  \n ],  \n \"hotel\": [  \n {  \n \"id\": 0,  \n \"name\": \"Hilton\",  \n \"price-range\": \"expensive\",  \n \"breakfast-included\": true,  \n \"city\": \"Berlin\",  \n \"free-wifi\": true,  \n \"star-rating\": 5,  \n \"swimming-pool\": true  \n },  \n {  \n \"id\": 1,  \n \"name\": \"Hilton\",  \n \"price-range\": \"expensive\",  \n \"breakfast-included\": true,  \n \"city\": \"Frankfurt am Main\",  \n \"free-wifi\": true,  \n \"star-rating\": 4,  \n \"swimming-pool\": false  \n },  \n {  \n \"id\": 2,  \n \"name\": \"B&B\",  \n \"price-range\": \"mid-range\",  \n \"breakfast-included\": false,  \n \"city\": \"Berlin\",  \n \"free-wifi\": false,  \n \"star-rating\": 1,  \n \"swimming-pool\": false  \n }  \n ]  \n}  \n```\nOnce the data is defined in a json file, called, for example, `data.json`, you will be able use the this data file to create your `InMemoryKnowledgeBase`, which will be passed to the action that queries the knowledge base.\nEvery object in your knowledge base should have at least the `\"name\"` and `\"id\"` fields to use the default implementation. If it doesn't, you'll have to [customize your InMemoryKnowledgeBase](/docs/reference/integrations/action-server/knowledge-bases#customizing-the-inmemoryknowledgebase).\n### Define the NLU Data\u200b\nIn this section:\n  * we will introduce a new intent, `query_knowledge_base`\n  * we will annotate `mention` entities so that our model detects indirect mentions of objects like \u201cthe first one\u201d\n  * we will use [synonyms](/docs/reference/primitives/training-data-format#synonyms) extensively\nFor the bot to understand that the user wants to retrieve information from the knowledge base, you need to define a new intent. We will call it `query_knowledge_base`.\nWe can split requests that `ActionQueryKnowledgeBase` can handle into two categories: (1) the user wants to obtain a list of objects of a specific type, or (2) the user wants to know about a certain attribute of an object. The intent should contain lots of variations of both of these requests:\n    \n    \n```\nnlu:  \n- intent: query_knowledge_base  \n examples: |  \n - what [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"} can you recommend?  \n - list some [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"}  \n - can you name some [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"} please?  \n- can you show me some [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"} options  \n - list [German](cuisine) [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"}  \n - do you have any [mexican](cuisine) [restaurants]{\"entity\": \"object_type\", \"value\": \"restaurant\"}?  \n - do you know the [price range]{\"entity\": \"attribute\", \"value\": \"price-range\"} of [that one](mention)?  \n - what [cuisine](attribute) is [it](mention)?  \n - do you know what [cuisine](attribute) the [last one]{\"entity\": \"mention\", \"value\": \"LAST\"} has?  \n - does the [first one]{\"entity\": \"mention\", \"value\": \"1\"} have [outside seating]{\"entity\": \"attribute\", \"value\": \"outside-seating\"}?  \n - what is the [price range]{\"entity\": \"attribute\", \"value\": \"price-range\"} of [Berlin Burrito Company](restaurant)?  \n - what about [I due forni](restaurant)?  \n - can you tell me the [price range](attribute) of [that restaurant](mention)?  \n - what [cuisine](attribute) do [they](mention) have?  \n```\nThe above example just shows examples related to the restaurant domain. You should add examples for every object type that exists in your knowledge base to the same `query_knowledge_base` intent.\nIn addition to adding a variety of training examples for each query type, you need to specify and annotate the following entities in your training examples:\n  * `object_type`: Whenever a training example references a specific object type from your knowledge base, the object type should be marked as an entity. Use [synonyms](/docs/reference/primitives/training-data-format#synonyms) to map e.g. `restaurants` to `restaurant`, the correct object type listed as a key in the knowledge base.\n\n  * `mention`: If the user refers to an object via \u201cthe first one\u201d, \u201cthat one\u201d, or \u201cit\u201d, you should mark those terms as `mention`. We also use synonyms to map some of the mentions to symbols. You can learn about that in [resolving mentions](/docs/reference/integrations/action-server/knowledge-bases#resolve-mentions).\n  * `attribute`: All attribute names defined in your knowledge base should be identified as `attribute` in the NLU data. Again, use synonyms to map variations of an attribute name to the one used in the knowledge base.\nRemember to add those entities to your domain file (as entities and slots):\n    \n    \n```\nentities:  \n - object_type  \n - mention  \n - attribute  \n  \nslots:  \n object_type:  \n type: any  \n influence_conversation: false  \n mappings:  \n - type: from_entity  \n entity: object_type  \n mention:  \n type: any  \n influence_conversation: false  \n mappings:  \n - type: from_entity  \n entity: mention  \n attribute:  \n type: any  \n influence_conversation: false  \n mappings:  \n - type: from_entity  \n entity: attribute  \n```\n### Create an Action to Query your Knowledge Base\u200b\nTo create your own knowledge base action, you need to inherit `ActionQueryKnowledgeBase` and pass the knowledge base to the constructor of `ActionQueryKnowledgeBase`.\n    \n    \n```\nfrom rasa_sdk.knowledge_base.storage import InMemoryKnowledgeBase  \nfrom rasa_sdk.knowledge_base.actions import ActionQueryKnowledgeBase  \n  \nclass MyKnowledgeBaseAction(ActionQueryKnowledgeBase):  \n def __init__(self):  \n knowledge_base = InMemoryKnowledgeBase(\"data.json\")  \n super().__init__(knowledge_base)  \n```\nWhenever you create an `ActionQueryKnowledgeBase`, you need to pass a `KnowledgeBase` to the constructor. It can be either an `InMemoryKnowledgeBase` or your own implementation of a `KnowledgeBase` (see [Creating Your Own Knowledge Base](/docs/reference/integrations/action-server/knowledge-bases#create-a-knowledge-base)). You can only pull information from one knowledge base, as the usage of multiple knowledge bases at the same time is not supported.\nThis is the entirety of the code for this action! The name of the action is `action_query_knowledge_base`. Don't forget to add it to your domain file:\n    \n    \n```\nactions:  \n- action_query_knowledge_base  \n```\nnote\nIf you overwrite the default action name `action_query_knowledge_base`, you need to add the following three unfeaturized slots to your domain file: `knowledge_base_objects`, `knowledge_base_last_object`, and `knowledge_base_last_object_type`. The slots are used internally by `ActionQueryKnowledgeBase`. If you keep the default action name, those slots will be automatically added for you.\nYou also need to make sure to add a story to your stories file that includes the intent `query_knowledge_base` and the action `action_query_knowledge_base`. For example:\n    \n    \n```\nstories:  \n- story: knowledge base happy path  \n steps:  \n - intent: greet  \n - action: utter_greet  \n - intent: query_knowledge_base  \n - action: action_query_knowledge_base  \n - intent: goodbye  \n - action: utter_goodbye  \n```\n\nThe last thing you need to do is to define the response `utter_ask_rephrase` in your domain file. If the action doesn't know how to handle the user's request, it will use this response to ask the user to rephrase. For example, add the following responses to your domain file:\n    \n    \n```\nresponses:  \n utter_ask_rephrase:  \n - text: \"Sorry, I'm not sure I understand. Could you rephrase it?\"  \n - text: \"Could you please rephrase your message? I didn't quite get that.\"  \n```\nAfter adding all the relevant pieces, the action is now able to query the knowledge base.\n## How It Works\u200b\n`ActionQueryKnowledgeBase` looks at both the entities that were picked up in the request as well as the previously set slots to decide what to query for.\n### Query the Knowledge Base for Objects\u200b\nIn order to query the knowledge base for any kind of object, the user's request needs to include the object type. Let's look at an example:\nCan you please name some restaurants?\nThis question includes the object type of interest: \u201crestaurant.\u201d The bot needs to pick up on this entity in order to formulate a query \u2013 otherwise the action would not know what objects the user is interested in.\nWhen the user says something like:\nWhat Italian restaurant options in Berlin do I have?\nThe user wants to obtain a list of restaurants that (1) have Italian cuisine and (2) are located in Berlin. If the NER detects those attributes in the request of the user, the action will use those to filter the restaurants found in the knowledge base.\nIn order for the bot to detect these attributes, you need to mark \u201cItalian\u201d and \u201cBerlin\u201d as entities in the NLU data:\n    \n    \n```\nintents:  \n\n- intent: query_knowledge_base  \n examples: |  \n - What [Italian](cuisine) [restaurant](object_type) options in [Berlin](city) do I have?.  \n```\nThe names of the attributes, \u201ccuisine\u201d and \u201ccity,\u201d should be equal to the ones used in the knowledge base. You also need to add those as entities and slots to the domain file.\n### Query the Knowledge Base for an Attribute of an Object\u200b\nIf the user wants to obtain specific information about an object, the request should include both the object and attribute of interest.\nNew in 3.6\nThe user is not required to query the knowledge base to list any kind of object prior to this. The `ActionQueryKnowledgeBase` will extract the object type from the user's request and query the knowledge base for an attribute of the object.\nFor example, if the user asks something like:\nWhat is the cuisine of Berlin Burrito Company?\nThe user wants to obtain the \u201ccuisine\u201d (attribute of interest) for the restaurant \u201cBerlin Burrito Company\u201d (object of interest).\nThe attribute and object of interest should be marked as entities in the NLU training data:\n    \n    \n```\nintents:  \n- intent: query_knowledge_base  \n examples: |  \n - What is the [cuisine](attribute) of [Berlin Burrito Company](restaurant)?  \n```\nMake sure to add the object type, \u201crestaurant,\u201d to the domain file as entity and slot. This will support `ActionQueryKnowledgeBase` to extract the object type of the object the user is interested in.\n### Resolve Mentions\u200b\nFollowing along from the above example, users may not always refer to restaurants by their names. Users can either refer to the object of interest by its name, e.g. \u201cBerlin Burrito Company\u201d (representation string of the object), or they may refer to a previously listed object via a mention, for example:\nWhat is the cuisine of the second restaurant you mentioned?\nOur action is able to resolve these mentions to the actual object in the knowledge base. More specifically, it can resolve two mention types: (1) ordinal mentions, such as \u201cthe first one\u201d, and (2) mentions such as \u201cit\u201d or \u201cthat one\u201d.\n**Ordinal Mentions**\nWhen a user refers to an object by its position in a list, it is called an ordinal mention. Here's an example:\n  * User: What restaurants in Berlin do you know?\n  * Bot: Found the following objects of type 'restaurant': 1: I due forni 2: PastaBar 3: Berlin Burrito Company\n  * User: Does the first one have outside seating?\nThe user referred to \u201cI due forni\u201d by the term \u201cthe first one\u201d. Other ordinal mentions might include \u201cthe second one,\u201d \u201cthe last one,\u201d \u201cany,\u201d or \u201c3\u201d.\nOrdinal mentions are typically used when a list of objects was presented to the user. To resolve those mentions to the actual object, we use an ordinal mention mapping which is set in the `KnowledgeBase` class. The default mapping looks like:\n    \n    \n```\n{  \n \"1\": lambda l: l[0],  \n \"2\": lambda l: l[1],  \n \"3\": lambda l: l[2],  \n \"4\": lambda l: l[3],  \n \"5\": lambda l: l[4],  \n \"6\": lambda l: l[5],  \n \"7\": lambda l: l[6],  \n \"8\": lambda l: l[7],  \n \"9\": lambda l: l[8],  \n \"10\": lambda l: l[9],  \n \"ANY\": lambda l: random.choice(l),  \n \"LAST\": lambda l: l[-1],  \n}  \n```\n\nThere is a [tutorial](https://blog.rasa.com/integrating-rasa-with-knowledge-bases/) on our blog about how to use knowledge bases in custom actions. The tutorial explains the implementation behind `ActionQueryKnowledgeBase` in detail.\n### Creating Your Own Knowledge Base Actions\u200b\n`ActionQueryKnowledgeBase` should allow you to easily get started with integrating knowledge bases into your actions. However, the action can only handle two kind of user requests:\n  * the user wants to get a list of objects from the knowledge base\n  * the user wants to get the value of an attribute for a specific object\nThe action is not able to compare objects or consider relations between objects in your knowledge base. Furthermore, resolving any mention to the last mentioned object in the conversation might not always be optimal.\nIf you want to tackle more complex use cases, you can write your own custom action. We added some helper functions to `rasa_sdk.knowledge_base.utils` ([link to code](https://github.com/RasaHQ/rasa-sdk/tree/main/rasa_sdk/knowledge_base/) ) to help you when implement your own solution. We recommend using `KnowledgeBase` interface so that you can still use the `ActionQueryKnowledgeBase` alongside your new custom action.\nIf you write a knowledge base action that tackles one of the above use cases or a new one, be sure to tell us about it on the [forum](https://forum.rasa.com)!\n### Customizing the `InMemoryKnowledgeBase`\u200b\nThe class `InMemoryKnowledgeBase` inherits `KnowledgeBase`. You can customize your `InMemoryKnowledgeBase` by overwriting the following functions:",
    "title": "Knowledge Base Actions",
    "url": "https://rasa.com/docs/reference/integrations/action-server/knowledge-bases",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Business Logic with Flows | Rasa Documentation\n# Business Logic with Flows\nNew in 3.7\nFlows are part of Rasa's new [Conversational AI with Language Models (CALM) approach](/docs/learn/concepts/calm) and available starting with version `3.7.0`.\n## Overview\u200b\nIn [CALM](/docs/learn/concepts/calm), the business logic of your AI assistant is implemented as a set of flows. Each flow describes the logical steps your AI assistant uses to complete a task. It describes the information you need from the user, data you need to retrieve from an API or a database, and branching logic based on the information collected.\nA flow in Rasa only describes the logic your assistant follows, not all the potential paths conversations can take. If you're used to designing AI assistants by creating flow charts of how conversations should go, you'll see that flows in Rasa are much simpler. Check out [Rasa Studio](/docs/studio/build/flow-building/introduction) to build flows with a web interface.\nTo get familiar with how flows work, follow the [tutorial](/docs/pro/tutorial). This page provides a reference of the format and properties of flows.\n## Hello World\u200b\nA Flow is defined using YAML syntax. Here is an example of a simple flow:\nflows.yml\n    \n    \n```\nflows:  \n hello_world:  \n description: A simple flow that greets the user  \n steps:  \n - action: utter_greet  \n```\n## Flow Properties\u200b\nA flow is defined using the following properties:\nflows.yml\n    \n    \n```\nflows:  \n a_flow: ///# required id  \n name: \"A flow\" ///# optional name  \n description: \"required description of what the flow does\"  \n always_include_in_prompt: false ///# optional boolean, defaults to false  \n run_pattern_completed: true ///# optional boolean, defaults to true  \n if: \"condition\" ///# optional flow guard  \n nlu_trigger: ///# optional list of intents that can start a flow  \n - intent: \"starting_flow_intent\"  \n\nA step with a `collect` key instructs your assistant to request information from the user to fill a slot. For example:\n    \n    \n```\n- collect: account_type ///# slot name  \n```\nYour assistant will not proceed to the next step in the flow until the slot `account_type` has been filled. See the [tutorial](/docs/pro/tutorial#collecting-information-in-slots) for more information about slot filling and defining slots in your domain file.\nInstead of a `response` you can also define a [custom action](/docs/reference/primitives/custom-actions) called `action_ask_recipient` to phrase the question along with, for example, some buttons to the user. Make sure to add the custom action to your domain file.\ndomain.yml\n    \n    \n```\nactions:  \n - action_ask_recipient  \n```\ninfo\nYou can define either a `response` or a `custom action` for your collect step. It is not possible to define both. A validation error will be thrown by Rasa if both are defined.\n#### Slot Descriptions\u200b\nAn optional `description` field can be added to the `collect` step to guide the language model in extracting slot values.\n    \n    \n```\n- collect: account_type  \n description: \"Account type is one of checking, savings, money market, or IRA.\"  \n```\ninfo\nThe description field can be used to perform slot validation:\n    \n    \n```\n- collect: zip_code  \n description: |  \n A US postal code, having either 5 or 9 digits.  \n For example, \"60613\" or \"60613-1060\".  \n```\n#### Always Asking Questions\u200b\n\nIt is possible to link from a flow to the [Human Handoff](/docs/learn/concepts/conversation-patterns) conversation repair pattern. This enables catching a scenario where the conversation should be handed over to a human agent. It is not possible to link from a flow to any of the other [conversation repair pattern](/docs/reference/primitives/patterns#default-behavior)\n### Call\u200b\nNew in 3.8.0\nThe `call` step is available starting with version `3.8.0`.\nYou can use a `call` step inside a flow (parent flow) to embed another flow (child flow). When the execution reaches a `call` step, CALM starts the child flow. Once the child flow is complete, the execution continues with the parent flow.\nCalling other flows helps split up and reuse functionality. It allows you to define a flow once and use it in multiple other flows. Long flows can be split into smaller ones, making them easier to understand and maintain.\nYou can define a `call` step as:\nflows.yml\n    \n    \n```\nflows:  \n parent_flow:  \n description: \"The parent flow calling a child flow.\"  \n steps:  \n - call: child_flow  \n  \n child_flow:  \n description: \"A child flow.\"  \n steps:  \n - action: utter_child_flow  \n```\nThe call step must reference an existing flow and the child flow can be defined in the same file as the one containing the parent flow or a different file.\n#### Behavior of the `call` step\u200b\nThe `call` step is designed to behave as if the child flow is part of the parent flow. Hence, the following properties come out of the box:\n  1. If the child flow has a `next: END` in any step, the control will get passed back to the parent flow, and the next logical step will be executed.\n\nImagine a dress shopping AI assistant created to help users find and purchase dresses. This AI assistant includes two types of features: primary features (i.e., dress type, size) and optional features (i.e., color, material, price range, etc.). The assistant should ask for the primary features and avoid asking for the optional features, unless the user specifically requests them. This approach is key to avoid asking too many questions and overwhelming the user.\nYou can achieve this by setting the `ask_before_filling` property to `false` on the `collect` step and setting an `initial_value` for the slot in the domain file.\n    \n    \n```\nflows:  \n purchase_dress:  \n name: purchase dress  \n description: present options to the user and purchase the dress  \n steps:  \n - collect: dress_type  \n - collect: dress_size  \n - collect: dress_color  \n ask_before_filling: false  \n - collect: dress_material  \n ask_before_filling: false  \n next:  \n - if: slots.dress_material = \"cotton\"  \n then:  \n - action: action_present_cotton_dresses  \n next: END  \n - if: slots.dress_material = \"silk\"  \n then:  \n - action: action_present_silk_dresses  \n next: END  \n - else:  \n - action: action_present_all_dresses  \n next: END  \n```\ndomain.yml\n    \n    \n```\nslots:  \n dress_type:  \n type: categorical  \n values:  \n - \"shirt\"  \n - \"pants\"  \n - \"jacket\"  \n dress_size:  \n type: categorical  \n values:  \n - \"small\"  \n - \"medium\"  \n - \"large\"  \n dress_color:  \n type: text  \n initial_value: \"unspecified\"  \n dress_material:  \n type: categorical  \n initial_value: \"any\"  \n values:  \n - \"cotton\"  \n - \"silk\"  \n - \"polyester\"  \n - \"any\"  \n```\nWith `ask_before_filling` set to `false` and given that the slots (`dress_color` and `dress_material`) already have initial values, the corresponding `collect` steps will not be asked. Instead, the assistant will move to the next step. If the user explicitly provides a value for a slot, this new value will overwrite the initial one.",
    "title": "Business Logic with Flows",
    "url": "https://rasa.com/docs/reference/primitives/flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Writing Responses | Rasa Documentation\n# Writing Responses\nResponses are the messages your assistant sends to end users. These can be simple text messages or more complex UI elements such as images and buttons. In CALM, a \u201cresponse\u201d is one of the fundamental building blocks your assistant uses to communicate information, ask clarifying questions, and guide the user.\n  * **Where:** You define responses as YAML entries (usually in a file such as `domain.yml` or `responses.yml`).\n  * **Usage:** When an assistant flow or pattern decides to \u201csay\u201d something, it references one of these response definitions.\nBelow are the core steps to define and use responses in your CALM assistant. For advanced options\u2014like channel-specific messages, conditional responses, and dynamic button creation\u2014refer to [Responses](/docs/reference/primitives/responses) in the Reference section.\n### 1\\. Define Your Responses\u200b\nIn CALM, you typically define all your responses under a `responses` key in your domain or responses file. Each response name starts with `utter_`. For example:\ndomain.yml\n    \n    \n```\nresponses:  \n utter_greet:  \n - text: \"Hi there!\"  \n  \n utter_bye:  \n - text: \"See you next time!\"  \n```\n  * **Purpose:** Each `utter_` response is a distinct piece of content your assistant can send to the user.\n  * **Where It\u2019s Used:** You can reference the response by its name (e.g., `utter_greet`) in a flow step, or even in a custom action.\n### 2\\. Use Variables in Responses (Optional)\u200b\nIf you want the assistant to include slot values or other dynamic content, enclose variable names in curly braces:\ndomain.yml\n    \n    \n```\nresponses:  \n utter_greet:  \n - text: \"Hey, {name}. How are you?\"  \n```\n  * **How It Works**\nCALM will replace `{name}` with the value of the `name` slot (if it\u2019s filled).\n  * **From Custom Actions**\nIn a custom action, you can pass extra data to fill those variables:\nactions.py\n    \n```\n///# ...  \n\nflows:  \n greet_user:  \n description: \"Greet the user\"  \n steps:  \n - action: utter_greet  \n ///# ...  \n```\nWhen the assistant runs the `utter_greet` step, it sends one of the variations you defined for `utter_greet`.",
    "title": "Writing Responses",
    "url": "https://rasa.com/docs/pro/build/writing-responses",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  }
]