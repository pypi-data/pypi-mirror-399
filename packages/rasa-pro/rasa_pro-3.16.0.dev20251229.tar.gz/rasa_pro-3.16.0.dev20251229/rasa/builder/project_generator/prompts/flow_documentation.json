[
  {
    "content": "Writing Flows | Rasa Documentation\n# Writing Flows\nA **flow** in CALM is a structured sequence of steps describing **only** the business logic needed to complete a specific user goal\u2014like blocking a credit card, changing an address, or adding a payee. By separating the business logic from the rest of the conversation, you get:\n  * **Clarity** : Each flow focuses on a single job or outcome (e.g., \u201cBlock Credit Card\u201d).\n  * **Reusability** : Flow logic can be called from other flows or triggered on its own.\n  * **Maintainability** : You can refine or change the flow logic without affecting the entire conversation design.\nThere are two types of flows in CALM: flows that you write to express your business logic and patterns or system flows that come out of the box with CALM. Before we move on to explain how flows work, a word on these conversation patterns:\n### Conversation Patterns (System Flows)\u200b\nIn addition to the flows you write for your domain-specific tasks, Rasa provides **patterns** \u2014pre-defined, reusable flows that handle \u201cmeta\u201d conversational situations or repairs. For instance, if a user cancels a flow midway or wants to clarify a previously collected piece of information, a **pattern** steps in to handle this detour. These patterns work like templates: they can be triggered whenever relevant, so your assistant can handle common conversational patterns consistently.\nRead more about customizing patterns under [Customizing Patterns](/docs/pro/customize/patterns)\n## How Do Flows Work?\u200b\n### Triggering Flows\u200b\n\nCALM uses an [LLM \u201ccommand generator\u201d prompt](/docs/pro/customize/command-generator) that contains the conversation history, the relevant flows, slots, and conversation patterns. Essentially, CALM leverages the LLM to parse the user\u2019s request into structured commands, referencing all pertinent context\u2014including conversation history, current state, and flow definitions. This approach ensures that when the user\u2019s goal matches the description of a given flow, that flow will be triggered. Flows can also be:\n  * Started by a direct [NLU trigger](/docs/reference/primitives/starting-flows#nlu-trigger) (e.g., when a recognized intent maps to a flow).\n  * [Linked](/docs/reference/primitives/flows#link) or [called](/docs/reference/primitives/flows#call) from inside another flow (for subflows or follow-up tasks).\n### Dialogue Stack\u200b\nWhen a flow (or pattern) is activated, it\u2019s placed on top of a **dialogue stack** (like stacking plates). The topmost flow is always active. Once that flow finishes or is canceled, the system returns to the next flow on the stack. This structure ensures that your assistant\u2019s logic remains organized, even when users interrupt or pivot to new tasks.\n## How to Write Flows\u200b\nWriting a flow in CALM involves capturing the _essential steps_ to fulfill a user request without hardcoding every possible conversation path. You define flows as YAML in your `flows.yml` (or multiple YAML files), focusing on the business logic:\n  1. **Give the flow an ID and a clear description**\nflows.yml\n    \n```\nflows:  \n block_card:  \n description: Block a user's credit card when requested  \n steps: []  \n```\n    * The `description` is critical for the LLM to understand when to pick this flow.\n  2. **Add the steps**\n\nEach step specifies what your assistant should do:\n    * **Collect** user information:\nflows.yml\n        \n\t```\n\tflows:  \n\t block_card:  \n\t description: Block a user's credit card when requested  \n\t steps:  \n\t - collect: card_number  \n\t description: \u201cThe 16-digit card number to block\u201d  \n\t\n```\n    * **Take an action** (e.g., a [custom action](/docs/pro/build/custom-actions) or a response):\nflows.yml\n        \n\t```\n\tflows:  \n\t block_card:  \n\t description: Block a user's credit card when requested  \n\t steps:  \n\t ///# ...  \n\t - action: action_block_card_in_backend  \n\t\n```\n    * **Set or reset slots** :\nflows.yml\n        \n\t```\n\tflows:  \n\t block_card:  \n\t description: Block a user's credit card when requested  \n\t steps:  \n\t ///# ...  \n\t - set_slots:  \n\t - card_number: null  \n\t\n```\n    * **Call or link other flows** for subflows or follow-ups:\nflows.yml\n        \n\t```\n\tflows:  \n\t block_card:  \n\t description: Block a user's credit card when requested  \n\t steps:  \n\t ///# ...  \n\t - call: authenticate_user_flow  \n\t\n```\nflows.yml\n        \n\t```\n\tflows:  \n\t block_card:  \n\t description: Block a user's credit card when requested  \n\t steps:  \n\t ///# ...  \n\t - link: collect_feedback  \n\t\n```More information on different step types can be found on the [reference page](/docs/reference/primitives/flows#step-types).\nMore information on different step types can be found on the [reference page](/docs/reference/primitives/flows#step-types).\n  3. **Include branching if needed**\nYou can add simple conditional logic (like checking if a slot is filled or if a user is already authenticated):\nflows.yml\n    \n```\nflows:  \n block_card:  \n description: Block a user's credit card when requested  \n steps:  \n ///# ...  \n - collect: user_authenticated  \n next:  \n\n - if: not slots.user_authenticated  \n then:  \n - action: utter_ask_for_login  \n - link: authenticate_user_flow  \n```\n4. **Force slot collection (suppress interruptions) in collect steps if needed**\nYou can choose to set the `force_slot_filling` property to `true` if you want the assistant to ignore any other commands and only focus on filling text type slots. This is especially useful when you want to collect feedback or longer text input from the user in collect steps.\nflows.yml\n    \n    \n```\nflows:  \n block_card:  \n description: Block a user's credit card when requested  \n steps:  \n ///# ...  \n - collect: feedback  \n force_slot_filling: true  \n```\nMore information on forcing slot collection can be found on the [Flow reference page](/docs/reference/primitives/flows#suppressing-interruptions).\n5. **Leverage conversation patterns**\nYou don\u2019t need to write custom branching logic for every possible user detour. Flows represent the business logic your assistant is supposed to drive throughout conversation. Instead, rely on patterns (built-in flows) to accommodate user detours.\nFlows in CALM can do more than these basics\u2014such as advanced branching, slot validation, or subflow calls. For a deeper look at each property, step type, or YAML configuration, check out the [Flows reference](/docs/reference/primitives/flows).\n## Importance of Clear Descriptions\u200b\nEach flow has a **description** that briefly explains what the flow accomplishes. The LLM reads these descriptions to decide which flow to start. A concise, specific description reduces errors in flow selection. For example:\n> Good: \u201cBlock a user\u2019s credit card if they suspect fraud or want to freeze it\u201d\n> Less useful: \u201cCard blocking request\u201d\n## Key Takeaways\u200b\n\n  1. **Flows define business logic** : They are not full conversation scripts but the critical steps your organization wants to _guarantee_.\n  2. **LLMs + flows** : The LLM remains flexible in interpreting user input and context, while flows make sure the assistant sticks to rules and processes.\n  3. **Write clear and detailed descriptions** : They help the LLM reliably select the right flow at the right time.\n  4. **Use patterns for conversation repair** : Don\u2019t clutter your flow with every possible detour. Let patterns handle cancellations, clarifications, or other unexpected conversation turns.\nWith flows, you maintain control over complex processes while giving the LLM room to shine in adapting to user input. Start by mapping out the tasks your assistant must support, split them into distinct flows, and keep descriptions tight. That\u2019s all you need to harness the best of both worlds: rigid business logic and flexible, human-like conversations.",
    "title": "Writing Flows",
    "url": "https://rasa.com/docs/pro/build/writing-flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Business Logic with Flows | Rasa Documentation\n# Business Logic with Flows\nNew in 3.7\nFlows are part of Rasa's new [Conversational AI with Language Models (CALM) approach](/docs/learn/concepts/calm) and available starting with version `3.7.0`.\n## Overview\u200b\nIn [CALM](/docs/learn/concepts/calm), the business logic of your AI assistant is implemented as a set of flows. Each flow describes the logical steps your AI assistant uses to complete a task. It describes the information you need from the user, data you need to retrieve from an API or a database, and branching logic based on the information collected.\nA flow in Rasa only describes the logic your assistant follows, not all the potential paths conversations can take. If you're used to designing AI assistants by creating flow charts of how conversations should go, you'll see that flows in Rasa are much simpler. Check out [Rasa Studio](/docs/studio/build/flow-building/introduction) to build flows with a web interface.\nTo get familiar with how flows work, follow the [tutorial](/docs/pro/tutorial). This page provides a reference of the format and properties of flows.\n## Hello World\u200b\nA Flow is defined using YAML syntax. Here is an example of a simple flow:\nflows.yml\n    \n    \n```\nflows:  \n hello_world:  \n description: A simple flow that greets the user  \n steps:  \n - action: utter_greet  \n```\n## Flow Properties\u200b\nA flow is defined using the following properties:\nflows.yml\n    \n    \n```\nflows:  \n a_flow: ///# required id  \n name: \"A flow\" ///# optional name  \n description: \"required description of what the flow does\"  \n always_include_in_prompt: false ///# optional boolean, defaults to false  \n run_pattern_completed: true ///# optional boolean, defaults to true  \n if: \"condition\" ///# optional flow guard  \n nlu_trigger: ///# optional list of intents that can start a flow  \n - intent: \"starting_flow_intent\"  \npersisted_slots: [] ///# optional list of slots that should be persisted at the conversation level after the flow ends  \n steps: [] ///# required list of steps  \n```\n### Flow ID\u200b\nThe id is required and uniquely identifies the flow among all flows. It allows only alphanumeric characters, underscores, and hyphens, with the restriction that the first character cannot be a hyphen.\n### Name\u200b\nThe `name` field is an optional human readable name for the flow.\n### Description\u200b\nThe `description` field is a summary of the flow. It is required, and should describe what the flow does for the user. Writing a clear description is important, because it is used by the [Dialogue Understanding](/docs/learn/concepts/dialogue-understanding) component to decide when to start this flow. See [Starting Flows](/docs/reference/primitives/starting-flows) for more details. Additionally, for guidelines on how to write concise and clear descriptions see the section provided [here](/docs/reference/config/components/llm-command-generators#customizing-the-prompt).\n### Always Include in Prompt\u200b\nIf `always_include_in_prompt` field is set to `true` and the [flow guard](/docs/reference/primitives/starting-flows#flow-guards) defined in the `if` field evaluates to `true`, the flow will be [always be included in the prompt](/docs/reference/config/components/llm-command-generators#retrieving-relevant-flows)\n### NLU Trigger property\u200b\nThe `nlu_trigger` field is used to add [intents that can start the flow](/docs/reference/primitives/starting-flows#nlu-trigger).\n### Run Pattern Completed\u200b\n\nThe `run_pattern_completed` field is used to determine if the [`pattern_completed`](/docs/reference/primitives/patterns#default-behavior) flow should be run when the conversation is finished. This field is only applicable to the parent flows which are not called by other flows.\n### If property\u200b\nThe `if` field is used to add [flow guards](/docs/reference/primitives/starting-flows#flow-guards).\n### Persisted Slots\u200b\nBy default, slots set in a `collect` and `set_slot` step are reset when the flow ends. To change this behavior, you can add these slots to the `persisted_slots` field.\nThe `persisted_slots` field is used to specify a list of slots whose value should be persisted after the flow ends. These slots have to be filled in either a `collect` or `set_slots` step in the flow.\nflows.yml\n    \n    \n```\nflows:  \n transfer_money:  \n description: This flow lets users send money to friends and family.  \n persisted_slots:  \n - recipient  \n - amount  \n steps:  \n - collect: recipient  \n - id: ask_amount  \n collect: amount  \n description: the number of US dollars to send  \n - action: action_check_sufficient_funds  \n next:  \n - if: not has_sufficient_funds  \n then:  \n - action: utter_insufficient_funds  \n - set_slots:  \n - amount: null  \n next: ask_amount  \n - else: final_confirmation  \n```\n#### Validation Rules for `persisted_slots` property\u200b\nDuring training, Rasa implements the following strict validation checks for the `persisted_slots` property:\n  * The `persisted_slots` property cannot be simultaneously used with the `reset_after_flow_ends` property of the `collect` step in a flow.\n\nYou can suppress interruptions to a `collect` step by setting the `force_slot_filling` property to `true`.\nBy default, the assistant will process an interruption to the conversation at any time, this could be triggered by the user digressing or by the assistant incorrectly interpreting the user's message.\nIn some cases, you may want to suppress interruptions to a `collect` step. For example, when the slot being collected is a feedback or comments slot, and you want to ensure that the user provides their feedback before proceeding with the next step. This kind of user message could reference different topics which could incorrectly trigger other commands.\nBy setting `force_slot_filling: true`, the assistant will ignore any other commands and only process the `SetSlot` command for the slot being collected.\n    \n    \n```\n- collect: feedback  \n force_slot_filling: true  \n```\n#### Using a different response key for the `collect` step\u200b\nBy default, Rasa will look for a response called `utter_ask_{slot_name}` to execute a `collect` step. You can use a [response](/docs/reference/primitives/responses) with a different key by adding an `utter` property to the step.\nFor example:\nflows.yml\n    \n    \n```\nflows:  \n replace_supplementary_card:  \n description: This flow helps the user to replace a supplementary card for a family member.  \n steps:  \n - collect: account_type  \n utter: utter_ask_secondary_account_type  \n next: ask_account_number  \n```\n#### Using an action to ask for information in `collect` step\u200b",
    "title": "Business Logic with Flows",
    "url": "https://rasa.com/docs/reference/primitives/flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "# Business Logic with Flows\nNew in 3.7\nFlows are part of Rasa's new [Conversational AI with Language Models (CALM) approach](/docs/learn/concepts/calm) and available starting with version `3.7.0`.\n## Overview\u200b\nIn [CALM](/docs/learn/concepts/calm), the business logic of your AI assistant is implemented as a set of flows. Each flow describes the logical steps your AI assistant uses to complete a task. It describes the information you need from the user, data you need to retrieve from an API or a database, and branching logic based on the information collected.\nA flow in Rasa only describes the logic your assistant follows, not all the potential paths conversations can take. If you're used to designing AI assistants by creating flow charts of how conversations should go, you'll see that flows in Rasa are much simpler. Check out [Rasa Studio](/docs/studio/build/flow-building/introduction) to build flows with a web interface.\nTo get familiar with how flows work, follow the [tutorial](/docs/pro/tutorial). This page provides a reference of the format and properties of flows.\n## Hello World\u200b\nA Flow is defined using YAML syntax. Here is an example of a simple flow:\nflows.yml\n    \n    \n```\nflows:  \n hello_world:  \n description: A simple flow that greets the user  \n steps:  \n - action: utter_greet  \n```",
    "title": "Business Logic with Flows",
    "url": "https://rasa.com/docs/reference/primitives/flows",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Designing Natural and Engaging Conversations | Rasa Documentation\n# Designing Natural and Engaging Conversations\nThis guide is intended as an introduction to how to create conversations that are helpful and feel natural.\nIt's designed specifically with **designers** in mind, but it's also useful for anyone who wants to learn how to get the most out of Rasa.\n### Topics covered\u200b\n  * What makes a good conversation? CxD\n  * How CxD works with CALM\n  * How to write responses that feel human\n  * How to test and improve through feedback\n## What is Conversation Design (CxD)?\u200b\n**Conversation Design** is the process of researching, conceptualizing, and creating conversational interactions between human users and AI. It is an interdisciplinary field drawing from UX design, linguistics, conversation analysis, content management, human-computer interaction, and related studies.\nConversation design is both human-centered and data-driven.\n## What is CALM?\u200b\n**Rasa CALM** is a state-of-the-art hybrid approach to building conversational AI assistants. It combines 'flows' \u2014 predefined sets of steps to complete tasks that represent business processes \u2014 with the power of language models to:\n  * Understand user intentions\n  * Handle edge cases\n  * Repair conversations\n  * Generate responses where appropriate\nTo read more about CALM, see the [CALM documentation](/docs/learn/concepts/calm).\n## How does CALM affect the CxD process?\u200b\nAs a conversation designer, each project starts with **discovery** , focusing on the use cases, scope, and tasks for the AI assistant. Extensive research is conducted on:\n  * Target audience interaction goals and needs\n  * Conversation habits\n  * Language styles\n### Outcomes of the Discovery Phase:\u200b\n\nThe research leads to user journeys that are converted into _conversational flows_ \u2014 dynamic representations of possible conversation paths between the user and AI assistant. These flows execute **Business Logic** in CALM.\n### Designing with CALM:\u200b\nYou don't need complex flowcharts with many interlinked branches. Instead, each flow can focus on specific tasks, such as:\n  * Responding to user questions\n  * Connecting to a knowledge base for requested information\n  * Collecting user information in a series of steps\n  * Performing actions (e.g., checking a balance, blocking a card, booking an appointment)\n  * Transferring to a human operator\n### Building a Flow in CALM:\u200b\nWhile building flows in CALM, you can predefine:\n  * The assistant's responses (which could also be generated)\n  * Information to collect from the user ( _slots_ ) and subsequent actions\n  * How to act based on user inputs ( _logic_ )\n  * Next steps in the conversation ( _links_ )\nCALM's **Dialogue Understanding** module leverages language models to interpret user statements and intentions. As a designer:\n  * You aren't required to build sets of intents, entities, and variations for every scenario.\n  * However, you can still do so for specific scenarios if desired.\n### LLM-Based `CommandGenerator`:\u200b\nThe `CommandGenerator` translates user input into commands that drive the conversation forward by triggering flows, operations, repair patterns, and more. It considers:\n  * Conversation history\n  * Context\n#### Key Customization Options:\u200b\n  * **Prompting the LLM:** Use flow descriptions and slot definitions to guide the LLM in generating appropriate commands. [Learn more about prompting](/docs/reference/config/components/llm-command-generators#customization).\n\n  * **Flow Retrieval:** Pre-select relevant flows for a given conversation. [Learn more about flow retrieval](/docs/reference/config/components/llm-command-generators#retrieving-relevant-flows).\n## CxD Workflow in CALM\u200b\n### Outside of Rasa: Designer Responsibilities\u200b\n  * Gather data on user needs, language style, and conversational habits\n  * Define user personas, map content, and user journeys\n  * Create an AI assistant personality\n  * Write sample dialogues\n  * Draft conversational flows\n  * Plan error handling, escalation strategies, and handovers (if needed)\n  * Prepare user testing rounds and protocols\n### Inside Rasa: Builder Responsibilities\u200b\n  * Build flows based on designs and user journeys\n  * Write efficient flow and slot descriptions to guide the LLM\n  * Create responses (if needed) that align with personality guidelines\n  * Prompt the LLM to generate or rephrase responses (if needed)\n  * Customize conversation repair patterns per error handling strategies\n  * Write end-to-end (e2e) tests based on sample dialogues\n  * Connect the assistant to knowledge sources and implement RAG\n  * Instruct the LLM on generating texts for RAG responses\n  * Debug designs and test the assistant using Rasa Inspector",
    "title": "Designing Natural and Engaging Conversations",
    "url": "https://rasa.com/docs/learn/best-practices/conversation-design",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  },
  {
    "content": "Rasa Tutorial | Rasa Documentation\n# Rasa Tutorial\n **Welcome!** In this tutorial, you'll learn how to build a reliable, scalable AI agent using **CALM** , Rasa's LLM-powered dialogue engine. You\u2019ll define a simple process (called a _flow_ in Rasa), and see first-hand how [**Process Calling**](https://rasa.com/blog/process-calling-agentic-tools-need-state/) with **Conversation Patterns** enable you to build steerable conversational experiences, without the risks of ungrounded LLM reasoning and answer generation.\n## What are you building?\u200b\nIn this tutorial, you will build an LLM-powered assistant that can complete a money transfer, reliably executing your business logic while allowing for fluid conversation.\nHere are some of the conversations your assistant will be able to handle, just by defining the money transfer process:\n  * Happy path\n  * All at once\n  * Change of mind\nUser: I want to send money\nBot: Who would you like to send money to?\nUser: to Jen\nBot: How much would you like to send?\nUser: $50\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: yes\nBot: All done. $50.0 has been sent to Jen.\nBot: Is there anything else I can help you with?!\nhappy path\nUser: I want to send 100 dollars to Joe\nBot: \nPlease confirm: you want to transfer $100.0 to Joe?\nUser: yes.\nBot: All done. $100.00 has been sent to Joe.\nBot: Is there anything else I can help you with?\nAll info given\nUser: I need to send $50\nBot: Who would you like to send money to?\nUser: Jen\nBot: \nPlease confirm: you want to transfer $50.0 to Jen?\nUser: actually no 60\nBot: Ok, I corrected the amount.\nBot: \nPlease confirm: you want to transfer $60.0 to Jen?\nUser: yes.\nBot: All done. $60.00 has been sent to Jen.\nBot: Is there anything else I can help you with?\nChange of mind\n## Following This Tutorial\u200b\nYou'll need a free Rasa [Developer Edition license](/docs/pro/intro)\n\nThis tutorial contains a mix of explanations and instructions. Whenever there are instructions you need to follow, you'll see this 'Action Required' label:\nAction Required\nThis assistant is powered by [an LLM that we fine-tuned and uploaded to huggingface](https://huggingface.co/rasa/command-generator-llama-3.1-8b-instruct). For convenience, this tutorial will use a deployment that we host and make available for users working through the tutorial. If you prefer, you don't have to use any 3rd party API and just [run this model yourself](/docs/pro/deploy/deploy-fine-tuned-model) or use [another LLM](/docs/reference/config/components/llm-configuration)\n## Setup\u200b\nAction Required\nFor new users, the easiest way to get started is in the browser with a [GitHub Codespace](/docs/learn/quickstart/pro#create-a-codespace).\nYou can also [install rasa-pro locally](/docs/pro/installation/python) and use your own machine.\ninfo\nA GitHub codespace gives you a working environment to explore Rasa in under a minute. We really suggest you start there!\nTo code along with this tutorial, navigate to an empty directory in your terminal, and run:\n    \n    \n```\nrasa init --template tutorial  \n```\nIf you're using a [codespace](/docs/learn/quickstart/pro#create-a-codespace), you already set your environment variables during setup. If you've installed Rasa locally, set your Rasa license in an environment variable:\n  * Linux/MacOS\n  * Windows\n    \n    \n```\nexport RASA_LICENSE=\"your-rasa-pro-license-key\"  \n```\n    \n    \n```\nsetx RASA_LICENSE your-rasa-license-key  \n```\nThe variable will now be correctly set when you create a new cmd prompt window.\n\nRemember to replace `your-rasa-license-key` with the your actual license key.\n## Overview\u200b\nOpen up the project folder in your IDE to see the files that make up your new project. In this tutorial you will primarily work with the following files:\n  * `data/flows.yml`\n  * `domain.yml`\n  * `actions/actions.py`\n## Testing your money transfer flow\u200b\nAction Required\nTrain your assistant by running:\n    \n    \n```\nrasa train  \n```\nNow, try telling the assistant that you'd like to transfer some money to a friend. Start talking to it in the browser by running:\n    \n    \n```\nrasa inspect  \n```\ninfo\nWhen you run the `rasa inspect` command in a GitHub Codespace, you'll see a notification that your application is available on port 5005. Click 'Open in Browser' to access the inspector and start chatting. \ninfo\nThis template bot responds to chitchat by generating a response. If you want to disable this, delete the file `data/patterns.yml` and re-train.\n## Understanding your money transfer flow.\u200b\nThe file `data/flows.yml` contains the definition of a `flow` called `transfer_money`. Let's look at this definition to see what is going on:\nflows.yml\n    \n    \n```\nflows:  \n transfer_money:  \n description: Help users send money to friends and family.  \n steps:  \n - collect: recipient  \n - collect: amount  \n description: the number of US dollars to send  \n - action: utter_transfer_complete  \n```\n\nThe two key attributes of the `transfer_money` flow are the `description` and the `steps`. The `description` is used to help decide _when_ to activate this flow. But it is also helpful for anyone who inspects your code to understand what is going on. If a user says \"I need to transfer some money\", the description helps Rasa understand that this is the relevant flow. The `steps` describe the business logic required to do what the user asked for.\nThe first step in your flow is a `collect` step, which is used to fill a `slot`. A `collect` step sends a message to the user requesting information, and waits for an answer.\n## Collecting Information in Slots\u200b\n`Slots` are variables that your assistant can read and write throughout a conversation. Slots are defined in your `domain.yml` file. For example, the definition of your `recipient` slot looks like this:\ndomain.yml\n    \n    \n```\nslots:  \n recipient:  \n type: text  \n mappings:  \n - type: from_llm  \n ///# ...  \n```\nSlots can be used to store information that users provide during the conversation, or information that has been fetched via an API call. First, you're going to see how to store information provided by the end user in a slot. To do this, you define a `collect` step like the first step in your flow above.\nflows.yml\n    \n    \n```\nflows:  \n transfer_money:  \n description: Help users send money to friends and family.  \n steps:  \n - collect: recipient  \n - collect: amount  \n description: the number of US dollars to send  \n - action: utter_transfer_complete  \n```\nRasa will look for a `response` called `utter_ask_recipient` in your domain file and use this to phrase the question to the user.\ndomain.yml\n    \n    \n\n## Branching Logic\u200b\nSlots are also used to build branching logic in flows.\nAction Required\nYou're going to introduce an extra step to your flow, asking the user to confirm the amount and the recipient before sending the transfer. Since you are asking a yes/no question, you can store the result in a boolean `slot` which you will call `final_confirmation`.\nIn your domain file, add the definition of the `final_confirmation` slot and the corresponding response: `utter_ask_final_confirmation`. Also add a response to confirm the transfer has been cancelled.\ndomain.yml\n    \n    \n```\nslots:  \n recipient:  \n type: Text  \n mappings:  \n - type: from_llm  \n ///# ...  \n final_confirmation:  \n type: bool  \n mappings:  \n - type: from_llm  \n```\ndomain.yml\n    \n    \n```\nresponses:  \n utter_ask_recipient:  \n - text: \"Who would you like to send money to?\"  \n ///# ...  \n utter_ask_final_confirmation:  \n - text: \"Please confirm: you want to transfer {amount} to {recipient}?\"  \n utter_transfer_cancelled:  \n - text: \"Your transfer has been cancelled.\"  \n```\nNotice that your confirmation question uses curly brackets `{}` to include slot values in your response.",
    "title": "Rasa Tutorial",
    "url": "https://rasa.com/docs/pro/tutorial",
    "metadata": {
      "type": "document",
      "record_type": "documentation",
      "context": null,
      "media_type": null
    }
  }
]