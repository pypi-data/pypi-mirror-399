"""
.. list-table:: Assign and Retrieve Colors
    :header-rows: 1
    :widths: 40 60

    * - Methods of :class:`~.simulation.CellContainer`
      - Description
    * - :func:`~.simulation.CellContainer.assign_colors_to_cells`
      - Assigns unique colors to cells.
    * - :func:`~.simulation.CellContainer.counter_to_cell_identifier`
      - Converts an integer counter to a cell
    * - :func:`~.simulation.CellContainer.get_color`
      - Obtains the color assigned to the cell
    * - :func:`~.simulation.CellContainer.get_cell_from_color`
      - Given a color, determines the :class:`CellIdentifier`
    * - :func:`counter_to_color`
      - Maps an integer counter uniquely to a color value
    * - :func:`color_to_counter`
      - Inverse of :func:`counter_to_color`

.. list-table:: Generating Images
    :header-rows: 1
    :widths: 40 60

    * - Function
      - Description
    * - :func:`render_pv_image`
      - Renders an image image purely generated by pyvista
    * - :func:`render_mask`
      - Creates masks usable for cell-segmentation
    * - :func:`render_image`
      - Renders a complete near-realistic image.
    * - :func:`store_all_images`
      - Creates and stores images in files.
"""

from .cr_mech_coli import (
    RodAgent,
    counter_to_color,
    color_to_counter,
    CellContainer,
)
from .simulation import Configuration, sort_cellular_identifiers, CellIdentifier
import pyvista as pv
import numpy as np
import cv2 as cv
import dataclasses
from pathlib import Path
from tqdm import tqdm
import multiprocessing as mp


@dataclasses.dataclass
class RenderSettings:
    """
    This class contains all settings to render images with
    `pyvista <https://docs.pyvista.org/>_ and `opencv <https://opencv.org>_ to create
    near-realistic microscopic images.
    Many of the values will be given directly to pyvistas :meth:`pyvista.plotter.add_mesh` function.
    Others are used by :mod:`cv2`.
    """

    pixel_per_micron: (
        float | np.float32 | tuple[float, float] | tuple[np.float32, np.float32]
    ) = 12.8  #: Determines Resolution of the generated image
    diffuse: float | np.float32 = 0.5  #: Value Between 0 and 1.
    ambient: float | np.float32 = 0.5  #: Value between 0 and 1.
    specular: float | np.float32 = 0.5  #: Value between 0 and 1.
    specular_power: float | np.float32 = 10.0  #: Value between 0 and 250.
    metallic: float | np.float32 = 1.0  #: Value between 0 and 1
    noise: int = 50  #: RGB values per pixel
    bg_brightness: int = 100  #: Background brightness
    cell_brightness: int = 30  #: Brightness of the individual cells
    ssao_radius: int = 50  #: Radius for ssao scattering
    kernel_size: int = 30  #: Smoothing kernel size
    pbr: bool = True  #: Enable physics-based rendering
    lighting: bool = True  # Enable lighting in 3D render
    render_mask: bool = (
        False  # If enabled, notifies rendering engine to disable effects
    )

    def prepare_for_masks(self):
        """
        Prepares all render settings such that the image generated is a mask.
        """
        rs = dataclasses.replace(self)
        rs.diffuse = 0
        rs.ambient = 1
        rs.specular = 0
        rs.specular_power = 0
        rs.metallic = 0
        rs.noise = 0
        rs.bg_brightness = 0
        rs.ssao_radius = 0
        rs.kernel_size = 1
        rs.pbr = False
        rs.lighting = False
        rs.render_mask = True
        return rs


def __create_cell_surfaces(
    cells: dict[CellIdentifier, tuple[RodAgent, CellIdentifier | None]],
):
    for ident in cells.keys():
        meshes = []
        p = cells[ident][0].pos
        r = cells[ident][0].radius

        meshes.append(pv.Sphere(center=p[0], radius=r))
        for j in range(max(p.shape[0] - 1, 0)):
            # Add sphere at junction
            meshes.append(pv.Sphere(center=p[j + 1], radius=r))

            # Otherwise add cylinders
            pos1 = p[j]
            pos2 = p[j + 1]
            center = 0.5 * (pos1 + pos2)
            direction = pos2 - center
            height = float(np.linalg.norm(pos1 - pos2))
            cylinder = pv.Cylinder(
                center=center, direction=direction, radius=r, height=height
            )
            meshes.append(cylinder)
        # Combine all together
        mesh = pv.MultiBlock(meshes).extract_geometry()
        yield (ident, mesh)


def render_pv_image(
    cells: dict[CellIdentifier, tuple[RodAgent, CellIdentifier | None]],
    render_settings: RenderSettings,
    domain_size: tuple[np.float32, np.float32],
    colors: dict[CellIdentifier, tuple[np.uint8, np.uint8, np.uint8]] | None = None,
    filename: str | Path | None = None,
    render_distance=None,
) -> np.ndarray:
    """
    Creates a 3D render of the given cells.

    Args:
        cells: A iterable which contains all cells at a specific iteration.
        render_settings (RenderSettings): Contains all settings to specify how to render image.
        domain_size (tuple[float, float]): The domain size as specified in :class:`Configuration`.
        colors (dict): A dictionary mapping a :class:`CellIdentifier` to a color.
            If not given use color from `render_settings`.
        filename: Name of the file in which to save the image. If not specified, do
            not save.
        image_distance: Distance of the camera from the image. If not given, try to estimate
            automatically.

    Returns:
        np.ndarray: An array of shape `(resolution, resolution, 3)` which contains the rendered
            pixels.
    """

    if render_distance is None:
        render_distance = max(domain_size)

    try:
        ppm = (render_settings.pixel_per_micron[0], render_settings.pixel_per_micron[1])
    except:
        ppm = (render_settings.pixel_per_micron, render_settings.pixel_per_micron)

    plotter = pv.Plotter(
        off_screen=True,
        window_size=[
            int(np.round(domain_size[0] * ppm[0])),
            int(np.round(domain_size[1] * ppm[1])),
        ],
    )

    # Get camera info
    p1 = np.array([0, 0, 0])
    p2 = np.array([domain_size[0], domain_size[1], 0])
    p3 = np.array([0, domain_size[1], 0])
    rect = pv.Rectangle([p1, p2, p3])
    plotter.add_mesh(rect)
    bounds = (0.0, domain_size[0], 0.0, domain_size[1], 0.0, 0)
    pv.Plotter.view_xy(plotter, bounds=bounds)
    pv.Plotter.enable_parallel_projection(plotter)
    plotter.camera.tight(padding=0)
    plotter.camera.position = (*plotter.camera.position[:2], render_distance)
    camera = plotter.camera.copy()
    plotter.clear_actors()

    pv.Plotter.set_background(plotter, [render_settings.bg_brightness] * 3)

    for ident, cell in __create_cell_surfaces(cells):
        color = [render_settings.cell_brightness] * 3
        if colors is not None:
            color = colors[ident]
        actor = plotter.add_mesh(
            cell,
            show_edges=False,
            color=color,
            diffuse=render_settings.diffuse,
            ambient=render_settings.ambient,
            specular=render_settings.specular,
            specular_power=render_settings.specular_power,
            metallic=render_settings.metallic,
            pbr=render_settings.pbr,
            lighting=render_settings.lighting,
        )
        actor.UseBoundsOff()

    if not render_settings.render_mask:
        pv.Plotter.enable_ssao(plotter, radius=render_settings.ssao_radius)
        plotter.enable_anti_aliasing()
    else:
        plotter.disable_anti_aliasing()

    plotter.camera = camera
    img = np.array(plotter.screenshot())
    plotter.close()

    if filename is not None:
        # Check that folder exist and if not create them
        odir = Path(filename).parents[0]
        odir.mkdir(parents=True, exist_ok=True)
        cv.imwrite(str(filename), img)

    return img


def render_mask(
    cells: dict[CellIdentifier, tuple[RodAgent, CellIdentifier | None]],
    colors: dict[CellIdentifier, tuple[np.uint8, np.uint8, np.uint8]],
    domain_size: tuple[np.float32, np.float32],
    render_settings: RenderSettings | None = None,
    filename: str | Path | None = None,
    render_distance=None,
) -> np.ndarray:
    """
    Creates an image containing masks of the given cells.
    This function internally uses the :func:`render_pv_image` function and
    :meth:`RenderSettings.prepare_for_masks` method.

    Args:
        cells: See :func:`render_pv_image`.
        render_settings (RenderSettings): See :func:`render_pv_image`.
        domain_size (tuple[np.float32, np.float32]): See :func:`render_pv_image`.
        colors (dict[CellIdentifier, tuple[int, int, int]]): See :func:`render_pv_image`.
        filename: See :func:`render_pv_image`.

    Returns:
        np.ndarray: See :func:`render_pv_image`.
    """
    if render_settings is None:
        render_settings = RenderSettings()
    rs = render_settings.prepare_for_masks()
    img = render_pv_image(
        cells,
        rs,
        domain_size,
        colors,
        filename,
        render_distance,
    )
    return img


def render_image(
    cells: dict[CellIdentifier, tuple[RodAgent, CellIdentifier | None]],
    domain_size: tuple[np.float32, np.float32],
    render_settings: RenderSettings | None = None,
    filename: str | Path | None = None,
    render_distance=None,
) -> np.ndarray:
    """
    Aims to create a near-realistic microscopic image with the given cells.
    This function internally uses the :func:`render_pv_image` function but changes some of the

    Args:
        cells: See :func:`render_pv_image`.
        domain_size (tuple[np.float32, np.float32]): See :func:`render_pv_image`.
        render_settings (RenderSettings): See :func:`render_pv_image`.
        colors (dict): See :func:`render_pv_image`.
        filename: See :func:`render_pv_image`.

    Returns:
        np.ndarray: See :func:`render_pv_image`.
    """
    if render_settings is None:
        render_settings = RenderSettings()
    img = render_pv_image(cells, render_settings, domain_size, render_distance)

    # Smoothen it out
    kernel = (
        np.ones([render_settings.kernel_size] * 2, np.float32)
        / render_settings.kernel_size**2
    )
    img = cv.filter2D(img, -1, kernel)

    # Make noise on image
    rng = np.random.default_rng()
    noise = rng.integers(
        0, render_settings.noise, img.shape[:2], dtype=np.uint8, endpoint=True
    )
    for j in range(3):
        img[:, :, j] = cv.add(img[:, :, j], noise)

    if filename is not None:
        # Check that folder exist and if not create them
        odir = Path(filename).parents[0]
        odir.mkdir(parents=True, exist_ok=True)
        cv.imwrite(str(filename), img)

    return img


def __store_all_images_wrapper(args):
    (
        iteration,
        container,
        domain_size,
        render_settings,
        save_dir,
        render_raw_pv,
        render_distance,
    ) = args
    cell_container = CellContainer.deserialize(container)
    cells = cell_container.get_cells_at_iteration(iteration)
    colors = cell_container.cell_to_color
    render_image(
        cells,
        domain_size,
        render_settings,
        Path(save_dir) / "images/{:09}.png".format(iteration),
        render_distance,
    )
    render_mask(
        cells,
        colors,
        domain_size,
        render_settings,
        Path(save_dir) / "masks/{:09}.png".format(iteration),
        render_distance,
    )
    if render_raw_pv:
        render_pv_image(
            cells,
            render_settings,
            domain_size,
            colors=None,
            filename=Path(save_dir) / "raw_pv/{:09}.png".format(iteration),
            render_distance=render_distance,
        )


def store_all_images(
    cell_container: CellContainer,
    domain_size: tuple[np.float32, np.float32] | tuple[float, float],
    render_settings: RenderSettings | None = None,
    save_dir: str | Path = "out",
    render_distance=None,
    render_raw_pv: bool = False,
    show_progressbar: bool | int = False,
    store_config: Configuration | None = None,
    use_hash: bool = True,
    workers: int = 1,
):
    """
    Combines multiple functions and renders images to files for a complete simulation result.
    This function calls the :func:`render_image`, :func:`render_pv_image` and
    :func:`render_mask` functions to create multiple images.

    Args:
        cell_container: See :func:`cr_mech_coli.simulation.run_simulation`.
        domain_size (tuple[np.float32, np.float32]): See :func:`render_pv_image`.
        render_settings (RenderSettings): See :func:`render_pv_image`.
        save_dir: Path of the directory where to save all images.
        render_raw_pv (bool): Additionaly render the intermediate image before applying effects
            from :mod:`cv2`.
        show_progressbar (bool): Shows a progressbar of how many iterations have been rendered.
        store_config (bool): Store config as json string in directory.
        use_hash (bool): Use a hash generated from the :class:`Configuration` class as subfolder of
            `save_dir` to store results in.
            This option can only be used together with the `store_config` option.

    Returns:
        np.ndarray: See :func:`render_pv_image`.
    """
    if render_settings is None:
        render_settings = RenderSettings()
    iterations = cell_container.get_all_iterations()

    if use_hash and store_config is not None:
        sim_hash = store_config.to_hash()
        save_dir = Path(save_dir) / "{:020}/".format(sim_hash)

    if store_config is not None:
        config_string = store_config.to_json()
        Path(save_dir).mkdir(parents=True, exist_ok=True)
        with open(Path(save_dir) / "config.json", "w") as f:
            f.write(config_string)

    from itertools import repeat

    container = cell_container.serialize()

    arglist = zip(
        iterations,
        repeat(container),
        repeat(domain_size),
        repeat(render_settings),
        repeat(save_dir),
        repeat(render_raw_pv),
        repeat(render_distance),
    )

    pool = mp.Pool(workers)
    _ = list(
        tqdm(
            pool.imap(__store_all_images_wrapper, arglist),
            total=len(iterations),
            disable=not show_progressbar,
        )
    )
