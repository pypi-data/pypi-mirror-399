# coding: utf-8

"""
    Seeq REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 66.91.2-v202512300114-CD
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import sys
import os
import re

from deprecated import deprecated
# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient
from ..models import *

class StoredTablesApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def create_stored_table_from_csv(self, **kwargs):
        """
        Create a new stored table from CSV. The column order will be equal to the order in the CSV.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_stored_table_from_csv(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableCSVInputV1 body: (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_stored_table_from_csv_with_http_info(**kwargs)
        else:
            (data) = self.create_stored_table_from_csv_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def create_stored_table_from_csv_with_http_info(self, **kwargs):
        """
        Create a new stored table from CSV. The column order will be equal to the order in the CSV.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_stored_table_from_csv_with_http_info(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableCSVInputV1 body: (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_stored_table_from_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_stored_table_from_csv`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/csv/create', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'StoredTableOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def delete_column_from_stored_table(self, **kwargs):
        """
        Delete a column from a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_column_from_stored_table(id=id_value, column_id=column_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The Seeq ID for the stored table (required)
        :param str column_id: The column ID to be deleted (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_column_from_stored_table_with_http_info(**kwargs)
        else:
            (data) = self.delete_column_from_stored_table_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def delete_column_from_stored_table_with_http_info(self, **kwargs):
        """
        Delete a column from a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_column_from_stored_table_with_http_info(id=id_value, column_id=column_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The Seeq ID for the stored table (required)
        :param str column_id: The column ID to be deleted (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """

        all_params = ['id', 'column_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_column_from_stored_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_column_from_stored_table`")
        # verify the required parameter 'column_id' is set
        if ('column_id' not in params) or (params['column_id'] is None):
            raise ValueError("Missing the required parameter `column_id` when calling `delete_column_from_stored_table`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'column_id' in params:
            path_params['columnId'] = params['column_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/{id}/columns/{columnId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'StoredTableOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def delete_stored_table_rows(self, **kwargs):
        """
        Delete rows from a stored table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_stored_table_rows(body=body_value, table_id=table_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableDeleteRowsInputV1 body: (required)
        :param str table_id: The id of the table to delete rows from (required)
        :return: DeleteRowsOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeleteRowsOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_stored_table_rows_with_http_info(**kwargs)
        else:
            (data) = self.delete_stored_table_rows_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def delete_stored_table_rows_with_http_info(self, **kwargs):
        """
        Delete rows from a stored table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_stored_table_rows_with_http_info(body=body_value, table_id=table_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableDeleteRowsInputV1 body: (required)
        :param str table_id: The id of the table to delete rows from (required)
        :return: DeleteRowsOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeleteRowsOutputV1
        """

        all_params = ['body', 'table_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_stored_table_rows" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `delete_stored_table_rows`")
        # verify the required parameter 'table_id' is set
        if ('table_id' not in params) or (params['table_id'] is None):
            raise ValueError("Missing the required parameter `table_id` when calling `delete_stored_table_rows`")


        collection_formats = {}

        path_params = {}
        if 'table_id' in params:
            path_params['tableId'] = params['table_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/{tableId}/deleteRows', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'DeleteRowsOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def get_stored_table(self, **kwargs):
        """
        Get a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stored_table(id=id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The ID of the stored table (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_stored_table_with_http_info(**kwargs)
        else:
            (data) = self.get_stored_table_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def get_stored_table_with_http_info(self, **kwargs):
        """
        Get a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_stored_table_with_http_info(id=id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str id: The ID of the stored table (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """

        all_params = ['id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stored_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_stored_table`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/{id}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'StoredTableOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def import_stored_table_csv(self, **kwargs):
        """
        Import a CSV file that can be used to create a stored table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.import_stored_table_csv(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str file:
        :return: ImportTableCSVOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ImportTableCSVOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.import_stored_table_csv_with_http_info(**kwargs)
        else:
            (data) = self.import_stored_table_csv_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def import_stored_table_csv_with_http_info(self, **kwargs):
        """
        Import a CSV file that can be used to create a stored table
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.import_stored_table_csv_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str file:
        :return: ImportTableCSVOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ImportTableCSVOutputV1
        """

        all_params = ['file']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_stored_table_csv" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/csv', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ImportTableCSVOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def modify_column_in_stored_table(self, **kwargs):
        """
        Modify a column in a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.modify_column_in_stored_table(body=body_value, id=id_value, column_id=column_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableColumnInputV1 body: (required)
        :param str id: The Seeq ID for the stored table (required)
        :param str column_id: The column ID to be modified. Possible modifications are: changing the column's index, renaming the column, changing the column's type, and updating the column's unit of measure. Once a column has become a non-String type, it's type can not be changed.For type conversions:- String to TIMESTAMPTZ: If the string value is in ISO8601 format, it gets directly cast to a timestamp with the same information. If not, then it gets cast to the epoch timestamp.- String to Numeric: The string values will get directly converted into their numeric equivalent. So, '1' becomes 1, '1.5' becomes 1.5, 1e10 becomes 10000000000. So integers, decimals, and scientific notation is handled. If a string cannot become converted, it will be cast as null. Units of measure are parsed out of numeric values and stored separately if multiple exist. If only one unit of measure exists, it is set as the column uom.- String to Boolean: If 'false', 'f', or '0', convert to false. If 'true', 't', or '1', convert to true. The string to boolean conversion is case-insensitive. (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.modify_column_in_stored_table_with_http_info(**kwargs)
        else:
            (data) = self.modify_column_in_stored_table_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def modify_column_in_stored_table_with_http_info(self, **kwargs):
        """
        Modify a column in a stored table. This endpoint is experimental and may change in future releases.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.modify_column_in_stored_table_with_http_info(body=body_value, id=id_value, column_id=column_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableColumnInputV1 body: (required)
        :param str id: The Seeq ID for the stored table (required)
        :param str column_id: The column ID to be modified. Possible modifications are: changing the column's index, renaming the column, changing the column's type, and updating the column's unit of measure. Once a column has become a non-String type, it's type can not be changed.For type conversions:- String to TIMESTAMPTZ: If the string value is in ISO8601 format, it gets directly cast to a timestamp with the same information. If not, then it gets cast to the epoch timestamp.- String to Numeric: The string values will get directly converted into their numeric equivalent. So, '1' becomes 1, '1.5' becomes 1.5, 1e10 becomes 10000000000. So integers, decimals, and scientific notation is handled. If a string cannot become converted, it will be cast as null. Units of measure are parsed out of numeric values and stored separately if multiple exist. If only one unit of measure exists, it is set as the column uom.- String to Boolean: If 'false', 'f', or '0', convert to false. If 'true', 't', or '1', convert to true. The string to boolean conversion is case-insensitive. (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """

        all_params = ['body', 'id', 'column_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modify_column_in_stored_table" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `modify_column_in_stored_table`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `modify_column_in_stored_table`")
        # verify the required parameter 'column_id' is set
        if ('column_id' not in params) or (params['column_id'] is None):
            raise ValueError("Missing the required parameter `column_id` when calling `modify_column_in_stored_table`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']
        if 'column_id' in params:
            path_params['columnId'] = params['column_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/{id}/columns/{columnId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'StoredTableOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def update_stored_table_from_csv(self, **kwargs):
        """
        Update an existing stored table from a CSV. The column order will be equal to the order in the CSV. All existing data in the stored table will be preseved and new rows/columns from the new CSV will be added to the existing data.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_stored_table_from_csv(body=body_value, id=id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableCSVInputV1 body: (required)
        :param str id: The Seeq ID for the stored table (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_stored_table_from_csv_with_http_info(**kwargs)
        else:
            (data) = self.update_stored_table_from_csv_with_http_info(**kwargs)
            return data

    @deprecated(reason="This API is experimental and may change or be removed in future releases without prior notice.")
    def update_stored_table_from_csv_with_http_info(self, **kwargs):
        """
        Update an existing stored table from a CSV. The column order will be equal to the order in the CSV. All existing data in the stored table will be preseved and new rows/columns from the new CSV will be added to the existing data.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_stored_table_from_csv_with_http_info(body=body_value, id=id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param StoredTableCSVInputV1 body: (required)
        :param str id: The Seeq ID for the stored table (required)
        :return: StoredTableOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StoredTableOutputV1
        """

        all_params = ['body', 'id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_stored_table_from_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_stored_table_from_csv`")
        # verify the required parameter 'id' is set
        if ('id' not in params) or (params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_stored_table_from_csv`")


        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/stored-tables/{id}/csv/update', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'StoredTableOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
