# coding: utf-8

"""
    Seeq REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 66.91.2-v202512300114-CD
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import sys
import os
import re

from deprecated import deprecated
# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient
from ..models import *

class FoldersApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def archive_folder(self, **kwargs):
        """
        Archive a folder and all of its content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.archive_folder(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to archive (required)
        :return: ArchiveOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArchiveOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.archive_folder_with_http_info(**kwargs)
        else:
            (data) = self.archive_folder_with_http_info(**kwargs)
            return data

    def archive_folder_with_http_info(self, **kwargs):
        """
        Archive a folder and all of its content
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.archive_folder_with_http_info(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to archive (required)
        :return: ArchiveOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArchiveOutputV1
        """

        all_params = ['folder_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `archive_folder`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'ArchiveOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def create_folder(self, **kwargs):
        """
        Create a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_folder(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param FolderInputV1 body: Folder information (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_folder_with_http_info(**kwargs)
        else:
            (data) = self.create_folder_with_http_info(**kwargs)
            return data

    def create_folder_with_http_info(self, **kwargs):
        """
        Create a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_folder_with_http_info(body=body_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param FolderInputV1 body: Folder information (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_folder`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_ancestors(self, **kwargs):
        """
        Get navigation context for a folder. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ancestors(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. (required)
        :param str root: What sharing category results should be returned for
        :return: FolderNavigationOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderNavigationOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_ancestors_with_http_info(**kwargs)
        else:
            (data) = self.get_ancestors_with_http_info(**kwargs)
            return data

    def get_ancestors_with_http_info(self, **kwargs):
        """
        Get navigation context for a folder. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_ancestors_with_http_info(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. (required)
        :param str root: What sharing category results should be returned for
        :return: FolderNavigationOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderNavigationOutputV1
        """

        all_params = ['folder_id', 'root']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ancestors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_ancestors`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']

        query_params = []
        if 'root' in params:
            query_params.append(('root', params['root']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}/ancestors', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderNavigationOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_folder(self, **kwargs):
        """
        Get information about a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_folder(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. Special values: 'mine' for the authenticated user's Home folder; 'corporate' for the Corporate folder; 'externallyShared' for the Externally Shared folder; 'users' (admins only) for the folder that contains the home folders of all users. (required)
        :param bool full_ancestry: If true, the full ancestry  will be returned, which includes the home folder of the relevant user. Otherwise, the home folder is not returned. Requires admin privileges.
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_folder_with_http_info(**kwargs)
        else:
            (data) = self.get_folder_with_http_info(**kwargs)
            return data

    def get_folder_with_http_info(self, **kwargs):
        """
        Get information about a folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_folder_with_http_info(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. Special values: 'mine' for the authenticated user's Home folder; 'corporate' for the Corporate folder; 'externallyShared' for the Externally Shared folder; 'users' (admins only) for the folder that contains the home folders of all users. (required)
        :param bool full_ancestry: If true, the full ancestry  will be returned, which includes the home folder of the relevant user. Otherwise, the home folder is not returned. Requires admin privileges.
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """

        all_params = ['folder_id', 'full_ancestry']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']

        query_params = []
        if 'full_ancestry' in params:
            query_params.append(('fullAncestry', params['full_ancestry']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_folders(self, **kwargs):
        """
        Get all root folders and workbooks, or folder content if a parent folder id is specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_folders(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter: If set to 'mine' or 'owner', only workbench items under the current user's home folder will be returned. If set to 'public' only workbench items shared with the Everyone group will be returned, excluding items under the corporate folder. If set to 'sharedOrPublic' only workbench items shared with the current user or a group they belong to are returned, excluding items under the corporate folder. If set to 'sharedDirectlyWithMe' only workbench items directly shared with the current user will be returned, excluding items under the corporate folder and items shared with groups the user belongs to. If set to 'shared' only workbench items shared with the current user or a group they belong to (except the Everyone group) are returned, excluding items under the corporate folder. If set to 'corporate', only workbench items under the corporate folder are returned. If set to 'users', only items under other user's home folders are returned. If set to 'all' (or not specified), all workbench items the current user has access to will be returned.
        :param str user_id: The user ID to return folders for, defaults to the current user if not specified. Only an admin user is allowed to specify a user ID.
        :param bool is_archived: When true, returns only archived workbench items.
        :param str sort_order: A field by which to order the folders followed by a space and 'asc' or 'desc'. Field name can be one of: createdAt, updatedAt, name, owner
        :param int offset: The pagination offset, the index of the first collection item that will be returned in this page of results
        :param int limit: The pagination limit, the total number of collection items that will be returned in this page of results
        :param bool only_pinned: When true, returns only pinned workbench items are returned. The given folderId is not applied.
        :param str folder_id: The folder to return the content of. If not specified, only root folders are returned unless filtering to specific IDs, filtering to pinned or archived items, sorting by last opened timestamp, or a text search is provided.
        :param list[str] ids: The IDs of items to return.
        :param list[str] types: The types of items to return.
        :param str text_search: Search text by which to filter items' names.
        :param bool is_exact: If true, uses the exact query terms supplied by the user instead of stemming the query to its root words
        :param str root: The highest ancestor that items should have, if possible
        :param list[str] search_fields: Search by name, description, or document body.  Searches name by default when no field is supplied
        :param list[str] creator_ids: List of creator IDs to filter on
        :param list[str] owner_ids: List of owner IDs to filter on
        :param list[str] locations: List of locations to search under, may be 'mine', 'others', or 'corporate'. 'mine' searches all items under the current user's home folder. 'others' searches items under home folders belonging to all users other than the current user. 'corporate' searches the corporate folder, if enabled. Values may be used together. No values searches all locations.
        :param list[str] access_statuses: List of access statuses to search by, may be 'public', 'groups', or 'directly'. 'public' searches items shared with the Everyone group, if enabled. 'groups' searches items shared with groups the current user belongs to. 'directly' searches items directly accessible by the current user. No values searches all access statuses.
        :return: WorkbenchItemOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkbenchItemOutputListV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_folders_with_http_info(**kwargs)
        else:
            (data) = self.get_folders_with_http_info(**kwargs)
            return data

    def get_folders_with_http_info(self, **kwargs):
        """
        Get all root folders and workbooks, or folder content if a parent folder id is specified.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_folders_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str filter: If set to 'mine' or 'owner', only workbench items under the current user's home folder will be returned. If set to 'public' only workbench items shared with the Everyone group will be returned, excluding items under the corporate folder. If set to 'sharedOrPublic' only workbench items shared with the current user or a group they belong to are returned, excluding items under the corporate folder. If set to 'sharedDirectlyWithMe' only workbench items directly shared with the current user will be returned, excluding items under the corporate folder and items shared with groups the user belongs to. If set to 'shared' only workbench items shared with the current user or a group they belong to (except the Everyone group) are returned, excluding items under the corporate folder. If set to 'corporate', only workbench items under the corporate folder are returned. If set to 'users', only items under other user's home folders are returned. If set to 'all' (or not specified), all workbench items the current user has access to will be returned.
        :param str user_id: The user ID to return folders for, defaults to the current user if not specified. Only an admin user is allowed to specify a user ID.
        :param bool is_archived: When true, returns only archived workbench items.
        :param str sort_order: A field by which to order the folders followed by a space and 'asc' or 'desc'. Field name can be one of: createdAt, updatedAt, name, owner
        :param int offset: The pagination offset, the index of the first collection item that will be returned in this page of results
        :param int limit: The pagination limit, the total number of collection items that will be returned in this page of results
        :param bool only_pinned: When true, returns only pinned workbench items are returned. The given folderId is not applied.
        :param str folder_id: The folder to return the content of. If not specified, only root folders are returned unless filtering to specific IDs, filtering to pinned or archived items, sorting by last opened timestamp, or a text search is provided.
        :param list[str] ids: The IDs of items to return.
        :param list[str] types: The types of items to return.
        :param str text_search: Search text by which to filter items' names.
        :param bool is_exact: If true, uses the exact query terms supplied by the user instead of stemming the query to its root words
        :param str root: The highest ancestor that items should have, if possible
        :param list[str] search_fields: Search by name, description, or document body.  Searches name by default when no field is supplied
        :param list[str] creator_ids: List of creator IDs to filter on
        :param list[str] owner_ids: List of owner IDs to filter on
        :param list[str] locations: List of locations to search under, may be 'mine', 'others', or 'corporate'. 'mine' searches all items under the current user's home folder. 'others' searches items under home folders belonging to all users other than the current user. 'corporate' searches the corporate folder, if enabled. Values may be used together. No values searches all locations.
        :param list[str] access_statuses: List of access statuses to search by, may be 'public', 'groups', or 'directly'. 'public' searches items shared with the Everyone group, if enabled. 'groups' searches items shared with groups the current user belongs to. 'directly' searches items directly accessible by the current user. No values searches all access statuses.
        :return: WorkbenchItemOutputListV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkbenchItemOutputListV1
        """

        all_params = ['filter', 'user_id', 'is_archived', 'sort_order', 'offset', 'limit', 'only_pinned', 'folder_id', 'ids', 'types', 'text_search', 'is_exact', 'root', 'search_fields', 'creator_ids', 'owner_ids', 'locations', 'access_statuses']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folders" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('filter', params['filter']))
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))
        if 'is_archived' in params:
            query_params.append(('isArchived', params['is_archived']))
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))
        if 'offset' in params:
            query_params.append(('offset', params['offset']))
        if 'limit' in params:
            query_params.append(('limit', params['limit']))
        if 'only_pinned' in params:
            query_params.append(('onlyPinned', params['only_pinned']))
        if 'folder_id' in params:
            query_params.append(('folderId', params['folder_id']))
        if 'ids' in params:
            query_params.append(('ids', params['ids']))
            collection_formats['ids'] = 'multi'
        if 'types' in params:
            query_params.append(('types', params['types']))
            collection_formats['types'] = 'multi'
        if 'text_search' in params:
            query_params.append(('textSearch', params['text_search']))
        if 'is_exact' in params:
            query_params.append(('isExact', params['is_exact']))
        if 'root' in params:
            query_params.append(('root', params['root']))
        if 'search_fields' in params:
            query_params.append(('searchFields', params['search_fields']))
            collection_formats['searchFields'] = 'multi'
        if 'creator_ids' in params:
            query_params.append(('creatorIds', params['creator_ids']))
            collection_formats['creatorIds'] = 'multi'
        if 'owner_ids' in params:
            query_params.append(('ownerIds', params['owner_ids']))
            collection_formats['ownerIds'] = 'multi'
        if 'locations' in params:
            query_params.append(('locations', params['locations']))
            collection_formats['locations'] = 'multi'
        if 'access_statuses' in params:
            query_params.append(('accessStatuses', params['access_statuses']))
            collection_formats['accessStatuses'] = 'multi'

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'WorkbenchItemOutputListV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_pinned(self, **kwargs):
        """
        Get pinned home screen items for the current user.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pinned(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_pinned_with_http_info(**kwargs)
        else:
            (data) = self.get_pinned_with_http_info(**kwargs)
            return data

    def get_pinned_with_http_info(self, **kwargs):
        """
        Get pinned home screen items for the current user.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_pinned_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pinned" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/pinned', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderSearchResultsV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_recently_used(self, **kwargs):
        """
        Get recently used home screen items for the current user. The results will be ordered in descending order (most recently used first, least recently used last).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_recently_used(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int limit: The maximum number of recently used home screen items to return. Default is 10, maximum is 100.
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_recently_used_with_http_info(**kwargs)
        else:
            (data) = self.get_recently_used_with_http_info(**kwargs)
            return data

    def get_recently_used_with_http_info(self, **kwargs):
        """
        Get recently used home screen items for the current user. The results will be ordered in descending order (most recently used first, least recently used last).
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_recently_used_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int limit: The maximum number of recently used home screen items to return. Default is 10, maximum is 100.
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """

        all_params = ['limit']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recently_used" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/recentlyUsed', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderSearchResultsV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_subfolders(self, **kwargs):
        """
        Get subfolders of a folder. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subfolders(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. Special values of 'mine', 'corporate', 'sharedOrPublic', 'externallyShared', or 'users' can be used to fetch the top level categories. (required)
        :param str root: What sharing category results should be returned for
        :return: FolderNavigationOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderNavigationOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_subfolders_with_http_info(**kwargs)
        else:
            (data) = self.get_subfolders_with_http_info(**kwargs)
            return data

    def get_subfolders_with_http_info(self, **kwargs):
        """
        Get subfolders of a folder. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_subfolders_with_http_info(folder_id=folder_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of the folder to retrieve. Special values of 'mine', 'corporate', 'sharedOrPublic', 'externallyShared', or 'users' can be used to fetch the top level categories. (required)
        :param str root: What sharing category results should be returned for
        :return: FolderNavigationOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderNavigationOutputV1
        """

        all_params = ['folder_id', 'root']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subfolders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_subfolders`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']

        query_params = []
        if 'root' in params:
            query_params.append(('root', params['root']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}/subfolders', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderNavigationOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def move_item_to_folder(self, **kwargs):
        """
        Move specified item to specified folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_item_to_folder(folder_id=folder_id_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of folder to move item to. Special values of 'mine' or 'corporate' move the item to the authenticated user's home folder or the corporate folder, respectively. (required)
        :param str item_id: ID of item to move to folder (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.move_item_to_folder_with_http_info(**kwargs)
        else:
            (data) = self.move_item_to_folder_with_http_info(**kwargs)
            return data

    def move_item_to_folder_with_http_info(self, **kwargs):
        """
        Move specified item to specified folder
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.move_item_to_folder_with_http_info(folder_id=folder_id_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of folder to move item to. Special values of 'mine' or 'corporate' move the item to the authenticated user's home folder or the corporate folder, respectively. (required)
        :param str item_id: ID of item to move to folder (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """

        all_params = ['folder_id', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_item_to_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `move_item_to_folder`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `move_item_to_folder`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}/{itemId}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def remove_item_from_folder(self, **kwargs):
        """
        Remove specified item from specified folder. The item will be moved to the root level.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_item_from_folder(folder_id=folder_id_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of folder to remove item from (required)
        :param str item_id: ID of item to remove from folder (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.remove_item_from_folder_with_http_info(**kwargs)
        else:
            (data) = self.remove_item_from_folder_with_http_info(**kwargs)
            return data

    def remove_item_from_folder_with_http_info(self, **kwargs):
        """
        Remove specified item from specified folder. The item will be moved to the root level.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.remove_item_from_folder_with_http_info(folder_id=folder_id_value, item_id=item_id_value, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str folder_id: ID of folder to remove item from (required)
        :param str item_id: ID of item to remove from folder (required)
        :return: FolderOutputV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderOutputV1
        """

        all_params = ['folder_id', 'item_id']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_item_from_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params) or (params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `remove_item_from_folder`")
        # verify the required parameter 'item_id' is set
        if ('item_id' not in params) or (params['item_id'] is None):
            raise ValueError("Missing the required parameter `item_id` when calling `remove_item_from_folder`")


        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']
        if 'item_id' in params:
            path_params['itemId'] = params['item_id']

        query_params = []

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/{folderId}/{itemId}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderOutputV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def search(self, **kwargs):
        """
        Search for folder content using string fragments and filters. This search is FAST, but it is also 'eventually consistent,' meaning that data that was written to the database may take some time to propagate to this search facility. Results will be returned based on read access to the content. If you are an admin, all results will be returned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query: String fragment to search for. Text will be matched against the content of the folder(s). If the 'query' argument is not supplied, all items are returned (that match the 'filter', 'location' and 'parentFolderId' arguments, if provided). 
        :param str filter: The filter string to apply to the search.<br> <br> Examples: <pre>'Type' = 'Analysis' AND Owner = '768C213D-F50E-40AC-AA68-D7D6BB09916E'</pre><br> You can use 'AND', 'OR', and 'NOT' to combine multiple filters, using parentheses to group them if necessary.<br> <br> For the <strong>Created At</strong> and <strong>Updated At</strong> fields, which are millisecond-based UNIX timestamps, you can use &gt; and &lt; operators.<br> <br> For the <strong>Ancestors</strong> and <strong>ACL</strong> fields, which are lists of IDs, hits will be returned if any members of the list match the filter.<br> <br> You can only filter on indexed fields, which are:<br> <ul>     <li><strong>Type</strong> ('Folder', 'Analysis', 'Topic' etc)</li>     <li><strong>Created At</strong> (nanosecond-based UNIX timestamp)</li>     <li><strong>Updated At</strong> (nanosecond-based UNIX timestamp)</li>     <li><strong>Owner</strong> (user ID)</li>     <li><strong>Archived</strong> (true/false)</li>     <li><strong>Ancestors</strong> (list of folder IDs in ascending order from top, with top-level of __Users__ or __Corporate__)</li>     <li><strong>ACL</strong> (list of identity IDs that have read access to the content)</li> </ul> 
        :param str location: Determines the location(s) to search for items. It acts as a convenient shortcut for applying multiple filters. The following locations are supported: <br> <ul>     <li><strong>ALL</strong> (Searches all locations)</li>     <li><strong>MINE</strong> (Searches for non-archived items in the current users home folder)</li>     <li><strong>SHARED</strong> (Searches for non-archived items shared with the current user)</li>     <li><strong>CORPORATE</strong> (Searches for non-archived items in the corporate folder)</li>     <li><strong>USERS</strong> (Searches for non-archived items in the users folder)</li>     <li><strong>TRASH</strong> (Searches for archived items/items in the trash)</li> </ul> Leaving the parameter empty searches all locations (similar to 'ALL'). 
        :param str parent_folder_id: ID of a folder to limit the search to. If supplied, only items within this folder (and its subfolders) will be searched. 
        :param str sort_field: Field to sort the results by. Supported fields are:<br> <ul>     <li><strong>Name</strong></li>     <li><strong>Created At</strong></li>     <li><strong>Updated At</strong></li>     <li><strong>Creator</strong></li>     <li><strong>Owner</strong></li> </ul> Leave this parameter empty to use the default sorting (relevance). 
        :param str sort_order: Sort order for the results. Supported values are:<br> <ul>     <li><strong>ASC</strong> for ascending</li>     <li><strong>DESC</strong> for descending</li> </ul> 
        :param str hit_highlight_format: If supplied, this turns on <em>hit highlighting</em> for the search results, which identifies the words that were matched in the content. The value is a string in the following format: <pre>&lt;strong&gt;%s&lt;/strong&gt;</pre> In this example, we're putting the hit highlight (the placeholder is <strong>%s</strong>) in a &lt;strong&gt; HTML tag. You can replace this string with whatever makes sense for your purposes.<br> <br> If you do not specify this parameter, then no hit highlighting is performed.<br> <br> Highlights are returned in the \"Highlights\" key of each hit. 
        :param int hits_per_page: Number of hits to return per page. Defaults to 40.
        :param int page: One-based page number to retrieve. If zero is specified, then no hits are returned -- only the hit counts. 
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.search_with_http_info(**kwargs)
        else:
            (data) = self.search_with_http_info(**kwargs)
            return data

    def search_with_http_info(self, **kwargs):
        """
        Search for folder content using string fragments and filters. This search is FAST, but it is also 'eventually consistent,' meaning that data that was written to the database may take some time to propagate to this search facility. Results will be returned based on read access to the content. If you are an admin, all results will be returned. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.search_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query: String fragment to search for. Text will be matched against the content of the folder(s). If the 'query' argument is not supplied, all items are returned (that match the 'filter', 'location' and 'parentFolderId' arguments, if provided). 
        :param str filter: The filter string to apply to the search.<br> <br> Examples: <pre>'Type' = 'Analysis' AND Owner = '768C213D-F50E-40AC-AA68-D7D6BB09916E'</pre><br> You can use 'AND', 'OR', and 'NOT' to combine multiple filters, using parentheses to group them if necessary.<br> <br> For the <strong>Created At</strong> and <strong>Updated At</strong> fields, which are millisecond-based UNIX timestamps, you can use &gt; and &lt; operators.<br> <br> For the <strong>Ancestors</strong> and <strong>ACL</strong> fields, which are lists of IDs, hits will be returned if any members of the list match the filter.<br> <br> You can only filter on indexed fields, which are:<br> <ul>     <li><strong>Type</strong> ('Folder', 'Analysis', 'Topic' etc)</li>     <li><strong>Created At</strong> (nanosecond-based UNIX timestamp)</li>     <li><strong>Updated At</strong> (nanosecond-based UNIX timestamp)</li>     <li><strong>Owner</strong> (user ID)</li>     <li><strong>Archived</strong> (true/false)</li>     <li><strong>Ancestors</strong> (list of folder IDs in ascending order from top, with top-level of __Users__ or __Corporate__)</li>     <li><strong>ACL</strong> (list of identity IDs that have read access to the content)</li> </ul> 
        :param str location: Determines the location(s) to search for items. It acts as a convenient shortcut for applying multiple filters. The following locations are supported: <br> <ul>     <li><strong>ALL</strong> (Searches all locations)</li>     <li><strong>MINE</strong> (Searches for non-archived items in the current users home folder)</li>     <li><strong>SHARED</strong> (Searches for non-archived items shared with the current user)</li>     <li><strong>CORPORATE</strong> (Searches for non-archived items in the corporate folder)</li>     <li><strong>USERS</strong> (Searches for non-archived items in the users folder)</li>     <li><strong>TRASH</strong> (Searches for archived items/items in the trash)</li> </ul> Leaving the parameter empty searches all locations (similar to 'ALL'). 
        :param str parent_folder_id: ID of a folder to limit the search to. If supplied, only items within this folder (and its subfolders) will be searched. 
        :param str sort_field: Field to sort the results by. Supported fields are:<br> <ul>     <li><strong>Name</strong></li>     <li><strong>Created At</strong></li>     <li><strong>Updated At</strong></li>     <li><strong>Creator</strong></li>     <li><strong>Owner</strong></li> </ul> Leave this parameter empty to use the default sorting (relevance). 
        :param str sort_order: Sort order for the results. Supported values are:<br> <ul>     <li><strong>ASC</strong> for ascending</li>     <li><strong>DESC</strong> for descending</li> </ul> 
        :param str hit_highlight_format: If supplied, this turns on <em>hit highlighting</em> for the search results, which identifies the words that were matched in the content. The value is a string in the following format: <pre>&lt;strong&gt;%s&lt;/strong&gt;</pre> In this example, we're putting the hit highlight (the placeholder is <strong>%s</strong>) in a &lt;strong&gt; HTML tag. You can replace this string with whatever makes sense for your purposes.<br> <br> If you do not specify this parameter, then no hit highlighting is performed.<br> <br> Highlights are returned in the \"Highlights\" key of each hit. 
        :param int hits_per_page: Number of hits to return per page. Defaults to 40.
        :param int page: One-based page number to retrieve. If zero is specified, then no hits are returned -- only the hit counts. 
        :return: FolderSearchResultsV1
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FolderSearchResultsV1
        """

        all_params = ['query', 'filter', 'location', 'parent_folder_id', 'sort_field', 'sort_order', 'hit_highlight_format', 'hits_per_page', 'page']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')
        all_params.append('_response_type')
        all_params.append('_custom_headers')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))
        if 'filter' in params:
            query_params.append(('filter', params['filter']))
        if 'location' in params:
            query_params.append(('location', params['location']))
        if 'parent_folder_id' in params:
            query_params.append(('parentFolderId', params['parent_folder_id']))
        if 'sort_field' in params:
            query_params.append(('sortField', params['sort_field']))
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))
        if 'hit_highlight_format' in params:
            query_params.append(('hitHighlightFormat', params['hit_highlight_format']))
        if 'hits_per_page' in params:
            query_params.append(('hitsPerPage', params['hits_per_page']))
        if 'page' in params:
            query_params.append(('page', params['page']))

        header_params = {}

        for key, value in params.get('_custom_headers', {}).items():
            header_params[key] = value


        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/vnd.seeq.v1+json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/vnd.seeq.v1+json', ])

        # Authentication setting
        auth_settings = ['api_key']

        return self.api_client.call_api('/folders/search', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=params.get('_response_type', 'FolderSearchResultsV1'),
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
