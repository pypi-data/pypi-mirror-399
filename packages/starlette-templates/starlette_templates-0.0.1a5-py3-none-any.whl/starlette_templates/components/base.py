import string
import random
import typing as t
from markupsafe import Markup
from starlette.requests import Request
from jinja2 import Environment, pass_context
from pydantic import BaseModel, Field, ConfigDict


# Template Functions and Filters
_alphabet = string.ascii_lowercase + string.digits


def generate_component_id(k: int = 8) -> str:
    """Generate a unique component ID."""
    return "component-" + "".join(random.choices(_alphabet, k=k))


class ComponentModel(BaseModel):
    """Base class for renderable UI components. Components should inherit from this class.

    Components are rendered using Jinja2 templates, which can be organized and loaded
    via the application's Jinja2 environment template loaders configured in `JinjaMiddleware`.

    ```python
    class HeaderComponent(ComponentModel):
        template: str = "components/header.html"
        title: str
        subtitle: str

    header = HeaderComponent(title="Welcome", subtitle="Enjoy your stay")
    rendered_html = await header.render(request)
    ```

    The `context` method can be overridden to provide custom context data for the Jinja templates.

    ```python
    class UserCardComponent(ComponentModel):
        template: str = "components/user_card.html"
        user_id: int

        def context(self) -> dict[str, t.Any]:
            user = get_user_from_db(self.user_id)
            return {"user": user}

    user_card = UserCardComponent(user_id=42)
    rendered_html = await user_card.render(request)
    ```

    Attributes:
        id (str): Unique identifier for this component. Auto-generated by default.
        template (str): Path to the Jinja2 template used to render this component. Required.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True, extra="allow")

    id: str = Field(default_factory=generate_component_id)
    """Unique identifier for this component. Auto-generated by default."""
    template: str
    """Path to the Jinja2 template used to render this component."""

    @classmethod
    def prepare_field_params(
        cls,
        params: dict[str, t.Any],
        field_value: t.Any,
    ) -> dict[str, t.Any]:
        """Transform form field params before component instantiation.

        Override in subclasses that need special handling when used with FormModel.
        For example, Select components need to convert choices to SelectOption objects,
        and Checkbox components need to set checked state from the field value.

        By default, this method sets the 'value' param to the field value.

        Args:
            params: Parameters from the form field's json_schema_extra
            field_value: The current value of the form field

        Returns:
            Modified params dict ready for component instantiation
        """
        params["value"] = field_value
        return params

    def context(self, jinja_context: dict[str, t.Any], request: Request) -> dict[str, t.Any]:
        """Context variables to set in parent template when this component is used.

        Override this method to set context variables that should be available
        to the parent template. For example, components can set library inclusion
        flags like `include_datatables` or any other context variables.

        Args:
            jinja_context: The current Jinja2 rendering context
            request: The Starlette Request object

        Returns:
            Dictionary of context variables to merge into parent template context
        """
        return {}

    async def render(self, request: Request, **kwargs) -> Markup:
        """Render this component to HTML."""
        # Start with kwargs and basic context
        ctx = {"request": request, **kwargs}

        # Process each field, rendering nested ComponentModel instances
        for name, value in self:
            if isinstance(value, ComponentModel):
                ctx[name] = await value.render(request)
            elif isinstance(value, list):
                # Check if it's a list of components or markup
                if value and (isinstance(value[0], ComponentModel) or isinstance(value[0], Markup)):
                    # Render list of components/markup and join them
                    rendered_children = []
                    for child in value:
                        if isinstance(child, ComponentModel):
                            rendered_children.append(await child.render(request))
                        elif isinstance(child, Markup):
                            rendered_children.append(child)
                        else:
                            # String content
                            rendered_children.append(str(child))
                    ctx[name] = Markup("".join(rendered_children))
                else:
                    # Empty list or list of non-components - render as empty string for templates
                    ctx[name] = Markup("") if not value else value
            else:
                ctx[name] = value

        template_env = request.state.jinja_env
        template = template_env.get_template(self.template)
        rendered = await template.render_async(ctx)
        return Markup(rendered)


def create_component_renderer(component_class: type[ComponentModel]) -> t.Callable:
    """Create an async function that renders a component in Jinja2 templates.

    This factory creates a Jinja2-compatible async function that:
    1. Accepts component parameters as kwargs
    2. Instantiates the component with those parameters
    3. Extracts the request from Jinja2 context
    4. Renders the component and returns Markup

    Args:
        component_class: The ComponentModel subclass to render

    Returns:
        An async function compatible with Jinja2 globals
    """

    @pass_context
    async def render_component(context: dict[str, t.Any], **kwargs: t.Any) -> Markup:
        # Get request from Jinja2 context
        request = context.get("request")
        if not request:
            raise RuntimeError(f"Cannot render {component_class.__name__}: 'request' not in template context")

        # Instantiate the component with provided kwargs
        component = component_class(**kwargs)

        # Call context() method to inject variables into parent template
        # This allows components to set library inclusion flags, share data, etc.
        component_context = component.context(context, request)
        if component_context:
            context.vars.update(component_context)

        # Render and return
        return await component.render(request)

    # Set function name for better debugging
    render_component.__name__ = component_class.__name__
    return render_component


def register_components(jinja_env: Environment, module: object) -> None:
    """Auto-register ComponentModel subclasses as Jinja2 global functions.

    This discovers all components from a module or registers a single ComponentModel class
    as async rendering functions in the Jinja2 environment.

    Components can then be used in templates like:
    ```html
    {{ Button(content='Click me', variant='primary') }}
    {{ Table(data='users', striped=True) }}
    ```

    Args:
        jinja_env: Jinja2 environment to register components
        module: Module containing ComponentModel subclasses, or a single ComponentModel class
    """
    # Check if it's a single ComponentModel class
    if isinstance(module, type) and issubclass(module, ComponentModel) and module is not ComponentModel:
        # Register individual ComponentModel class
        renderer = create_component_renderer(module)
        jinja_env.globals[module.__name__] = renderer
        return

    # Otherwise treat it as a module - iterate through all exports from module
    for name in module.__all__:
        try:
            component_class = getattr(module, name)

            # Register ComponentModel subclasses (not ComponentModel itself)
            if (
                isinstance(component_class, type)
                and issubclass(component_class, ComponentModel)
                and component_class is not ComponentModel
            ):
                # Create and register the renderer function
                renderer = create_component_renderer(component_class)
                jinja_env.globals[name] = renderer
            # Also register BaseModel subclasses (helper models like TabItem, AccordionItem, etc.)
            elif (
                isinstance(component_class, type)
                and issubclass(component_class, BaseModel)
                and component_class is not BaseModel
                and component_class is not ComponentModel
            ):
                # Register the class directly for use as data models in templates
                jinja_env.globals[name] = component_class

        except AttributeError:
            # Skip if attribute doesn't exist
            continue
