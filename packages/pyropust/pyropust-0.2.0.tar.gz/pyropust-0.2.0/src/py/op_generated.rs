// This file is auto-generated by tools/gen_ops.py
// Do not edit manually!

use crate::ops::OperatorKind;
use crate::py::operator::Operator;
use pyo3::prelude::*;

/// Namespace for coerce operations
#[pyclass(frozen, name = "OpCoerce")]
pub struct OpCoerce;

#[pymethods]
impl OpCoerce {
    #[staticmethod]
    pub fn assert_str() -> Operator {
        Operator {
            kind: OperatorKind::AssertStr,
        }
    }

    #[staticmethod]
    pub fn expect_str() -> Operator {
        Operator {
            kind: OperatorKind::ExpectStr,
        }
    }

    #[staticmethod]
    pub fn as_str() -> Operator {
        Operator {
            kind: OperatorKind::AsStr,
        }
    }

    #[staticmethod]
    pub fn as_int() -> Operator {
        Operator {
            kind: OperatorKind::AsInt,
        }
    }

    #[staticmethod]
    pub fn as_float() -> Operator {
        Operator {
            kind: OperatorKind::AsFloat,
        }
    }

    #[staticmethod]
    pub fn as_bool() -> Operator {
        Operator {
            kind: OperatorKind::AsBool,
        }
    }

    #[staticmethod]
    pub fn as_datetime(format: String) -> Operator {
        Operator {
            kind: OperatorKind::AsDatetime { format },
        }
    }

    #[staticmethod]
    pub fn json_decode() -> Operator {
        Operator {
            kind: OperatorKind::JsonDecode,
        }
    }
}

/// Namespace for core operations
#[pyclass(frozen, name = "OpCore")]
pub struct OpCore;

#[pymethods]
impl OpCore {
    #[staticmethod]
    pub fn map_py(func: Py<PyAny>) -> Operator {
        Operator {
            kind: OperatorKind::MapPy { func },
        }
    }

    #[staticmethod]
    pub fn is_null() -> Operator {
        Operator {
            kind: OperatorKind::IsNull,
        }
    }

    #[staticmethod]
    pub fn is_empty() -> Operator {
        Operator {
            kind: OperatorKind::IsEmpty,
        }
    }

    #[staticmethod]
    pub fn len() -> Operator {
        Operator {
            kind: OperatorKind::Len,
        }
    }
}

/// Namespace for map operations
#[pyclass(frozen, name = "OpMap")]
pub struct OpMap;

#[pymethods]
impl OpMap {
    #[staticmethod]
    pub fn get(key: String) -> Operator {
        Operator {
            kind: OperatorKind::GetKey { key },
        }
    }

    #[staticmethod]
    pub fn get_or(key: String, default: Py<PyAny>) -> Operator {
        Operator {
            kind: OperatorKind::GetOr { key, default },
        }
    }

    #[staticmethod]
    pub fn keys() -> Operator {
        Operator {
            kind: OperatorKind::Keys,
        }
    }

    #[staticmethod]
    pub fn values() -> Operator {
        Operator {
            kind: OperatorKind::Values,
        }
    }
}

/// Namespace for seq operations
#[pyclass(frozen, name = "OpSeq")]
pub struct OpSeq;

#[pymethods]
impl OpSeq {
    #[staticmethod]
    pub fn index(idx: usize) -> Operator {
        Operator {
            kind: OperatorKind::Index { idx },
        }
    }

    #[staticmethod]
    pub fn slice(start: usize, end: usize) -> Operator {
        Operator {
            kind: OperatorKind::Slice { start, end },
        }
    }

    #[staticmethod]
    pub fn first() -> Operator {
        Operator {
            kind: OperatorKind::First,
        }
    }

    #[staticmethod]
    pub fn last() -> Operator {
        Operator {
            kind: OperatorKind::Last,
        }
    }
}

/// Namespace for text operations
#[pyclass(frozen, name = "OpText")]
pub struct OpText;

#[pymethods]
impl OpText {
    #[staticmethod]
    pub fn split(delim: String) -> Operator {
        Operator {
            kind: OperatorKind::Split { delim },
        }
    }

    #[staticmethod]
    pub fn trim() -> Operator {
        Operator {
            kind: OperatorKind::Trim,
        }
    }

    #[staticmethod]
    pub fn lower() -> Operator {
        Operator {
            kind: OperatorKind::Lower,
        }
    }

    #[staticmethod]
    pub fn replace(old: String, new: String) -> Operator {
        Operator {
            kind: OperatorKind::Replace { old, new },
        }
    }

    #[staticmethod]
    pub fn to_uppercase() -> Operator {
        Operator {
            kind: OperatorKind::ToUppercase,
        }
    }

    #[staticmethod]
    pub fn len() -> Operator {
        Operator {
            kind: OperatorKind::Len,
        }
    }
}

/// Static factory class for creating Operators
#[pyclass(frozen, name = "Op")]
pub struct Op;

#[pymethods]
impl Op {
    #[classattr]
    fn coerce() -> OpCoerce {
        OpCoerce
    }

    #[classattr]
    fn core() -> OpCore {
        OpCore
    }

    #[classattr]
    fn map() -> OpMap {
        OpMap
    }

    #[classattr]
    fn seq() -> OpSeq {
        OpSeq
    }

    #[classattr]
    fn text() -> OpText {
        OpText
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn assert_str() -> Operator {
        OpCoerce::assert_str()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn expect_str() -> Operator {
        OpCoerce::expect_str()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn as_str() -> Operator {
        OpCoerce::as_str()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn as_int() -> Operator {
        OpCoerce::as_int()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn as_float() -> Operator {
        OpCoerce::as_float()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn as_bool() -> Operator {
        OpCoerce::as_bool()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn as_datetime(format: String) -> Operator {
        OpCoerce::as_datetime(format)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn json_decode() -> Operator {
        OpCoerce::json_decode()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn map_py(func: Py<PyAny>) -> Operator {
        OpCore::map_py(func)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn is_null() -> Operator {
        OpCore::is_null()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn is_empty() -> Operator {
        OpCore::is_empty()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn len() -> Operator {
        OpCore::len()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn get(key: String) -> Operator {
        OpMap::get(key)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn get_or(key: String, default: Py<PyAny>) -> Operator {
        OpMap::get_or(key, default)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn keys() -> Operator {
        OpMap::keys()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn values() -> Operator {
        OpMap::values()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn index(idx: usize) -> Operator {
        OpSeq::index(idx)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn slice(start: usize, end: usize) -> Operator {
        OpSeq::slice(start, end)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn first() -> Operator {
        OpSeq::first()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn last() -> Operator {
        OpSeq::last()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn split(delim: String) -> Operator {
        OpText::split(delim)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn trim() -> Operator {
        OpText::trim()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn lower() -> Operator {
        OpText::lower()
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn replace(old: String, new: String) -> Operator {
        OpText::replace(old, new)
    }

    /// Alias for backward compatibility
    #[staticmethod]
    pub fn to_uppercase() -> Operator {
        OpText::to_uppercase()
    }
}
