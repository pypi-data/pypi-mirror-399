"""Generate pyropust_native.pyi from pyropust/__init__.pyi.

This script extracts the native module type definitions from the public API stub,
excluding Python-only implementations (do, catch) that don't exist in the Rust module.

Usage:
    python tools/gen_native_stub.py
"""
# ruff: noqa: T201  # Allow print() in this tool

from pathlib import Path

# Imports used only by excluded definitions (do, catch, Do type alias)
UNUSED_IMPORTS_IN_NATIVE = ["Generator", "overload"]

HEADER = """\
# Auto-generated by tools/gen_native_stub.py
# Do not edit manually! Edit pyropust/__init__.pyi instead.
#
# This file provides type information for the native Rust module.
# For the public API, see pyropust/__init__.pyi.

"""


def _clean_import_line(line: str) -> str | None:
    """Remove unused imports from an import line. Returns None if line becomes empty."""
    # Handle: from typing import Generic, Never, TypeVar, overload
    if line.startswith("from ") and "import" in line:
        prefix, imports_part = line.split("import", 1)
        imports = [imp.strip() for imp in imports_part.split(",")]
        filtered = [imp for imp in imports if imp not in UNUSED_IMPORTS_IN_NATIVE]
        if not filtered:
            return None
        return f"{prefix}import {', '.join(filtered)}"
    return line


def extract_native_stub(init_pyi_content: str) -> str:
    """Extract native module types from __init__.pyi content."""
    lines = init_pyi_content.split("\n")
    result_lines: list[str] = []

    i = 0
    while i < len(lines):
        line = lines[i]

        # Skip type Do = ... (single line)
        if line.startswith("type Do"):
            i += 1
            continue

        # Skip def do (single line with ...)
        if line.startswith("def do"):
            i += 1
            continue

        # Skip catch-related blocks (overloads and main definition)
        if "# Overload" in line and "catch" in line:
            # Skip comment, @overload decorator, and def line
            while i < len(lines) and not lines[i].strip().endswith("..."):
                i += 1
            i += 1  # Skip the ... line
            continue

        if line.startswith("@overload") and i + 1 < len(lines) and "def catch" in lines[i + 1]:
            # Skip @overload and def catch lines
            i += 1  # Skip @overload
            while i < len(lines) and not lines[i].strip().endswith("..."):
                i += 1
            i += 1  # Skip the ... line
            continue

        if line.startswith("def catch"):
            i += 1
            continue

        # Skip __all__
        if line.startswith("__all__"):
            i += 1
            continue

        # Clean up imports
        if line.startswith("from ") and "import" in line:
            cleaned = _clean_import_line(line)
            if cleaned:
                result_lines.append(cleaned)
            i += 1
            continue

        result_lines.append(line)
        i += 1

    # Clean up: remove excessive blank lines at end
    while result_lines and result_lines[-1] == "":
        result_lines.pop()

    # Add trailing newline
    result_lines.append("")

    return HEADER + "\n".join(result_lines)


def main() -> None:
    """Run the native stub generator."""
    root = Path(__file__).parent.parent
    init_pyi = root / "pyropust/__init__.pyi"
    native_pyi = root / "pyropust/pyropust_native.pyi"

    print(f"ðŸ“– Reading {init_pyi}...")
    init_content = init_pyi.read_text()

    print("ðŸ”§ Extracting native module types...")
    native_content = extract_native_stub(init_content)

    print(f"ðŸ“ Writing {native_pyi}...")
    native_pyi.write_text(native_content)

    # Count lines for summary
    init_lines = len(init_content.split("\n"))
    native_lines = len(native_content.split("\n"))
    print(f"   {init_lines} lines -> {native_lines} lines (excluded Python-only definitions)")

    print("âœ… Done!")


if __name__ == "__main__":
    main()
