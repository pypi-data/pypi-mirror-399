from collections.abc import Callable, Generator, Mapping, Sequence
from datetime import datetime
from typing import Generic, Never, TypeVar, overload

# Variance-sensitive type parameters require old-style TypeVar
T_co = TypeVar("T_co", covariant=True)
In_contra = TypeVar("In_contra", contravariant=True)
Out_co = TypeVar("Out_co", covariant=True)

class Result(Generic[T_co]):
    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def is_ok_and(self, predicate: Callable[[T_co], object]) -> bool: ...
    def is_err_and(self, predicate: Callable[[RopustError], object]) -> bool: ...
    def unwrap(self) -> T_co: ...
    def unwrap_err(self) -> RopustError: ...
    def expect(self, msg: str) -> T_co: ...
    def expect_err(self, msg: str) -> RopustError: ...
    def unwrap_or[U](self, default: U) -> T_co | U: ...
    def unwrap_or_else[U](self, f: Callable[[RopustError], U]) -> T_co | U: ...
    def ok(self) -> Option[T_co]: ...
    def err(self) -> Option[RopustError]: ...
    def map[U](self, f: Callable[[T_co], U]) -> Result[U]: ...
    def map_err(self, f: Callable[[RopustError], RopustError]) -> Result[T_co]: ...
    def map_or[U](self, default: U, f: Callable[[T_co], U]) -> U: ...
    def map_or_else[U](
        self, default_f: Callable[[RopustError], U], f: Callable[[T_co], U]
    ) -> U: ...
    def inspect(self, f: Callable[[T_co], object]) -> Result[T_co]: ...
    def inspect_err(self, f: Callable[[RopustError], object]) -> Result[T_co]: ...
    def context(
        self,
        message: str,
        *,
        code: str = "context",
        metadata: Mapping[str, str] | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
    ) -> Result[T_co]: ...
    def with_code(self, code: str) -> Result[T_co]: ...
    def map_err_code(self, prefix: str) -> Result[T_co]: ...
    def and_[U](self, other: Result[U]) -> Result[U]: ...
    def or_(self, other: Result[T_co]) -> Result[T_co]: ...
    def or_else(self, f: Callable[[RopustError], Result[T_co]]) -> Result[T_co]: ...
    def and_then[U](self, f: Callable[[T_co], Result[U]]) -> Result[U]: ...
    def flatten[T](self: Result[Result[T]]) -> Result[T]: ...
    def transpose[T](self: Result[Option[T]]) -> Option[Result[T]]: ...
    def unwrap_or_raise(self, exc: BaseException) -> T_co: ...
    @classmethod
    def attempt[T](cls, f: Callable[[], T], *exceptions: type[BaseException]) -> Result[T]: ...

class Option(Generic[T_co]):
    def is_some(self) -> bool: ...
    def is_none(self) -> bool: ...
    def is_some_and(self, predicate: Callable[[T_co], object]) -> bool: ...
    def is_none_or(self, predicate: Callable[[T_co], object]) -> bool: ...
    def unwrap(self) -> T_co: ...
    def expect(self, msg: str) -> T_co: ...
    def unwrap_or[U](self, default: U) -> T_co | U: ...
    def unwrap_or_else[U](self, f: Callable[[], U]) -> T_co | U: ...
    def map[U](self, f: Callable[[T_co], U]) -> Option[U]: ...
    def map_or[U](self, default: U, f: Callable[[T_co], U]) -> U: ...
    def map_or_else[U](self, default_f: Callable[[], U], f: Callable[[T_co], U]) -> U: ...
    def inspect(self, f: Callable[[T_co], object]) -> Option[T_co]: ...
    def filter(self, predicate: Callable[[T_co], object]) -> Option[T_co]: ...
    def and_[U](self, other: Option[U]) -> Option[U]: ...
    def and_then[U](self, f: Callable[[T_co], Option[U]]) -> Option[U]: ...
    def or_(self, other: Option[T_co]) -> Option[T_co]: ...
    def or_else(self, f: Callable[[], Option[T_co]]) -> Option[T_co]: ...
    def xor(self, other: Option[T_co]) -> Option[T_co]: ...
    def flatten[T](self: Option[Option[T]]) -> Option[T]: ...
    def transpose[T](self: Option[Result[T]]) -> Result[Option[T]]: ...
    def zip[U](self, other: Option[U]) -> Option[tuple[T_co, U]]: ...
    def zip_with[U, R](self, other: Option[U], f: Callable[[T_co, U], R]) -> Option[R]: ...
    def ok_or(self, error: RopustError | BaseException | str) -> Result[T_co]: ...
    def ok_or_else(self, f: Callable[[], RopustError | BaseException | str]) -> Result[T_co]: ...

class ErrorKind:
    InvalidInput: ErrorKind
    NotFound: ErrorKind
    Internal: ErrorKind

class RopustError:
    @property
    def kind(self) -> ErrorKind: ...
    @property
    def code(self) -> str: ...
    @property
    def message(self) -> str: ...
    @property
    def metadata(self) -> dict[str, str]: ...
    @property
    def op(self) -> str | None: ...
    @property
    def path(self) -> list[str | int]: ...
    @property
    def expected(self) -> str | None: ...
    @property
    def got(self) -> str | None: ...
    @property
    def cause(self) -> str | None: ...
    def to_dict(self) -> dict[str, object]: ...
    @classmethod
    def from_dict(cls, data: dict[str, object]) -> RopustError: ...
    @classmethod
    def new(
        cls,
        code: str,
        message: str,
        *,
        kind: ErrorKind | str | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        metadata: Mapping[str, str] | None = None,
    ) -> RopustError: ...
    @classmethod
    def wrap(
        cls,
        err: BaseException | RopustError,
        *,
        code: str,
        message: str,
        kind: ErrorKind | str | None = None,
        op: str | None = None,
        path: list[str | int] | None = None,
        expected: str | None = None,
        got: str | None = None,
        metadata: Mapping[str, str] | None = None,
    ) -> RopustError: ...

class Operator(Generic[In_contra, Out_co]): ...

# BEGIN GENERATED NS

class OpCoerce:
    @staticmethod
    def assert_str() -> Operator[object, str]: ...
    @staticmethod
    def expect_str() -> Operator[object, str]: ...
    @staticmethod
    def as_str() -> Operator[object, str]: ...
    @staticmethod
    def as_int() -> Operator[object, int]: ...
    @staticmethod
    def as_float() -> Operator[object, float]: ...
    @staticmethod
    def as_bool() -> Operator[object, bool]: ...
    @staticmethod
    def as_datetime(format: str) -> Operator[object, datetime]: ...
    @staticmethod
    def json_decode() -> Operator[str | bytes, Mapping[str, object]]: ...

class OpCore:
    @staticmethod
    def map_py[T, U](func: Callable[[T], U]) -> Operator[T, U]: ...
    @staticmethod
    def is_null() -> Operator[object, bool]: ...
    @staticmethod
    def is_empty() -> Operator[object, bool]: ...
    @staticmethod
    def len() -> Operator[object, int]: ...

class OpMap:
    @staticmethod
    def get(key: str) -> Operator[Mapping[str, object], object]: ...
    @staticmethod
    def get_or[T](key: str, default: T) -> Operator[Mapping[str, T], T]: ...
    @staticmethod
    def keys() -> Operator[Mapping[str, object], list[str]]: ...
    @staticmethod
    def values() -> Operator[Mapping[str, object], list[object]]: ...

class OpSeq:
    @staticmethod
    def index(idx: int) -> Operator[Sequence[object], object]: ...
    @staticmethod
    def slice(start: int, end: int) -> Operator[Sequence[object], list[object]]: ...
    @staticmethod
    def first() -> Operator[Sequence[object], object]: ...
    @staticmethod
    def last() -> Operator[Sequence[object], object]: ...

class OpText:
    @staticmethod
    def split(delim: str) -> Operator[str, list[str]]: ...
    @staticmethod
    def trim() -> Operator[str, str]: ...
    @staticmethod
    def lower() -> Operator[str, str]: ...
    @staticmethod
    def replace(old: str, new: str) -> Operator[str, str]: ...
    @staticmethod
    def to_uppercase() -> Operator[str, str]: ...
    @staticmethod
    def len() -> Operator[object, int]: ...

# END GENERATED NS

class Blueprint[OrigIn, Out]:
    def __new__(cls) -> Blueprint[object, object]: ...
    @classmethod
    def for_type[T_in](cls, t: type[T_in]) -> Blueprint[T_in, T_in]: ...
    @classmethod
    def any(cls) -> Blueprint[object, object]: ...
    def pipe[NextOut](self, operator: Operator[Out, NextOut]) -> Blueprint[OrigIn, NextOut]: ...
    def guard_str(self: Blueprint[OrigIn, object]) -> Blueprint[OrigIn, str]: ...

class Op:
    # BEGIN GENERATED OP
    coerce: OpCoerce
    core: OpCore
    map: OpMap
    seq: OpSeq
    text: OpText
    @staticmethod
    def assert_str() -> Operator[object, str]: ...
    @staticmethod
    def expect_str() -> Operator[object, str]: ...
    @staticmethod
    def as_str() -> Operator[object, str]: ...
    @staticmethod
    def as_int() -> Operator[object, int]: ...
    @staticmethod
    def as_float() -> Operator[object, float]: ...
    @staticmethod
    def as_bool() -> Operator[object, bool]: ...
    @staticmethod
    def as_datetime(format: str) -> Operator[object, datetime]: ...
    @staticmethod
    def json_decode() -> Operator[str | bytes, Mapping[str, object]]: ...
    @staticmethod
    def map_py[T, U](func: Callable[[T], U]) -> Operator[T, U]: ...
    @staticmethod
    def is_null() -> Operator[object, bool]: ...
    @staticmethod
    def is_empty() -> Operator[object, bool]: ...
    @staticmethod
    def len() -> Operator[object, int]: ...
    @staticmethod
    def get(key: str) -> Operator[Mapping[str, object], object]: ...
    @staticmethod
    def get_or[T](key: str, default: T) -> Operator[Mapping[str, T], T]: ...
    @staticmethod
    def keys() -> Operator[Mapping[str, object], list[str]]: ...
    @staticmethod
    def values() -> Operator[Mapping[str, object], list[object]]: ...
    @staticmethod
    def index(idx: int) -> Operator[Sequence[object], object]: ...
    @staticmethod
    def slice(start: int, end: int) -> Operator[Sequence[object], list[object]]: ...
    @staticmethod
    def first() -> Operator[Sequence[object], object]: ...
    @staticmethod
    def last() -> Operator[Sequence[object], object]: ...
    @staticmethod
    def split(delim: str) -> Operator[str, list[str]]: ...
    @staticmethod
    def trim() -> Operator[str, str]: ...
    @staticmethod
    def lower() -> Operator[str, str]: ...
    @staticmethod
    def replace(old: str, new: str) -> Operator[str, str]: ...
    @staticmethod
    def to_uppercase() -> Operator[str, str]: ...
    # END GENERATED OP

def Ok[T](value: T) -> Result[T]: ...
def Err(error: RopustError | BaseException | str) -> Result[Never]: ...
def Some[T](value: T) -> Option[T]: ...
def None_() -> Option[Never]: ...

type Do[T, R] = Generator[Result[T], T, Result[R]]

def do[**P, T, R](fn: Callable[P, Do[T, R]]) -> Callable[P, Result[R]]: ...
def run[OrigIn, Out](blueprint: Blueprint[OrigIn, Out], input: OrigIn) -> Result[Out]: ...
def exception_to_ropust_error(exc: BaseException, code: str = "py_exception") -> RopustError: ...

# Overload 1: Decorator with exception types (@catch() or @catch(ValueError, ...))
# Note: mypy reports overlap with overload 3 because type[BaseException] and Callable
# cannot be distinguished statically, but runtime correctly handles this.
@overload
def catch[R](  # type: ignore[overload-overlap]
    exc: type[BaseException],
    /,
    *more_exceptions: type[BaseException],
) -> Callable[[Callable[..., R]], Callable[..., Result[R]]]: ...

# Overload 2: Decorator without arguments (@catch())
@overload
def catch[R]() -> Callable[[Callable[..., R]], Callable[..., Result[R]]]: ...

# Overload 3: Bare decorator usage (@catch)
@overload
def catch[R](fn: Callable[..., R], /) -> Callable[..., Result[R]]: ...

__all__: list[str]
