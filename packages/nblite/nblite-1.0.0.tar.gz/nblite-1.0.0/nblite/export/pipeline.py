"""
Export pipeline for nblite.

Handles exporting notebooks to different formats and to Python modules.
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from pathlib import Path

from nblite.config.schema import ExportMode
from nblite.core.notebook import Format, Notebook
from nblite.export.function_export import export_function_notebook, is_function_notebook

__all__ = [
    "export_notebook_to_notebook",
    "export_notebook_to_module",
    "ExportResult",
]


# Pattern to extract function/class names for __all__
FUNCTION_PATTERN = re.compile(r"^(?:async\s+)?def\s+(\w+)\s*\(", re.MULTILINE)
CLASS_PATTERN = re.compile(r"^class\s+(\w+)\s*[\(:]", re.MULTILINE)
VARIABLE_PATTERN = re.compile(r"^([A-Z][A-Z0-9_]*)\s*=", re.MULTILINE)


@dataclass
class ExportResult:
    """Result of an export operation."""

    success: bool = True
    files_created: list[Path] = field(default_factory=list)
    files_updated: list[Path] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)


def export_notebook_to_notebook(
    notebook: Notebook,
    output_path: Path | str,
    format: str | None = None,
) -> None:
    """
    Export a notebook to another notebook format.

    Args:
        notebook: Source notebook
        output_path: Output path for the notebook
        format: Output format (ipynb, percent). Auto-detected if None.
    """
    output_path = Path(output_path)

    if format is None:
        format = Format.from_path(output_path)

    content = notebook.to_string(format)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)


def export_notebook_to_module(
    notebook: Notebook,
    output_path: Path | str,
    export_mode: ExportMode = ExportMode.PERCENT,
    include_warning: bool = True,
    cell_reference_style: str = "relative",
) -> None:
    """
    Export a notebook to a Python module.

    Args:
        notebook: Source notebook
        output_path: Output path for the module
        export_mode: Export mode (percent with cell markers, or py without)
        include_warning: Include autogenerated warning header
        cell_reference_style: Style for cell references (relative or absolute)
    """
    output_path = Path(output_path)

    # Check if this is a function notebook
    if is_function_notebook(notebook):
        export_function_notebook(
            notebook,
            output_path,
            include_warning=include_warning,
        )
        return

    source_path = notebook.source_path

    # Calculate relative path for cell references
    if source_path and cell_reference_style == "relative":
        try:
            source_ref = str(source_path.relative_to(output_path.parent.parent))
        except ValueError:
            source_ref = str(source_path)
    else:
        source_ref = str(source_path) if source_path else "unknown"

    # Collect exported cells
    exported_content = _collect_exported_content(notebook, export_mode, source_ref)

    # Build module content
    lines: list[str] = []

    # Add autogenerated header
    if include_warning:
        lines.append(f"# AUTOGENERATED! DO NOT EDIT! File to edit: {source_ref}")
        lines.append("")

    # Add __all__ list
    all_names = _extract_public_names(exported_content)
    if all_names:
        all_str = ", ".join(f"'{name}'" for name in sorted(all_names))
        lines.append(f"__all__ = [{all_str}]")
        lines.append("")

    # Add content
    lines.append(exported_content)

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))


def _collect_exported_content(
    notebook: Notebook,
    export_mode: ExportMode,
    source_ref: str,
) -> str:
    """Collect content from exported cells."""
    parts: list[str] = []

    for cell in notebook.cells:
        if not cell.is_code:
            continue

        # Check for export directives
        has_export = cell.has_directive("export") or cell.has_directive("exporti")
        has_export_to = cell.has_directive("export_to")

        if not (has_export or has_export_to):
            continue

        # Get source without directives
        source = cell.source_without_directives.strip()
        if not source:
            continue

        if export_mode == ExportMode.PERCENT:
            # Add cell marker
            parts.append(f"# %% {source_ref} {cell.index}")
            parts.append(source)
            parts.append("")
        else:
            # Plain Python mode
            parts.append(source)
            parts.append("")

    return "\n".join(parts)


def _extract_public_names(content: str) -> list[str]:
    """Extract public names (functions, classes, constants) from content."""
    names: list[str] = []

    # Find functions
    for match in FUNCTION_PATTERN.finditer(content):
        name = match.group(1)
        if not name.startswith("_"):
            names.append(name)

    # Find classes
    for match in CLASS_PATTERN.finditer(content):
        name = match.group(1)
        if not name.startswith("_"):
            names.append(name)

    # Find constants (UPPERCASE variables)
    for match in VARIABLE_PATTERN.finditer(content):
        name = match.group(1)
        names.append(name)

    return names
