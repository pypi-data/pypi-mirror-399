from __future__ import annotations

import logging
import os
from pathlib import Path
from typing import Dict, Optional, Tuple

from dulwich import porcelain
from dulwich.config import StackedConfig
from dulwich.repo import Repo
from github import Auth, Github
from github.Repository import Repository

from .base import SubmitChange
from pr_creator.git_urls import github_slug_from_url, token_auth_github_url

logger = logging.getLogger(__name__)


def _load_repo(repo_path: Path) -> Repo:
    return Repo.discover(str(repo_path))


def _origin_url(repo: Repo) -> str:
    cfg: StackedConfig = repo.get_config()
    url_bytes = cfg.get((b"remote", b"origin"), b"url")
    return url_bytes.decode()


def _current_branch(repo: Repo) -> str:
    """Get the current branch (assumes HEAD points to the desired branch)."""
    head = repo.refs.read_ref(b"HEAD")
    if head and head.startswith(b"refs/heads/"):
        return head[len(b"refs/heads/") :].decode()
    # Fallback: pick a branch whose ref matches HEAD target, or any branch
    head_sha = repo.refs.read_ref(b"HEAD")
    for ref_name in repo.refs.keys():
        if ref_name.startswith(b"refs/heads/") and repo.refs[ref_name] == head_sha:
            return ref_name[len(b"refs/heads/") :].decode()
    for ref_name in repo.refs.keys():
        if ref_name.startswith(b"refs/heads/"):
            return ref_name[len(b"refs/heads/") :].decode()
    raise RuntimeError("HEAD is not pointing to a branch; clone step should set it")


def _config_value(
    cfg: StackedConfig, section: tuple[bytes, ...], name: bytes
) -> Optional[str]:
    try:
        value = cfg.get(section, name)
    except KeyError:
        return None
    if isinstance(value, bytes):
        return value.decode()
    return str(value)


def _ensure_identity(repo: Repo) -> tuple[str, str]:
    cfg = repo.get_config()
    name = os.environ.get("GIT_AUTHOR_NAME") or _config_value(cfg, (b"user",), b"name")
    email = os.environ.get("GIT_AUTHOR_EMAIL") or _config_value(
        cfg, (b"user",), b"email"
    )
    author = f"{name or 'pr-creator'} <{email or 'pr-creator@example.com'}>"
    return author, author


def _git_status_dirty(repo: Repo) -> bool:
    status = porcelain.status(repo)
    return bool(status.staged or status.unstaged or status.untracked)


def _commit_changes(repo: Repo, message: str) -> None:
    author, committer = _ensure_identity(repo)
    porcelain.add(repo.path)
    porcelain.commit(
        repo.path,
        message=message,
        author=author.encode(),
        committer=committer.encode(),
        sign=False,
    )


def _push_branch(repo: Repo, branch: str, token: str, origin_url: str) -> None:
    """Push branch to remote."""
    push_url = token_auth_github_url(origin_url, token)
    if not push_url:
        raise RuntimeError(f"Unsupported origin URL for token push: {origin_url}")

    refspec = f"refs/heads/{branch}:refs/heads/{branch}"
    logger.info("[submit] pushing %s", refspec)
    porcelain.push(repo.path, push_url, refspecs=[refspec])


def _build_pr_body(base_body: str, change_prompt: Optional[str]) -> str:
    """Build PR body with optional change prompt."""
    if change_prompt:
        return f"{base_body}\n\n## Change Prompt\n\n{change_prompt}"
    return base_body


def _get_remote_repo_and_base_branch(
    origin: str, github_token: Optional[str], base_branch: Optional[str]
) -> Tuple[Optional[Repository], str]:
    """Get remote repository and determine base branch."""
    if not github_token:
        return None, base_branch or "main"

    gh = Github(auth=Auth.Token(github_token))
    slug = github_slug_from_url(origin)
    if not slug:
        return None, base_branch or "main"

    remote_repo = gh.get_repo(slug)
    if base_branch is None:
        base_branch = remote_repo.default_branch

    return remote_repo, base_branch or "main"


class GithubSubmitter(SubmitChange):
    def __init__(self) -> None:
        self.base_branch = os.environ.get("SUBMIT_PR_BASE") or None
        self.commit_message = os.environ.get(
            "SUBMIT_COMMIT_MESSAGE", "Automated changes"
        )
        self.pr_title = os.environ.get("SUBMIT_PR_TITLE", self.commit_message)
        self.pr_body = os.environ.get(
            "SUBMIT_PR_BODY", "Automated changes generated by pr-creator."
        )
        self.branch_prefix = os.environ.get("SUBMIT_BRANCH_PREFIX", "auto/pr")
        self.github_token = os.environ.get("GITHUB_TOKEN")

    def submit(
        self,
        repo_path: Path,
        change_prompt: str | None = None,
        change_id: str | None = None,
    ) -> Optional[Dict[str, str]]:
        repo = _load_repo(Path(repo_path))
        origin = _origin_url(repo)

        # Get current branch (clone step already checked it out)
        branch = _current_branch(repo)
        logger.info("[submit] current branch=%s", branch)

        # Get remote repo and base branch
        remote_repo, base_branch = _get_remote_repo_and_base_branch(
            origin, self.github_token, self.base_branch
        )

        pr_body = _build_pr_body(self.pr_body, change_prompt)

        # No existing PR - check if there are changes to commit
        if not _git_status_dirty(repo):
            logger.info("[submit] no changes to commit; skipping PR creation")
            return None

        # Commit and push changes
        _commit_changes(repo, self.commit_message)
        _push_branch(repo, branch, self.github_token, origin)

        if not remote_repo:
            logger.warning("GITHUB_TOKEN not set; skipping PR creation")
            return {"repo_url": origin, "branch": branch, "pr_url": None}

        # Avoid creating PR when head matches base (no-op PR)
        if branch == base_branch:
            logger.warning(
                "Current branch '%s' matches base '%s'; skipping PR creation",
                branch,
                base_branch,
            )
            return {"repo_url": origin, "branch": branch, "pr_url": None}

        # Create new PR
        logger.info("[submit] creating PR head=%s base=%s", branch, base_branch)
        pr = remote_repo.create_pull(
            title=self.pr_title,
            body=pr_body,
            head=branch,
            base=base_branch,
        )
        return {"repo_url": origin, "branch": branch, "pr_url": pr.html_url}
