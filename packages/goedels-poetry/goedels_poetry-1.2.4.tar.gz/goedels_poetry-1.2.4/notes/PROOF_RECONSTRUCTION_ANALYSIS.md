# Proof Reconstruction Failure Analysis

## Problem Summary

Proof reconstruction from decomposed subgoals fails, leaving `sorry` statements in the final proof instead of inlining the child proofs. In the example case from `partial.log`, two `sorry` statements remain:
- Line 11: `sorry` in `have hv_rewrite` statement
- Line 16: `sorry` in `have hcalc` statement

## Root Cause Analysis

### Issue 1: Pattern Doesn't Handle Comments Between `:= by` and `sorry` (PRIMARY BUG)

**Location**: `goedels_poetry/state.py`, line 1726 in `_replace_sorry_for_have()`

**Problem**: The regex pattern expects `sorry` to immediately follow `by` (with only whitespace), but the actual sketch has comments between them.

**Current pattern** (line 1726):
```python
pattern = rf"(have\s+{re.escape(have_name)}\s*:.*?:=\s*by\s*)sorry"
```

**Why it fails**: The parent sketch has:
```lean
have hv_rewrite : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
  -- from `v = 1/3 * (b*h)` and `b=30`, `h=13/2`
  sorry
```

The pattern `\s*` after `by` only matches whitespace (spaces, tabs, newlines), but **does not match comment lines**. So when it encounters:
```
by
  -- comment line
  sorry
```

The pattern fails because `\s*` matches the newline after `by`, but then encounters `--` (start of comment), which doesn't match `sorry`. The pattern expects `sorry` to come immediately after the whitespace, but there's a comment line in between.

**Root cause**: The pattern `(have\s+{re.escape(have_name)}\s*:.*?:=\s*by\s*)sorry` captures everything up to and including `by` with trailing whitespace, then expects `sorry` immediately. But `\s*` doesn't account for comment lines (`-- ...`) that may appear between `by` and `sorry`.

### Issue 2: Non-Greedy Matching May Stop Too Early

**Problem**: The pattern uses `.*?` (non-greedy) to match between `:` and `:=`, which might stop matching too early in complex type signatures.

**Example**: If a have statement has:
```lean
have hv_rewrite : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
```

The `.*?` needs to match ` v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) `, which should work with `re.DOTALL`. However, if there are nested colons or complex expressions, the non-greedy match might stop at the first `:=` it encounters (though this is less likely to be the issue).

**Note**: This is a secondary concern - the primary issue is Issue 1 (comments between `by` and `sorry`).

### Issue 3: Proof Body Extraction May Return Full Lemma Instead of Tactics

**Location**: `goedels_poetry/state.py`, `_extract_proof_body()` and `_extract_tactics_after_by()`

**Problem**: If `formal_proof` is stored as a full lemma/theorem statement (which shouldn't happen but might in edge cases), `_extract_tactics_after_by()` will try to extract tactics, but if it can't find `:= by`, it returns the whole proof text. This could cause issues when trying to inline.

**Current behavior**:
```python
def _extract_tactics_after_by(self, proof: str) -> str:
    match = re.search(r":=\s*by", proof)
    if match is None:
        return proof.strip()  # Returns full proof if no := by found
    tactics = proof[match.end() :].strip()
    return tactics
```

If `formal_proof` is already just tactics (as it should be), this should work. But if it's a full lemma, it might return the lemma statement instead of just tactics.

### Issue 4: Child Proof Format Mismatch

**Problem**: The child proofs generated by the prover agent are full lemma statements:
```lean
lemma hv_rewrite (b h v : ℝ) ... : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
  have h₄ : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
    calc
      v = 1 / 3 * (b * h) := h₁
      _ = 1 / 3 * (30 * (13 / 2 : ℝ)) := by rw [h₂, h₃]
  exact h₄
```

But `_parse_prover_response()` should extract just the tactics (after `:= by`). However, if the extraction fails or returns the full lemma, then when we try to inline it, we're inserting a full lemma statement into a `have` statement, which is invalid.

## Detailed Failure Scenario

1. **Parent sketch** contains:
   ```lean
   have hv_rewrite : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
     -- comment
     sorry
   ```

2. **Child proof** is generated and stored in `formal_proof` as:
   ```lean
   have h₄ : v = (1 / 3 : ℝ) * (30 * (13 / 2 : ℝ)) := by
     calc
       v = 1 / 3 * (b * h) := h₁
       _ = 1 / 3 * (30 * (13 / 2 : ℝ)) := by rw [h₂, h₃]
   exact h₄
   ```

3. **Reconstruction process**:
   - `_reconstruct_node_proof()` calls `_extract_proof_body(child)`
   - `_extract_proof_body()` calls `_extract_tactics_after_by(proof)`
   - If `proof` is the full lemma, `_extract_tactics_after_by()` should extract just the tactics
   - `_inline_child_proof()` tries to match the pattern and replace `sorry`

4. **Pattern matching fails** because:
   - The pattern doesn't correctly handle the multiline structure with comments
   - Or the pattern matches but the replacement doesn't work correctly

## Plan for Fixing Proof Reconstruction

### Phase 1: Fix Pattern Matching (Critical)

1. **Improve regex pattern to handle multiline have statements with comments**:
   - Update pattern to allow for comments and newlines between `:= by` and `sorry`
   - Ensure `re.DOTALL` is consistently used
   - Make the pattern more robust to handle various formatting

2. **Add debugging/logging**:
   - Log when pattern matching fails
   - Log the actual parent sketch and child proof being matched
   - Log what the pattern is trying to match

### Phase 2: Verify Proof Body Extraction (High Priority)

1. **Verify `formal_proof` storage format**:
   - Ensure `_parse_prover_response()` always returns just tactics (not full lemma)
   - Add assertions or validation to catch if full lemma is stored

2. **Improve `_extract_tactics_after_by()`**:
   - Handle edge cases where proof might be in unexpected format
   - Add validation to ensure extracted tactics are valid (not a full lemma statement)

### Phase 3: Improve Error Handling and Diagnostics (Medium Priority)

1. **Add validation in `_inline_child_proof()`**:
   - Check if pattern matching succeeded
   - If not, log detailed information about why it failed
   - Provide fallback behavior or clear error messages

2. **Add unit tests**:
   - Test pattern matching with various have statement formats
   - Test with comments between `:= by` and `sorry`
   - Test with multiline type signatures
   - Test with nested have statements

### Phase 4: Robustness Improvements (Low Priority)

1. **Handle edge cases**:
   - Multiple have statements with same name (shouldn't happen, but handle gracefully)
   - Have statements with complex type signatures spanning multiple lines
   - Have statements with different formatting styles

2. **Alternative matching strategy**:
   - Consider using AST-based matching instead of regex if regex proves too fragile
   - Or use a two-pass approach: first find the have statement, then find the sorry within it

## Specific Code Changes Needed

### Change 1: Fix Pattern in `_replace_sorry_for_have()`

**File**: `goedels_poetry/state.py`
**Location**: Lines 1724-1751

**Current pattern**:
```python
pattern = rf"(have\s+{re.escape(have_name)}\s*:.*?:=\s*by\s*)sorry"
```

**Proposed fix**:
```python
# Pattern should allow for comments and newlines between := by and sorry
# Match: have <name> : <type> := by <whitespace/comments/newlines> sorry
# The key is to allow comment lines (-- ...) between by and sorry
pattern = rf"(have\s+{re.escape(have_name)}\s*:.*?:=\s*by(?:\s|--[^\n]*\n|/-.*?-/)*)sorry"
```

This pattern allows:
- Whitespace (`\s`) - spaces, tabs, newlines
- Single-line comments (`--[^\n]*\n`) - matches `--` followed by any non-newline chars, then newline
- Block comments (`/-.*?-/`) - matches block comments (though less common in this context)
- All of these can appear between `by` and `sorry`

**Alternative simpler fix** (if block comments aren't needed):
```python
# Simpler version that just allows whitespace and single-line comments
pattern = rf"(have\s+{re.escape(have_name)}\s*:.*?:=\s*by(?:\s|--[^\n]*)*)sorry"
```

**Note**: The `(?:\s|--[^\n]*)*` part matches zero or more of:
- Any whitespace character (including newlines)
- A comment line starting with `--` followed by any characters until end of line

This will correctly match:
```
by
  -- comment
  sorry
```

### Change 2: Add Validation in `_extract_tactics_after_by()`

**File**: `goedels_poetry/state.py`
**Location**: Lines 1557-1581

**Add validation** to ensure we're not returning a full lemma statement:
```python
def _extract_tactics_after_by(self, proof: str) -> str:
    match = re.search(r":=\s*by", proof)
    if match is None:
        # If no := by found, check if this looks like a full lemma/theorem
        if re.search(r"^\s*(lemma|theorem|have)\s+", proof, re.MULTILINE):
            # This looks like a full statement, not just tactics
            # Log warning and return sorry as fallback
            return "sorry"
        return proof.strip()

    tactics = proof[match.end() :].strip()

    # Validate that tactics don't start with lemma/theorem (shouldn't happen)
    if re.search(r"^\s*(lemma|theorem)\s+", tactics, re.MULTILINE):
        # This is a full lemma, extract just the tactics
        # Find the := by in the lemma and extract from there
        inner_match = re.search(r":=\s*by", tactics)
        if inner_match:
            tactics = tactics[inner_match.end() :].strip()
        else:
            return "sorry"

    return tactics
```

### Change 3: Add Logging for Debugging

**File**: `goedels_poetry/state.py`
**Location**: `_inline_child_proof()` and `_replace_sorry_for_have()`

**Add logging** to help diagnose failures:
```python
def _replace_sorry_for_have(self, parent_sketch: str, have_name: str, child_proof_body: str) -> str:
    pattern = rf"(have\s+{re.escape(have_name)}\s*:.*?:=\s*by(?:\s|--[^\n]*\n|/-.*?-/)*)sorry"
    match = re.search(pattern, parent_sketch, re.DOTALL)
    if not match:
        # Log failure for debugging
        logger.warning(f"Failed to match pattern for have statement '{have_name}'")
        logger.debug(f"Pattern: {pattern}")
        logger.debug(f"Parent sketch snippet: {parent_sketch[:500]}")
        return parent_sketch
    # ... rest of function
```

## Testing Strategy

1. **Unit tests** for pattern matching:
   - Test with the exact format from `partial.log`
   - Test with various comment styles
   - Test with multiline type signatures

2. **Integration test**:
   - Use the exact case from `partial.log` as a test case
   - Verify that reconstruction produces a proof without `sorry`

3. **Regression tests**:
   - Ensure existing tests still pass
   - Add tests for edge cases discovered during debugging

## Expected Outcome

After implementing these fixes:
1. Pattern matching should correctly identify and replace `sorry` in multiline have statements
2. Proof body extraction should reliably return just tactics
3. Final reconstructed proof should have no `sorry` statements (when all children are proven)
4. Better error messages if reconstruction fails for any reason
