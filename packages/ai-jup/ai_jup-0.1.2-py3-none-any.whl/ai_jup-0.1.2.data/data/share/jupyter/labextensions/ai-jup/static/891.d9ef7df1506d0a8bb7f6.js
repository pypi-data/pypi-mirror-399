"use strict";(self.webpackChunkai_jup=self.webpackChunkai_jup||[]).push([[891],{891(t,e,n){n.r(e),n.d(e,{default:()=>O});var o=n(762),s=n(986),r=n(177),a=n(560),i=n(424),l=n(694),c=n(674);var d=n(602),p=n(297);class _{constructor(){this._state="idle",this._output="",this._abortController=null,this._streamEvent=new d.Signal(this),this._outputChanged=new d.Signal(this),this._stateChanged=new d.Signal(this)}get streamEvent(){return this._streamEvent}get outputChanged(){return this._outputChanged}get stateChanged(){return this._stateChanged}get state(){return this._state}get output(){return this._output}async executePrompt(t,e,n){this._setState("executing"),this._output="",this._abortController=new AbortController,this._emitEvent({type:"start"});const o=p.PageConfig.getBaseUrl(),s={prompt:t,context:e,model:n.model,kernel_id:n.kernelId,max_steps:n.maxSteps??1};try{const t=document.cookie.split("; ").find(t=>t.startsWith("_xsrf="))?.split("=")[1],e=await fetch(`${o}ai-jup/prompt`,{method:"POST",credentials:"same-origin",headers:{"Content-Type":"application/json",...t&&{"X-XSRFToken":t}},body:JSON.stringify(s),signal:this._abortController.signal});if(!e.ok){let t=`HTTP ${e.status}: ${e.statusText}`;try{const n=await e.json();n.error&&(t=n.error)}catch{}throw new Error(t)}this._setState("streaming"),await this._processStream(e),this._setState("idle")}catch(t){if(t instanceof Error&&"AbortError"===t.name)return void this._setState("idle");throw this._emitEvent({type:"error",error:t instanceof Error?t.message:String(t)}),this._setState("error"),t}finally{this._abortController=null}}async _processStream(t){const e=t.body?.getReader();if(!e)throw new Error("No response body");const n=new TextDecoder;let o="",s=null;try{for(;;){const{done:t,value:r}=await e.read();if(t)break;o+=n.decode(r,{stream:!0});const a=o.split("\n");o=a.pop()||"";for(const t of a){const e=t.replace(/\r$/,"");if(!e.startsWith("data: "))continue;const n=e.slice(6);try{const t=JSON.parse(n);this._handleServerEvent(t,s),t.tool_call?s={name:t.tool_call.name,id:t.tool_call.id,input:""}:t.tool_input&&s?s.input+=t.tool_input:t.tool_result&&(s=null)}catch{}}}}finally{e.releaseLock()}this._emitEvent({type:"done"})}_handleServerEvent(t,e){if(t.text){const e=t.text;this._appendOutput(e),this._emitEvent({type:"text",text:e})}else if(t.error){const e=t.error;this._appendOutput(`\n\n**Error:** ${e}\n`),this._emitEvent({type:"error",error:e})}else if(t.tool_call){const e=t.tool_call;this._appendOutput(`\n\nðŸ”§ *Calling tool: \`${e.name}\`...*\n`),this._emitEvent({type:"tool_call",toolCall:{name:e.name,id:e.id}})}else if(t.tool_input)this._emitEvent({type:"tool_input",toolInput:t.tool_input});else if(t.tool_result){const e=t.tool_result,n=function(t){if(!t||"object"!=typeof t)return`\n**Tool Result:** ${JSON.stringify(t)}\n`;const e=t;if("error"===e.status||e.error)return`\n**Tool Error:** ${e.error||"Unknown error"}\n`;const n=e.type,o=e.content??"";return"text"===n?`\n**Tool Result:**\n\`\`\`\n${o}\n\`\`\`\n`:"html"===n?`\n**Tool Result (HTML):**\n\n${o}\n`:"image"===n?`\n**Tool Result:**\n\n![](data:image/${e.format||"png"};base64,${o})\n`:`\n**Tool Result:**\n\`\`\`json\n${JSON.stringify(t,null,2)}\n\`\`\`\n`}(e.result);this._appendOutput(n),this._emitEvent({type:"tool_result",toolResult:{id:e.id,name:e.name,result:e.result}})}}_appendOutput(t){this._output+=t,this._outputChanged.emit(this._output)}abort(){this._abortController&&(this._abortController.abort(),this._abortController=null)}reset(){this.abort(),this._output="",this._setState("idle"),this._outputChanged.emit(this._output)}_setState(t){this._state!==t&&(this._state=t,this._stateChanged.emit(t))}_emitEvent(t){this._streamEvent.emit(t)}dispose(){this.abort(),d.Signal.clearData(this)}}const u=["image/png","image/jpeg","image/gif"],m=/^application\/vnd\.vegalite\.v\d+\+json$/,h="ai-jup-prompt-cell",g="ai-jup-prompt-output",f="ai_jup";class C{constructor(){this._connectors=new Map,this._settings=null}setSettings(t){this._settings=t}setupNotebook(t,e){const n=t.id;this._connectors.set(n,e);const o=t.content,s=()=>{if(t.isDisposed||!o.model)return;const e=o.model.cells.length;console.log(`[ai-jup] Styling prompt cells, ${e} cells in model, ${o.widgets.length} widgets`);for(let t=0;t<e;t++){const e=o.model.cells.get(t);if(this._isPromptCellModel(e)&&(console.log(`[ai-jup] Found prompt cell at index ${t}`),t<o.widgets.length)){const e=o.widgets[t];e&&!e.hasClass(h)&&(e.addClass(h),console.log(`[ai-jup] Added class to cell ${t}`))}}};s();const r=()=>{s()};o.activeCellChanged.connect(r);const a=o.model?.cells,i=()=>{requestAnimationFrame(()=>s())};a&&a.changed.connect(i),t.disposed.connect(()=>{this._connectors.delete(n),o.activeCellChanged.disconnect(r),a&&a.changed.disconnect(i)})}insertPromptCell(t){const e=t.content;o.NotebookActions.insertBelow(e);const n=e.activeCellIndex,s=e.widgets[n].model;if(s.setMetadata(f,{isPromptCell:!0,model:"claude-sonnet-4-20250514"}),e.model){const t=s.toJSON();t.cell_type="markdown",t.source="**AI Prompt:** ",e.model.sharedModel.deleteCell(n),e.model.sharedModel.insertCell(n,t)}e.widgets[n].addClass(h),e.activeCellIndex=n,e.mode="edit"}async executePromptCell(t){const e=t.content.activeCell;if(!e||!this._isPromptCellModel(e.model))return void console.log("Not a prompt cell");const n=this._connectors.get(t.id);if(!n)return void console.error("No kernel connector found");const o=e.model.getMetadata(f),s=this._settings?.defaultModel??"claude-sonnet-4-20250514",r=o?.model||s,a=t.sessionContext.session?.kernel?.id,i=e.model.sharedModel.getSource().replace(/^\*\*AI Prompt:\*\*\s*/i,""),l=function(t){const e=/\$`([a-zA-Z_][a-zA-Z0-9_]*)`/g,n=/&`([a-zA-Z_][a-zA-Z0-9_]*)`/g,o=[],s=[];let r;for(;null!==(r=e.exec(t));){const t=r[1];o.includes(t)||o.push(t)}for(;null!==(r=n.exec(t));){const t=r[1];s.includes(t)||s.push(t)}return{variables:o,functions:s}}(i),c=await this._gatherContext(t,n,l),d={};for(const[t,e]of Object.entries(c.variables))d[t]=e.repr;const p=function(t,e){let n=function(t,e){let n=t;for(const[t,o]of Object.entries(e)){const e=new RegExp(`\\$\`${t}\``,"g");n=n.replace(e,()=>o)}return n}(t,e);return n=function(t){return t.replace(/&`([a-zA-Z_][a-zA-Z0-9_]*)`/g,"").replace(/\s+/g," ").trim()}(n),n.trim()}(i,d),_=this._insertOutputCell(t,e);await this._callAI(t,p,c,_,r,a)}async _gatherContext(t,e,n){const o=t.content,s=o.activeCellIndex,r=[],a=[],i=[];for(let t=0;t<s;t++){const e=o.widgets[t].model;"code"===e.type?(r.push(e.sharedModel.getSource()),(0,c.isCodeCellModel)(e)&&(this._extractImagesFromCodeCell(e,t,a),this._extractChartSpecsFromCodeCell(e,t,i))):"markdown"===e.type&&this._extractImagesFromMarkdownCell(e,t,a)}const l={};for(const t of n.variables){const n=await e.getVariable(t);n&&(l[t]=n)}const d={};for(const t of n.functions){const n=await e.getFunction(t);n&&(d[t]=n)}return{preceding_code:r.join("\n\n"),variables:l,functions:d,images:a.length>0?a:void 0,chartSpecs:i.length>0?i:void 0}}_extractImagesFromCodeCell(t,e,n){const o=t.outputs;if(o)for(let t=0;t<o.length;t++){const s=o.get(t).data;for(const t of u){const o=s[t];if(o&&"string"==typeof o){n.push({data:o,mimeType:t,source:"output",cellIndex:e});break}}}}_extractImagesFromMarkdownCell(t,e,n){const o=t.getMetadata("attachments");if(o)for(const[t,s]of Object.entries(o))if(s&&"object"==typeof s)for(const t of u){const o=s[t];if(o&&"string"==typeof o){n.push({data:o,mimeType:t,source:"attachment",cellIndex:e});break}}}_extractChartSpecsFromCodeCell(t,e,n){const o=t.outputs;if(o)for(let t=0;t<o.length;t++){const s=o.get(t).data;for(const t of Object.keys(s))if(m.test(t)){const o=s[t];o&&"object"==typeof o&&n.push({type:"vega-lite",spec:o,cellIndex:e});break}const r=s["application/vnd.plotly.v1+json"];r&&"object"==typeof r&&n.push({type:"plotly",spec:r,cellIndex:e})}}_insertOutputCell(t,e){const n=t.content,s=n.widgets.indexOf(e);let r=s;for(let t=s+1;t<n.widgets.length&&n.widgets[t].hasClass(g);t++)r=t;n.activeCellIndex=r,o.NotebookActions.insertBelow(n);const a=r+1,i=n.widgets[a];if(n.model){const t=i.model.toJSON();t.cell_type="markdown",t.source='<div class="ai-jup-loading">Generating response...</div>',n.model.sharedModel.deleteCell(a),n.model.sharedModel.insertCell(a,t)}const l=n.widgets[a];return l.addClass(g),l}async _callAI(t,e,n,o,s,r){const a=new _,i=(t,e)=>{o.isDisposed||o.model.sharedModel.setSource(e)};a.outputChanged.connect(i);const l=()=>a.abort();o.disposed.connect(l);try{const i=this._settings?.maxToolSteps??5;await a.executePrompt(e,n,{model:s,kernelId:r,maxSteps:i}),!o.isDisposed&&o instanceof c.MarkdownCell&&(o.rendered=!0,(this._settings?.showConvertButton??1)&&this._addConvertButton(t,o,a.output))}catch(t){if(t instanceof Error&&"AbortError"===t.name)return;o.isDisposed||(o.model.sharedModel.setSource(`**Error:** Failed to connect to AI backend.\n\n${String(t)}`),o instanceof c.MarkdownCell&&(o.rendered=!0))}finally{a.outputChanged.disconnect(i),o.disposed.disconnect(l),a.dispose()}}isPromptCell(t){return this._isPromptCellModel(t.model)}_isPromptCellModel(t){const e=t.getMetadata(f);return!0===e?.isPromptCell}_addConvertButton(t,e,n){if(e.model.setMetadata("ai_jup_content",n),e.node.querySelector(".ai-jup-convert-button-container"))return;const o=document.createElement("div");o.className="ai-jup-convert-button-container";const s=document.createElement("button");s.className="jp-mod-styled ai-jup-convert-button",s.innerHTML='<span class="jp-ToolbarButtonComponent-icon"></span><span class="jp-ToolbarButtonComponent-label">Convert to Cells</span>',s.title="Convert this response into separate code and markdown cells",s.addEventListener("click",()=>{const o=e.model.getMetadata("ai_jup_content")||n;this._convertToCells(t,e,o)}),o.appendChild(s),e.node.appendChild(o)}_convertToCells(t,e,n){const o=t.content,s=o.widgets.indexOf(e);if(s<0||!o.model)return void console.log("[ai-jup] Convert: invalid cell index or no model");console.log("[ai-jup] Converting content:",n.substring(0,200)+"...");const r=this._parseContentBlocks(n);if(console.log("[ai-jup] Parsed blocks:",r.length,r.map(t=>({type:t.type,len:t.content.length}))),0!==r.length){o.model.sharedModel.deleteCell(s);for(let t=r.length-1;t>=0;t--){const e=r[t],n={cell_type:"code"===e.type?"code":"markdown",source:e.content,metadata:{}};o.model.sharedModel.insertCell(s,n)}console.log("[ai-jup] Inserted",r.length,"cells")}else console.log("[ai-jup] No blocks parsed, keeping original cell")}_parseContentBlocks(t){const e=[],n=t.replace(/\r\n/g,"\n").replace(/\r/g,"\n"),o=/```(\w*)[ \t]*\n?([\s\S]*?)\n?```/g;let s,r=0;for(console.log("[ai-jup] Parsing content, length:",n.length),console.log("[ai-jup] Content starts with:",JSON.stringify(n.substring(0,100)));null!==(s=o.exec(n));){console.log("[ai-jup] Found code block match at",s.index,"language:",s[1],"code length:",s[2].length);const t=n.slice(r,s.index).trim();t&&e.push({type:"markdown",content:t});const o=s[1]||"python",a=s[2].trim();a&&e.push({type:"code",content:a,language:o}),r=s.index+s[0].length}const a=n.slice(r).trim();return a&&e.push({type:"markdown",content:a}),0===e.length&&n.trim()&&(console.log("[ai-jup] No code blocks found, returning as single markdown"),e.push({type:"markdown",content:n.trim()})),e}}class y{constructor(t){this._session=t}get kernelAvailable(){return!!this._session.session?.kernel}async execute(t,e){const n=this._session.session?.kernel;if(!n)return null;const o={code:t,stop_on_error:!1,store_history:!1,silent:!0},s=n.requestExecute(o);e&&(s.onIOPub=e);try{return await s.done}finally{s.dispose()}}async executeAndCapture(t){let e="";return await this.execute(t,t=>{const n=t.header.msg_type,o=t.content;if("stream"===n&&"stdout"===o.name)e+=o.text;else if("execute_result"===n){const t=o.data;t&&t["text/plain"]&&(e+=t["text/plain"])}}),e.trim()}async getVariable(t){const e=`\nimport json as _json_mod\ntry:\n    _var = ${t}\n    _result = {\n        "name": "${t}",\n        "type": type(_var).__name__,\n        "repr": repr(_var)[:500]\n    }\n    print(_json_mod.dumps(_result))\n    del _var, _result\nexcept Exception as _e:\n    print(_json_mod.dumps({"error": str(_e)}))\n`;try{const n=await this.executeAndCapture(e);if(!n)return null;const o=JSON.parse(n);return o.error?(console.warn(`Error getting variable ${t}:`,o.error),null):o}catch(e){return console.error(`Failed to get variable ${t}:`,e),null}}async getFunction(t){const e=`\nimport json as _json_mod\nimport inspect as _inspect_mod\nimport re as _re_mod\ntry:\n    _func = ${t}\n    if not callable(_func):\n        print(_json_mod.dumps({"error": "Not callable"}))\n    else:\n        _sig = str(_inspect_mod.signature(_func))\n        _doc = _inspect_mod.getdoc(_func) or "No documentation"\n        \n        # Parse docstring for parameter descriptions (numpy/Google style)\n        _param_docs = {}\n        try:\n            _lines = _doc.splitlines()\n            _in_params_section = False\n            _current_param = None\n            _current_desc = []\n            \n            for _line in _lines:\n                _stripped = _line.strip()\n                _lower = _stripped.lower()\n                \n                # Detect section headers\n                if _lower in ('parameters', 'args', 'arguments', 'params'):\n                    _in_params_section = True\n                    continue\n                elif _lower in ('returns', 'return', 'raises', 'examples', 'notes', 'see also', 'attributes'):\n                    # End of parameters section\n                    if _current_param and _current_desc:\n                        _param_docs[_current_param] = ' '.join(_current_desc).strip()\n                    _in_params_section = False\n                    _current_param = None\n                    _current_desc = []\n                    continue\n                \n                if not _in_params_section:\n                    continue\n                \n                # Skip section underlines (numpy style)\n                if _stripped and all(c == '-' for c in _stripped):\n                    continue\n                \n                # Check if this is a new parameter line\n                # Numpy style: "param : type" or "param: type"\n                # Google style: "param (type): description" or "param: description"\n                _param_match = _re_mod.match(r'^(\\w+)\\s*(?:\\(.*?\\))?\\s*:(.*)$', _stripped)\n                if _param_match and not _line.startswith(' ' * 4) or (_param_match and _line and _line[0] not in ' \\t'):\n                    # Save previous param\n                    if _current_param and _current_desc:\n                        _param_docs[_current_param] = ' '.join(_current_desc).strip()\n                    \n                    _current_param = _param_match.group(1)\n                    _rest = _param_match.group(2).strip()\n                    _current_desc = [_rest] if _rest else []\n                elif _current_param and _stripped:\n                    # Continuation line\n                    _current_desc.append(_stripped)\n            \n            # Save last param\n            if _current_param and _current_desc:\n                _param_docs[_current_param] = ' '.join(_current_desc).strip()\n        except (AttributeError, TypeError, ValueError) as _parse_err:\n            # Docstring parsing is best-effort; fall back to empty on parse failures\n            _param_docs = {}\n        \n        _params = {}\n        for _pname, _param in _inspect_mod.signature(_func).parameters.items():\n            # Use parsed docstring description if available, otherwise use param name\n            _desc = _param_docs.get(_pname, _pname)\n            _pinfo = {"type": "string", "description": _desc}\n            if _param.annotation != _inspect_mod.Parameter.empty:\n                _ann = _param.annotation\n                if hasattr(_ann, '__name__'):\n                    _pinfo["type"] = _ann.__name__\n                elif hasattr(_ann, '__origin__'):\n                    _pinfo["type"] = str(_ann)\n            if _param.default != _inspect_mod.Parameter.empty:\n                _pinfo["default"] = repr(_param.default)\n            _params[_pname] = _pinfo\n        # Extract return type annotation\n        _return_type = None\n        _ret_ann = _inspect_mod.signature(_func).return_annotation\n        if _ret_ann != _inspect_mod.Parameter.empty:\n            if hasattr(_ret_ann, '__name__'):\n                _return_type = _ret_ann.__name__\n            elif hasattr(_ret_ann, '__origin__'):\n                _return_type = str(_ret_ann)\n            else:\n                _return_type = str(_ret_ann)\n        \n        # Append return type to docstring (like toolslm pattern)\n        _full_doc = _doc[:500]\n        if _return_type:\n            _full_doc += f"\\n\\nReturns:\\n- type: {_return_type}"\n        \n        _result = {\n            "name": "${t}",\n            "signature": _sig,\n            "docstring": _full_doc,\n            "parameters": _params,\n            "return_type": _return_type\n        }\n        print(_json_mod.dumps(_result))\n        del _func, _sig, _doc, _params, _result, _param_docs\nexcept Exception as _e:\n    print(_json_mod.dumps({"error": str(_e)}))\n`;try{const n=await this.executeAndCapture(e);if(!n)return null;const o=JSON.parse(n);return o.error?(console.warn(`Error getting function ${t}:`,o.error),null):o}catch(e){return console.error(`Failed to get function ${t}:`,e),null}}}const w="claude-sonnet-4-20250514",v=!0;class b{constructor(){this._settings=null,this._defaultModel=w,this._maxToolSteps=5,this._showConvertButton=v,this._settingsChanged=new d.Signal(this)}get settingsChanged(){return this._settingsChanged}get defaultModel(){return this._defaultModel}get maxToolSteps(){return this._maxToolSteps}get showConvertButton(){return this._showConvertButton}async initialize(t){try{this._settings=await t.load("ai-jup:plugin"),this._updateFromSettings(),this._settings.changed.connect(this._onSettingsChanged,this)}catch(t){console.warn("[ai-jup] Failed to load settings, using defaults:",t)}}async set(t,e){this._settings&&await this._settings.set(t,e)}toJSON(){return{defaultModel:this._defaultModel,maxToolSteps:this._maxToolSteps,showConvertButton:this._showConvertButton}}_onSettingsChanged(){this._updateFromSettings(),this._settingsChanged.emit()}_updateFromSettings(){if(!this._settings)return;const t=this._settings.composite;this._defaultModel=t.defaultModel??w,this._maxToolSteps=t.maxToolSteps??5,this._showConvertButton=t.showConvertButton??v}dispose(){this._settings&&this._settings.changed.disconnect(this._onSettingsChanged,this),d.Signal.clearData(this)}}var k=n(345);const j="ai_jup",x="ai-jup-prompt-cell";class S extends l.ReactWidget{constructor(t,e,n){super(),this.handleChange=t=>{const e=t.target.value;"-"!==e&&("prompt"===e?this._convertToPrompt():(this._removePromptMetadata(),o.NotebookActions.changeCellType(this._notebook,e)),this._notebook.activate())},this.handleKeyDown=t=>{"Enter"===t.key&&this._notebook.activate()},this._trans=(n??i.nullTranslator).load("jupyterlab"),this.addClass("jp-Notebook-toolbarCellType"),this._notebook=t.content,this._notebook.model&&this.update(),this._notebook.activeCellChanged.connect(this.update,this),this._notebook.selectionChanged.connect(this.update,this),t.disposed.connect(()=>{this._notebook.activeCellChanged.disconnect(this.update,this),this._notebook.selectionChanged.disconnect(this.update,this)})}_convertToPrompt(){const t=this._notebook;if(!t.model)return;const e=[];t.widgets.forEach((n,o)=>{if(!t.isSelectedOrActive(n))return;const s=n.model.getMetadata(j);s?.isPromptCell||e.push(o)});for(let n=e.length-1;n>=0;n--){const s=e[n],r=t.widgets[s];if(!r)continue;"markdown"!==r.model.type&&(t.activeCellIndex=s,t.deselectAll(),o.NotebookActions.changeCellType(t,"markdown"));const a=t.widgets[s];if(a){a.model.setMetadata(j,{isPromptCell:!0,model:"claude-sonnet-4-20250514"});const t=a.model.sharedModel.getSource();t&&t.trim()||a.model.sharedModel.setSource("**AI Prompt:** "),a.hasClass(x)||a.addClass(x)}}t.deselectAll()}_removePromptMetadata(){const t=this._notebook;t.widgets.forEach(e=>{if(!t.isSelectedOrActive(e))return;const n=e.model.getMetadata(j);n?.isPromptCell&&(e.model.deleteMetadata(j),e.removeClass(x))})}_getValue(){const t=this._notebook;if(!t.activeCell)return"-";let e=this._isPromptCell(t.activeCell.model)?"prompt":t.activeCell.model.type;for(const n of t.widgets)if(t.isSelectedOrActive(n)&&(this._isPromptCell(n.model)?"prompt":n.model.type)!==e)return"-";return e}_isPromptCell(t){const e=t.getMetadata(j);return!0===e?.isPromptCell}render(){const t=this._getValue();return k.createElement("select",{className:"jp-Notebook-toolbarCellTypeDropdown",onChange:this.handleChange,onKeyDown:this.handleKeyDown,value:t,"aria-label":this._trans.__("Cell type"),title:this._trans.__("Select the cell type")},k.createElement("option",{value:"-"},"-"),k.createElement("option",{value:"code"},this._trans.__("Code")),k.createElement("option",{value:"markdown"},this._trans.__("Markdown")),k.createElement("option",{value:"raw"},this._trans.__("Raw")),k.createElement("option",{value:"prompt"},this._trans.__("Prompt")))}}var M=n(262);const E=new M.Token("ai-jup:IKernelConnectorFactory","Factory for creating kernel connectors"),I=new M.Token("ai-jup:IPromptCellManager","Manages prompt cells within notebooks"),P=(new M.Token("ai-jup:IPromptModelFactory","Factory for creating prompt models"),new M.Token("ai-jup:IExtensionSettings","Extension configuration settings")),T={id:"ai-jup:settings",description:"Provides AI-Jup extension settings",autoStart:!0,requires:[],optional:[a.ISettingRegistry],provides:P,activate:async(t,e)=>{const n=new b;return e?(await n.initialize(e),console.log("[ai-jup] Settings loaded:",n.toJSON())):console.log("[ai-jup] No setting registry available, using defaults"),n}},A={id:"ai-jup:kernel-connector",description:"Provides kernel connector factory",autoStart:!0,provides:E,activate:()=>({create:t=>new y(t)})},N={id:"ai-jup:prompt-cell-manager",description:"Manages AI prompt cells",autoStart:!0,requires:[P],provides:I,activate:(t,e)=>{const n=new C;return n.setSettings(e),n}},$={id:"ai-jup:plugin",description:"AI-powered prompt cells for JupyterLab",autoStart:!0,requires:[o.INotebookTracker,I,E],optional:[s.ICommandPalette,r.IMainMenu],activate:(t,e,n,o,r,a)=>{console.log("AI-Jup extension activated");const i="ai-jup:insert-prompt-cell";t.commands.addCommand(i,{label:"Insert AI Prompt Cell",caption:"Insert a new AI prompt cell below the current cell",execute:()=>{const t=e.currentWidget;t&&n.insertPromptCell(t)}});const c="ai-jup:run-prompt";t.commands.addCommand(c,{label:"Run AI Prompt",caption:"Execute the current prompt cell",execute:async()=>{const t=e.currentWidget;t&&await n.executePromptCell(t)}}),t.commands.addKeyBinding({command:i,keys:["Accel Shift P"],selector:".jp-Notebook"}),t.commands.addKeyBinding({command:i,keys:["P"],selector:".jp-Notebook.jp-mod-commandMode:not(.jp-mod-readWrite) :focus"}),t.commands.addKeyBinding({command:c,keys:["Shift Enter"],selector:".jp-Notebook.jp-mod-editMode .jp-Cell.ai-jup-prompt-cell"}),t.commands.addKeyBinding({command:c,keys:["Shift Enter"],selector:".jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected.ai-jup-prompt-cell"}),r&&(r.addItem({command:i,category:"AI"}),r.addItem({command:c,category:"AI"})),a&&a.editMenu.addGroup([{command:i},{command:c}],20);const d=t=>{const e=()=>{if(t.isDisposed)return;const e=new s.ToolbarButton({icon:l.addIcon,onClick:()=>{n.insertPromptCell(t)},tooltip:"Insert AI Prompt Cell (Cmd/Ctrl+Shift+P)",label:"AI Prompt"});t.toolbar.insertAfter("cellType","ai-jup-insert",e),requestAnimationFrame(()=>{if(t.isDisposed)return;const e=o.create(t.sessionContext);n.setupNotebook(t,e)})};t.context.isReady?e():t.context.ready.then(e)};e.widgetAdded.connect((t,e)=>d(e)),e.forEach(d)}},O=[T,A,N,{id:"ai-jup:cell-type-switcher",description:"Adds Prompt option to cell type dropdown",autoStart:!0,requires:[s.IToolbarWidgetRegistry,I,o.INotebookWidgetFactory],optional:[i.ITranslator],activate:(t,e,n,o,s)=>{console.log("[ai-jup] Registering custom cell type switcher (after notebook widget factory)");const r=e.addFactory("Notebook","cellType",t=>(console.log("[ai-jup] Creating CustomCellTypeSwitcher for panel:",t.id),new S(t,n,s??void 0)));console.log("[ai-jup] Replaced cellType factory, old factory was:",r?"present":"none")}},$]}}]);