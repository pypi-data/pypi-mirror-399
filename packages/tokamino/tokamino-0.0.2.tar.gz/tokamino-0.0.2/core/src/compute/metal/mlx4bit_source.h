"#include <metal_stdlib>\n"
"using namespace metal;\n"
"\n"
"inline float bf16_to_f32(uint16_t bf16) {\n"
"    uint32_t bits = (uint32_t)bf16 << 16;\n"
"    return as_type<float>(bits);\n"
"}\n"
"\n"
"inline float dequantize_mlx4bit(uint8_t nibble, uint16_t scale, uint16_t bias) {\n"
"    float val = (float)nibble - 8.0f;\n"
"    return val * bf16_to_f32(scale) + bf16_to_f32(bias);\n"
"}\n"
"\n"
"kernel void mlx4bit_matmul(\n"
"    constant float* a [[buffer(0)]],\n"
"    constant uint8_t* b_data [[buffer(1)]],\n"
"    constant uint16_t* b_scales [[buffer(2)]],\n"
"    constant uint16_t* b_biases [[buffer(3)]],\n"
"    device float* c [[buffer(4)]],\n"
"    constant uint32_t& m [[buffer(5)]],\n"
"    constant uint32_t& k [[buffer(6)]],\n"
"    constant uint32_t& n [[buffer(7)]],\n"
"    constant uint32_t& group_size [[buffer(8)]],\n"
"    uint2 gid [[thread_position_in_grid]])\n"
"{\n"
"    uint row = gid.y;\n"
"    uint col = gid.x;\n"
"    if (row >= m || col >= n) return;\n"
"\n"
"    float sum = 0.0f;\n"
"    for (uint i = 0; i < k; i++) {\n"
"        float a_val = a[row * k + i];\n"
"        uint b_idx = i * n + col;\n"
"        uint byte_idx = b_idx / 2;\n"
"        uint nibble;\n"
"        if (b_idx % 2 == 0) {\n"
"            nibble = b_data[byte_idx] & 0x0F;\n"
"        } else {\n"
"            nibble = (b_data[byte_idx] >> 4) & 0x0F;\n"
"        }\n"
"        uint group_idx = b_idx / group_size;\n"
"        uint16_t scale = b_scales[group_idx];\n"
"        uint16_t bias = b_biases[group_idx];\n"
"        float b_val = dequantize_mlx4bit(nibble, scale, bias);\n"
"        sum += a_val * b_val;\n"
"    }\n"
"    c[row * n + col] = sum;\n"
"}\n"
