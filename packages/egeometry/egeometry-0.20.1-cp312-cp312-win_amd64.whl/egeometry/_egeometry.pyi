# generated from codegen/templates/_boundingbox2d.pyi

__all__ = ["DBoundingBox2d", "FBoundingBox2d", "IBoundingBox2d"]

from typing import Iterable
from typing import overload

from emath import *

from ._dboundingbox2d import DBoundingBox2dOverlappable
from ._dboundingbox2d import HasDBoundingBox2d
from ._dcircle import DCircle
from ._drectangle import DRectangle
from ._dtriangle2d import DTriangle2d
from ._fboundingbox2d import FBoundingBox2d
from ._iboundingbox2d import IBoundingBox2d

class DBoundingBox2d:
    @overload
    def __init__(self, position: DVector2, size: DVector2) -> None: ...
    @overload
    def __init__(self, *, shapes: Iterable[HasDBoundingBox2d | DVector2]) -> None: ...
    def __init__(
        self,
        position: DVector2 | None = None,
        size: DVector2 | None = None,
        *,
        shapes: Iterable[HasDBoundingBox2d | DVector2] | None = None,
    ): ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def overlaps(self, other: DVector2 | DBoundingBox2dOverlappable) -> bool: ...
    def overlaps_d_circle(self, other: DCircle) -> bool: ...
    def overlaps_d_rectangle(self, other: DRectangle) -> bool: ...
    def overlaps_d_triangle_2d(self, other: DTriangle2d) -> bool: ...
    def overlaps_d_bounding_box_2d(self, other: DBoundingBox2d) -> bool: ...
    def overlaps_d_vector_2(self, other: DVector2) -> bool: ...
    def translate(self, translation: DVector2) -> DBoundingBox2d: ...
    def __rmatmul__(self, transform: DMatrix4) -> DBoundingBox2d: ...
    def clip(self, other: DBoundingBox2d) -> DBoundingBox2d: ...
    @property
    def bounding_box(self) -> DBoundingBox2d: ...
    @property
    def extent(self) -> DVector2: ...
    @property
    def position(self) -> DVector2: ...
    @property
    def size(self) -> DVector2: ...
    @property
    def points(self) -> tuple[DVector2, DVector2, DVector2, DVector2]: ...
    def to_i(self) -> IBoundingBox2d: ...
    def to_f(self) -> FBoundingBox2d: ...

from ._dboundingbox2d import DBoundingBox2d
from ._fboundingbox2d import FBoundingBox2dOverlappable
from ._fboundingbox2d import HasFBoundingBox2d
from ._fcircle import FCircle
from ._frectangle import FRectangle
from ._ftriangle2d import FTriangle2d
from ._iboundingbox2d import IBoundingBox2d

class FBoundingBox2d:
    @overload
    def __init__(self, position: FVector2, size: FVector2) -> None: ...
    @overload
    def __init__(self, *, shapes: Iterable[HasFBoundingBox2d | FVector2]) -> None: ...
    def __init__(
        self,
        position: FVector2 | None = None,
        size: FVector2 | None = None,
        *,
        shapes: Iterable[HasFBoundingBox2d | FVector2] | None = None,
    ): ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def overlaps(self, other: FVector2 | FBoundingBox2dOverlappable) -> bool: ...
    def overlaps_f_circle(self, other: FCircle) -> bool: ...
    def overlaps_f_rectangle(self, other: FRectangle) -> bool: ...
    def overlaps_f_triangle_2d(self, other: FTriangle2d) -> bool: ...
    def overlaps_f_bounding_box_2d(self, other: FBoundingBox2d) -> bool: ...
    def overlaps_f_vector_2(self, other: FVector2) -> bool: ...
    def translate(self, translation: FVector2) -> FBoundingBox2d: ...
    def __rmatmul__(self, transform: FMatrix4) -> FBoundingBox2d: ...
    def clip(self, other: FBoundingBox2d) -> FBoundingBox2d: ...
    @property
    def bounding_box(self) -> FBoundingBox2d: ...
    @property
    def extent(self) -> FVector2: ...
    @property
    def position(self) -> FVector2: ...
    @property
    def size(self) -> FVector2: ...
    @property
    def points(self) -> tuple[FVector2, FVector2, FVector2, FVector2]: ...
    def to_i(self) -> IBoundingBox2d: ...
    def to_d(self) -> DBoundingBox2d: ...

from ._dboundingbox2d import DBoundingBox2d
from ._fboundingbox2d import FBoundingBox2d
from ._iboundingbox2d import HasIBoundingBox2d
from ._iboundingbox2d import IBoundingBox2dOverlappable
from ._icircle import ICircle
from ._irectangle import IRectangle
from ._itriangle2d import ITriangle2d

class IBoundingBox2d:
    @overload
    def __init__(self, position: IVector2, size: IVector2) -> None: ...
    @overload
    def __init__(self, *, shapes: Iterable[HasIBoundingBox2d | IVector2]) -> None: ...
    def __init__(
        self,
        position: IVector2 | None = None,
        size: IVector2 | None = None,
        *,
        shapes: Iterable[HasIBoundingBox2d | IVector2] | None = None,
    ): ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...
    def overlaps(self, other: IVector2 | IBoundingBox2dOverlappable) -> bool: ...
    def overlaps_i_circle(self, other: ICircle) -> bool: ...
    def overlaps_i_rectangle(self, other: IRectangle) -> bool: ...
    def overlaps_i_triangle_2d(self, other: ITriangle2d) -> bool: ...
    def overlaps_i_bounding_box_2d(self, other: IBoundingBox2d) -> bool: ...
    def overlaps_i_vector_2(self, other: IVector2) -> bool: ...
    def translate(self, translation: IVector2) -> IBoundingBox2d: ...
    def clip(self, other: IBoundingBox2d) -> IBoundingBox2d: ...
    @property
    def bounding_box(self) -> IBoundingBox2d: ...
    @property
    def extent(self) -> IVector2: ...
    @property
    def position(self) -> IVector2: ...
    @property
    def size(self) -> IVector2: ...
    @property
    def points(self) -> tuple[IVector2, IVector2, IVector2, IVector2]: ...
    def to_d(self) -> DBoundingBox2d: ...
    def to_f(self) -> FBoundingBox2d: ...
