"""
Type definitions for the model-drift-detector package.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
import json


class DriftType(Enum):
    """Types of drift that can be detected."""
    DATA_DRIFT = "data_drift"
    CONCEPT_DRIFT = "concept_drift"
    PREDICTION_DRIFT = "prediction_drift"
    FEATURE_DRIFT = "feature_drift"
    LABEL_DRIFT = "label_drift"
    COVARIATE_SHIFT = "covariate_shift"
    PRIOR_PROBABILITY_SHIFT = "prior_probability_shift"


class DriftSeverity(Enum):
    """Severity levels for detected drift."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    NONE = "none"


class StatisticalTest(Enum):
    """Statistical tests for drift detection."""
    KS_TEST = "kolmogorov_smirnov"
    CHI_SQUARE = "chi_square"
    PSI = "population_stability_index"
    JS_DIVERGENCE = "jensen_shannon_divergence"
    KL_DIVERGENCE = "kullback_leibler_divergence"
    WASSERSTEIN = "wasserstein_distance"
    T_TEST = "t_test"
    MANN_WHITNEY = "mann_whitney"
    ANDERSON_DARLING = "anderson_darling"


class FeatureType(Enum):
    """Types of features."""
    NUMERICAL = "numerical"
    CATEGORICAL = "categorical"
    BINARY = "binary"
    TEXT = "text"
    DATETIME = "datetime"
    UNKNOWN = "unknown"


class AlertLevel(Enum):
    """Alert levels for monitoring."""
    EMERGENCY = "emergency"
    ALERT = "alert"
    WARNING = "warning"
    INFO = "info"


@dataclass
class DriftScore:
    """Score for a single drift detection."""
    score: float
    p_value: Optional[float] = None
    test_used: Optional[StatisticalTest] = None
    threshold: float = 0.05
    is_drifted: bool = False
    details: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if self.p_value is not None and self.p_value < self.threshold:
            self.is_drifted = True
        elif self.p_value is None and self.score > self.threshold:
            self.is_drifted = True


@dataclass
class FeatureDrift:
    """Drift information for a single feature."""
    feature_name: str
    feature_type: FeatureType
    drift_score: DriftScore
    severity: DriftSeverity
    reference_stats: Dict[str, Any] = field(default_factory=dict)
    current_stats: Dict[str, Any] = field(default_factory=dict)
    description: str = ""
    suggestion: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "feature_name": self.feature_name,
            "feature_type": self.feature_type.value,
            "drift_score": self.drift_score.score,
            "p_value": self.drift_score.p_value,
            "is_drifted": self.drift_score.is_drifted,
            "severity": self.severity.value,
            "reference_stats": self.reference_stats,
            "current_stats": self.current_stats,
            "description": self.description,
            "suggestion": self.suggestion,
        }


@dataclass
class PredictionDrift:
    """Drift information for model predictions."""
    drift_score: DriftScore
    severity: DriftSeverity
    reference_distribution: Dict[str, float] = field(default_factory=dict)
    current_distribution: Dict[str, float] = field(default_factory=dict)
    confidence_shift: Optional[float] = None
    description: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "drift_score": self.drift_score.score,
            "p_value": self.drift_score.p_value,
            "is_drifted": self.drift_score.is_drifted,
            "severity": self.severity.value,
            "reference_distribution": self.reference_distribution,
            "current_distribution": self.current_distribution,
            "confidence_shift": self.confidence_shift,
            "description": self.description,
        }


@dataclass
class PerformanceDrift:
    """Drift in model performance metrics."""
    metric_name: str
    reference_value: float
    current_value: float
    change_percent: float
    severity: DriftSeverity
    is_degraded: bool = False
    threshold: float = 0.1
    description: str = ""
    
    def __post_init__(self):
        if abs(self.change_percent) > self.threshold:
            self.is_degraded = True
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "metric_name": self.metric_name,
            "reference_value": self.reference_value,
            "current_value": self.current_value,
            "change_percent": self.change_percent,
            "severity": self.severity.value,
            "is_degraded": self.is_degraded,
        }


@dataclass
class Alert:
    """Alert generated by drift detection."""
    alert_id: str
    level: AlertLevel
    drift_type: DriftType
    message: str
    details: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    acknowledged: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "alert_id": self.alert_id,
            "level": self.level.value,
            "drift_type": self.drift_type.value,
            "message": self.message,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged,
        }


@dataclass
class DriftConfig:
    """Configuration for drift detection."""
    # Statistical test settings
    default_test: StatisticalTest = StatisticalTest.KS_TEST
    categorical_test: StatisticalTest = StatisticalTest.CHI_SQUARE
    significance_level: float = 0.05
    
    # PSI thresholds
    psi_threshold_low: float = 0.1
    psi_threshold_high: float = 0.25
    
    # Performance drift thresholds
    performance_threshold_warning: float = 0.05
    performance_threshold_critical: float = 0.1
    
    # Feature drift settings
    min_samples_for_test: int = 30
    max_categories: int = 100
    
    # Alerting
    enable_alerts: bool = True
    alert_on_any_drift: bool = False
    alert_on_critical_only: bool = False
    
    # Monitoring
    monitoring_window_size: int = 1000
    baseline_window_size: int = 10000
    
    # Feature selection
    features_to_monitor: Optional[List[str]] = None
    features_to_ignore: Optional[List[str]] = None


@dataclass
class ReferenceData:
    """Reference (baseline) data for drift comparison."""
    data: Any  # Can be numpy array, pandas DataFrame, or list
    feature_names: List[str] = field(default_factory=list)
    feature_types: Dict[str, FeatureType] = field(default_factory=dict)
    statistics: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    predictions: Optional[Any] = None
    labels: Optional[Any] = None
    created_at: datetime = field(default_factory=datetime.now)
    sample_count: int = 0
    
    def __post_init__(self):
        if hasattr(self.data, '__len__'):
            self.sample_count = len(self.data)


@dataclass
class DriftReport:
    """Complete drift detection report."""
    report_id: str
    timestamp: datetime
    reference_period: str
    current_period: str
    overall_drift_detected: bool
    overall_severity: DriftSeverity
    feature_drifts: List[FeatureDrift] = field(default_factory=list)
    prediction_drift: Optional[PredictionDrift] = None
    performance_drifts: List[PerformanceDrift] = field(default_factory=list)
    alerts: List[Alert] = field(default_factory=list)
    summary: str = ""
    recommendations: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def drifted_features(self) -> List[str]:
        """Get list of features with detected drift."""
        return [f.feature_name for f in self.feature_drifts if f.drift_score.is_drifted]
    
    @property
    def drift_count(self) -> int:
        """Total number of drifted features."""
        return len(self.drifted_features)
    
    @property
    def critical_drifts(self) -> List[FeatureDrift]:
        """Get features with critical drift."""
        return [f for f in self.feature_drifts if f.severity == DriftSeverity.CRITICAL]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert report to dictionary."""
        return {
            "report_id": self.report_id,
            "timestamp": self.timestamp.isoformat(),
            "reference_period": self.reference_period,
            "current_period": self.current_period,
            "overall_drift_detected": self.overall_drift_detected,
            "overall_severity": self.overall_severity.value,
            "drift_count": self.drift_count,
            "drifted_features": self.drifted_features,
            "feature_drifts": [f.to_dict() for f in self.feature_drifts],
            "prediction_drift": self.prediction_drift.to_dict() if self.prediction_drift else None,
            "performance_drifts": [p.to_dict() for p in self.performance_drifts],
            "alerts": [a.to_dict() for a in self.alerts],
            "summary": self.summary,
            "recommendations": self.recommendations,
            "metadata": self.metadata,
        }
    
    def to_json(self, indent: int = 2) -> str:
        """Convert report to JSON string."""
        return json.dumps(self.to_dict(), indent=indent, default=str)


@dataclass
class MonitoringWindow:
    """A window of data for monitoring."""
    window_id: str
    start_time: datetime
    end_time: datetime
    sample_count: int
    data: Any = None
    predictions: Optional[Any] = None
    labels: Optional[Any] = None
    statistics: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "window_id": self.window_id,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat(),
            "sample_count": self.sample_count,
            "statistics": self.statistics,
        }


@dataclass
class DriftMetrics:
    """Aggregated drift metrics over time."""
    total_checks: int = 0
    drift_detected_count: int = 0
    alerts_generated: int = 0
    features_monitored: int = 0
    avg_drift_score: float = 0.0
    max_drift_score: float = 0.0
    most_drifted_feature: Optional[str] = None
    last_check_time: Optional[datetime] = None
    history: List[Dict[str, Any]] = field(default_factory=list)
    
    @property
    def drift_rate(self) -> float:
        """Percentage of checks that detected drift."""
        if self.total_checks == 0:
            return 0.0
        return self.drift_detected_count / self.total_checks
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_checks": self.total_checks,
            "drift_detected_count": self.drift_detected_count,
            "drift_rate": self.drift_rate,
            "alerts_generated": self.alerts_generated,
            "features_monitored": self.features_monitored,
            "avg_drift_score": self.avg_drift_score,
            "max_drift_score": self.max_drift_score,
            "most_drifted_feature": self.most_drifted_feature,
            "last_check_time": self.last_check_time.isoformat() if self.last_check_time else None,
        }


@dataclass
class WebhookConfig:
    """Configuration for alert webhooks."""
    url: str
    method: str = "POST"
    headers: Dict[str, str] = field(default_factory=dict)
    include_report: bool = True
    alert_levels: List[AlertLevel] = field(default_factory=lambda: [AlertLevel.ALERT, AlertLevel.EMERGENCY])
    enabled: bool = True


@dataclass
class MonitoringConfig:
    """Complete monitoring configuration."""
    drift_config: DriftConfig = field(default_factory=DriftConfig)
    webhooks: List[WebhookConfig] = field(default_factory=list)
    check_interval_seconds: int = 3600
    retention_days: int = 30
    enable_logging: bool = True
    log_level: str = "INFO"
