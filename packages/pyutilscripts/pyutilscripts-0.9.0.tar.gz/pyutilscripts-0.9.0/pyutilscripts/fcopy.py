#! python
# -*- coding: utf-8 -*-
#
# This file is part of the PyUtilScripts project.
# Copyright (c) 2020-2025 zero <zero.kwok@foxmail.com>
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code.
#

import os
import re
import sys
import stat
import math
import shlex
import click
import shutil
import difflib
import filecmp
import argparse
import datetime
import traceback
from typing import Tuple, List, Set
from pathlib import Path
from natsort import natsorted
from datetime import datetime
from termcolor import cprint

from . import utils

CopyModes = ["update", "overwrite", "rename", "u", "o", "r"]

ListFileHead = """# File list generated by fcopy on {Date}
# One file per line, relative to source directory
# From  : {Source}
# Count : {Count}
"""

ActionFileHead = """# Action plan for file copying (edit this file to change actions)
#
# Actions:
# c - Copy      : Target doesn't exist
# u - Update    : Target exists with metadata mismatch, source is newer
# o - Overwrite : Target exists, copy and overwrite unconditionally (--mode overwrite)
# r - Rename    : Target exists, copy with incremented filename (--mode rename)
# e - MakeDir   : Source is an empty directory (not auto-created by subfile copy)
# m - Missing   : Source doesn't exist
# i - Ignore    : Source and target are the same but with metadata differences, 
#                 or source and target differ and source is older
# f - Filter    : Source excluded (--filter)
# s - Skip      : Target exists, no differences found in shallow or deep comparison
#
# Example:
# c file1.txt                   Copy
# r file3.txt -> file(3).txt    Copy and Rename to file(3).txt
# i file2.txt # file:=, meta:>  Files are the same and source file is newer
# i file2.txt # file:≠, meta:<  Files are different and source is older
#
# Source Directory: {Source}
# Target Directory: {Target}
# Blacklist       : {Filter}
# Action Count    : {Count}
"""

ActionPriority = ["c", "u", "o", "r", "e", "m", "i", "f", "s"]

ActionTags = {
    "c": "Copy",
    "u": "Update",
    "o": "Overwrite",
    "r": "Rename",
    "e": "MakeDir",
    "m": "Missing",
    "i": "Ignore",
    "f": "Filter",
    "s": "Skip",
}

ActionDescriptions = {
    "c": "# Files to copy: {}",
    "u": "# Files to update: {}",
    "o": "# Files to overwrite: {}",
    "r": "# Files to rename: {}",
    "e": "# Empty directories to create: {}",
    "m": "# Source files missing: {}",
    "i": "# Files to ignore: {}",
    "f": "# Files filtered out: {}",
    "s": "# Files to skip: {}",
}

ActionColors = {
    "c": "green",
    "u": "green",
    "o": "yellow",
    "r": "yellow",
    "e": "green",
    "m": "magenta",
    "i": "white",
    "f": "white",
    "s": "white",
}


def output(level, *args, **kwargs):
    """
    Output messages with specified level.
    0 - error (red, stderr)
    1 - warning (yellow, stderr) - can be treated as error in strict mode
    2 - normal output (stdout)
    3 - verbose (stdout, only when verbose enabled)
    """

    # Extract control parameters
    verbose_mode = kwargs.pop("verbose", False)
    strict_mode = kwargs.pop("strict", False)

    # Handle verbose filtering
    if level > 2 and not verbose_mode:
        return

    # Handle strict mode: upgrade warnings to errors
    if level == 1 and strict_mode:
        level = 0

    # Add appropriate prefixes
    if len(args) == 0:
        args = ("",)

    if level == 0:
        args = (
            "Error: " + args[0],
            *args[1:],
        )
    elif level == 1:
        args = (
            "Warning: " + args[0],
            *args[1:],
        )

    # Set output destination and color
    if level == 0:
        kwargs.setdefault("file", sys.stderr)
        kwargs.setdefault("color", "red")
    elif level == 1:
        kwargs.setdefault("file", sys.stderr)
        kwargs.setdefault("color", "yellow")
    elif level == 2:
        kwargs.setdefault("file", sys.stdout)
    elif level == 3:
        kwargs.setdefault("file", sys.stdout)
        kwargs.setdefault("color", "blue")  # Optional: different color for verbose

    # Output the message
    cprint(*args, **kwargs)


def read_file_list(filename, comment="#", keep_comments=False):
    """Read the list of files to copy from the manifest file."""
    if filename is None:
        return None
    with open(filename, "r") as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out comments and empty lines
    files = []
    for line in lines:
        if not keep_comments:
            if line.startswith(comment) or not line:
                continue
        files.append(line)
    return files


def filter_match(file, patterns):
    if not patterns:
        return False
    return any(p.match(file) for p in patterns)


def read_file_filter(filename, comment="#"):
    patterns = []
    try:
        for line in read_file_list(filename, comment, False) or []:
            patterns.append(re.compile(line))
    except FileNotFoundError:
        pass  # ignore missing file
    return patterns


def make_file_list(source, filters=[], verbose=False):
    def handle_files(files, root, names):
        for n in names:
            filename = os.path.join(root, n)
            filename = os.path.relpath(filename, start=source)
            if filter_match(filename, filters):
                output(3, f"Filtered: {filename}", verbose=verbose)
                continue
            files.append(filename)

    dirs = []
    files = []
    for root, _dirs, _files in os.walk(source):
        handle_files(dirs, root, _dirs)
        handle_files(files, root, _files)

    date = datetime.now().isoformat(timespec="seconds")
    info = f"{len(dirs)} directories, {len(files)} files"
    head = ListFileHead.format(Date=date, Source=source, Count=info).splitlines()
    return head + [""] + natsorted(dirs + files)


def update_file_list(args):
    """Update the file list with the current contents of the source directory."""
    new = make_file_list(args.source, args.filter_patterns, args.verbose)
    old = []
    if os.path.exists(args.list):
        with open(args.list, "r") as f:
            old = [line.strip() for line in f.readlines()]

    # 生成 unified diff
    diff = difflib.unified_diff(
        old,
        new,
        fromfile=args.list + " (old)",
        tofile=args.list + " (new)",
        lineterm="",
    )

    # 对 diff 行进行彩色渲染
    print("")
    for line in diff:
        if line.startswith("+"):
            cprint(line, "green")  # 新增行：绿色
        elif line.startswith("-"):
            cprint(line, "red")  # 删除行：红色
        elif line.startswith("@@"):
            cprint(line, "cyan")  # 差异位置标记：青色
        else:
            cprint(line)

    # Ask for confirmation
    cprint(f"\nUpdate {args.list} with these changes? [y/N]", end=" ")
    confirm = input().strip().lower()
    if confirm != "y":
        output(0, "User Cancelled")
        return 1

    with open(args.list, "w") as f:
        f.write("\n".join(new))
    return 0


def file_cmp(file1, file2, stat1, stat2) -> Tuple[bool, int]:
    """Compare two files and return a tuple of (is_same, meta_cmp)."""
    # 浅比较, 比较文件大小和修改时间
    if stat1.st_size == stat2.st_size and stat1.st_mtime == stat2.st_mtime:
        return True, 0

    # 根据修改时间, 对比谁比较新
    meta_cmp = 1 if stat1.st_mtime >= stat2.st_mtime else -1

    # 深比较
    def _do_cmp(f1, f2):
        bufsize = 8 * 1024
        with open(f1, "rb") as fp1, open(f2, "rb") as fp2:
            while True:
                b1 = fp1.read(bufsize)
                b2 = fp2.read(bufsize)
                if b1 != b2:
                    return False
                if not b1:
                    return True

    if stat1.st_size == stat2.st_size and _do_cmp(file1, file2):
        return True, meta_cmp
    return False, meta_cmp


def increment_filename(directory, filename, rename_list):
    """
    在指定目录中为给定文件名生成不冲突的新文件名（仅文件名部分，不含路径）。
    支持多扩展名（如 .tar.gz）及已有的 (1)、(2) 递增模式。
    """
    directory = Path(directory)
    filename = Path(filename)
    components = filename.parent
    filename = filename.name

    stem, *suffixes = filename.split(".")
    suffix = "." + ".".join(suffixes) if suffixes else ""

    # 若 stem 形如 "file(1)"，则提取基础名与编号
    match = re.match(r"^(.*?)(\((\d+)\))?$", stem)
    if match:
        stem = match.group(1)
        number = int(match.group(3)) if match.group(3) else 0
    else:
        number = 0

    # 除了判断文件系统中是否存在之外, 还要判断计划中产生的文件是否存在
    def exists(d, c, f):
        if (d / c / f).exists():
            return True
        if rename_list:
            if (c / f) in rename_list:
                return True
        return False

    # 初始候选
    candidate = filename
    while exists(directory, components, candidate):
        number += 1
        candidate = f"{stem}({number}){suffix}"

    return components / candidate


class Action:
    """Action类用于描述操作行为"""

    def __init__(self, action: str, src: str, dst: str = "", attributes=None):
        self.action = action
        self.src = src
        self.dst = dst
        self.attributes = attributes

    def __iter__(self):
        return iter((self.action, self.src, self.dst))

    def natsorted(actions, priority=ActionPriority):
        keys = {c: i for i, c in enumerate(priority)}
        return natsorted(actions, key=lambda a: (keys[a.action], a.src, a.dst))


def make_actions(args):
    items: List[Action] = []
    dirs: Set[str] = set()
    renamed: Set[str] = set()

    for file in args.manifest:
        source = os.path.normpath(os.path.join(args.source, file))
        target = os.path.normpath(os.path.join(args.target, file))

        # 过滤掉名单中的文件
        if filter_match(source, args.filter_patterns):
            items.append(Action("f", file))
            continue

        try:
            stat1 = os.stat(source)
        except:
            if args.strict:
                output(0, f"Source Missing: {source}")
                raise SystemExit()
            else:
                items.append(Action("m", file))  # missing
            continue

        try:
            stat2 = os.stat(target)
        except FileNotFoundError:
            if stat.S_ISDIR(stat1.st_mode):
                dirs.add(file)  # dir that target is not exist
            else:
                items.append(Action("c", file))
            continue

        if stat.S_ISDIR(stat1.st_mode):  # 目录直接跳过, 因为拷贝文件会尝试创建目录
            continue

        if args.mode in ("r", "rename"):
            file2 = increment_filename(args.target, file, renamed)
            items.append(Action("r", file, str(file2)))
            renamed.add(file2)
            continue

        elif args.mode in ("o", "overwrite"):
            items.append(Action("o", file))
            continue

        # update mode
        is_same, meta_cmp = file_cmp(source, target, stat1, stat2)
        attributes = (is_same, meta_cmp, stat1, stat2) if meta_cmp != 0 else None
        if is_same:
            # i 文件内容相同, 但属性不同: meta_cmp > 0 源文件修改时间更近, 否则反之
            items.append(
                Action("s" if meta_cmp == 0 else "i", file, attributes=attributes)
            )
        else:
            # i 文件内容不同, 且目标文件修改时间更近
            items.append(
                Action("u" if meta_cmp >= 1 else "i", file, attributes=attributes)
            )

    # 仅记录空目录，因为空目录不能被拷贝隐式创建
    for a in items:
        if a.action in ("c", "o", "u", "r"):
            for p in Path(a.src).parents:
                dirs.discard(str(p))
    for f in dirs:
        items.append(Action("e", f))

    # 按优先级排序
    return Action.natsorted(items)


def parse_actions(lines, comment="#"):
    files = []
    for row, line in enumerate(lines):
        line = line.strip()
        if line.startswith('\ufeff'): # BOM
            line = line[1:]
        if not line or line.startswith(comment):
            continue

        # Handle action-prefixed lines (for edit mode)
        if " " not in line:
            raise ValueError(f"Invalid line: {row}: {line}")
        fields = shlex.split(line, posix=os.name != "nt")

        # remove comments fields
        result = []
        for f in fields:
            if f.startswith(comment):
                break
            result.append(f)
        fields = result

        if len(fields) == 2:
            action, file1, file2 = fields + [""]
        elif len(fields) == 4 and "->" in fields:
            action, file1, _, file2 = fields
        else:
            raise ValueError(f"Invalid line: {row}: {line}, parse as: {fields}")
        files.append(Action(action, file1.strip(" '\""), file2.strip(" '\"")))

    return files


def read_file_actions(filename, comment="#"):
    return parse_actions(read_file_list(filename, comment, True), comment)


def line_append_space(line, align=16, minLength=32):
    l = len(line)
    n = math.ceil(l / align) * align
    n = max(n, minLength)
    return line + max(n - l, 1) * " "


def join_actions(actions: list[Action], head: str, args):
    def comment1(prefix, same, cmp): 
        return f'{prefix} file:{["≠", "="][same]}, meta:{["<", ">"][cmp == 1]}'
    def comment2(prefix, stat): 
        return f"{prefix} {utils.format_ftime(stat.st_mtime)}, {utils.format_bytes(stat.st_size)}"

    lines = []
    current = ""
    counter = {}
    for item in actions:
        # 统计
        if current != item.action:
            current = item.action
            counter[item.action] = 0
            lines.append("")
            lines.append(ActionDescriptions[item.action].format(f"{{{item.action}}}"))
        counter[item.action] += 1
        
        line = f'{item.action} "{item.src}"'
        if item.dst:
            line += f' -> "{item.dst}"'
        if item.attributes and args.verbose <= 0:
            same, cmp, _, _ = item.attributes
            line = line_append_space(line) + comment1('#', same, cmp)
        lines.append(line)

        if item.attributes and args.verbose > 0:  # 详细模式下，以独立的行存在
            same, cmp, stat1, stat2 = item.attributes
            lines.append(comment1('#   Status:', same, cmp))
            lines.append(comment2('#   Source:', stat1))
            lines.append(comment2('#   Target:', stat2))

    info = str(counter).replace("'", "") + f"={len(actions)}"
    head = head.format(
        Source=args.source, Target=args.target, Count=info,
        Filter=os.path.abspath(args.filter) if args.filter else ""
    )
    body = "\n".join(lines)
    body = body.format(**counter)

    return head.rstrip() + "\n" + body + "\n"


def print_actions(actions: list, head: str, args):
    output(2, f"\nThe following actions will be performed:\n", "yellow")
    colors = {
        "#": "dark_grey",
        " ": "white",
    }
    colors.update(ActionColors)

    lines = join_actions(actions, head, args)
    for line in lines.splitlines():
        if not line:
            output(2)
            continue

        a = line.strip()[0]
        f = a if a in colors else " "
        output(2, line, colors[f])
    output(2)


def get_available_editor(defaults=["nano", "vim", "vi", "notepad"]):
    """检查哪个编辑器可用，返回第一个可用的，否则返回 None"""
    if "EDITOR" in os.environ:
        defaults.insert(0, os.environ["EDITOR"])
        cprint(f"Preferred editor detected: {defaults[0]}", "yellow")
    for editor in defaults:
        if shutil.which(editor):  # 检查是否在 PATH 里
            return editor
    return None


def edit_actions(actions: list, head: str, args) -> list:
    """
    使用 click.edit() 启动编辑器让用户编辑行动计划。
    返回: None 用户取消编辑或没保存
    """
    content = join_actions(actions, head, args)

    # 打开编辑器让用户编辑内容
    edited = click.edit(
        content, extension=".actions-todo", editor=get_available_editor()
    )
    if edited is None:
        output(0, "User canceled or didn't save, aborted.")
        raise SystemExit()

    # 解析用户编辑后的结果
    return parse_actions(edited.splitlines(), "#")


def copy_files(args):
    """Copy files from source directory to target directory with specified manifest"""
    args.manifest = read_file_list(args.list)
    if not args.manifest:
        output(0, "list file is empty or invalid.")
        return 1

    actions = make_actions(args)
    if not actions:
        output(0, "Error: No actions to perform.")
        return 1

    if args.interactive:
        actions = edit_actions(actions, ActionFileHead, args)
    elif args.dry_run or args.verbose > 1:
        print_actions(actions, ActionFileHead, args)
    output(2)

    copied, skipped, missing, filtered = 0, 0, 0, 0
    for action, file1, file2 in actions:
        file2 = file2 or file1
        if action in ("s", "i"):
            skipped += 1
            continue
        elif action == "f":
            filtered += 1
            if not args.interactive:  # 交互模式下，已经显示过了, 因此不再展示
                output(3, f"Filtered: {file1}", verbose=args.verbose)
            continue
        elif action == "m":
            missing += 1
            if not args.interactive:
                output(1, f"Source Missing: {file1}")
            continue

        source = os.path.normpath(os.path.join(args.source, file1))
        target = os.path.normpath(os.path.join(args.target, file2))

        if action in ("c", "u", "o", "r"):
            if os.path.isdir(source):
                continue

            title = "Dry run: " if args.dry_run else ""
            prefix = ActionTags[action]
            stems = f"{file1} -> {file2}" if args.verbose > 0 or args.dry_run else f"{file1}"
            stems = f"{source} -> {target}" if args.verbose > 1 else stems
            color = "cyan" if args.dry_run else "green"
            output(2, f"{title}{prefix} {stems}", color)
 
            if not args.dry_run:
                try:
                    os.makedirs(os.path.dirname(target), exist_ok=True)
                    shutil.copy2(source, target)
                except OSError as e:
                    output(0, f"{prefix} {source} to {target}: {e}")
                    return 1
            copied += 1

        elif action == "e":
            try:
                os.makedirs(target, exist_ok=True)
            except OSError as e:
                output(0, f"{prefix} {source} to {target}: {e}")
                return 1
            copied += 1

    output(
        2,
        f"Done. {copied} copied, {skipped} skipped, {missing} missing, {filtered} filtered.",
    )
    return 0


def main():
    try:
        parser = argparse.ArgumentParser(
            description="Copy files from source directory to target directory with flexible copy modes.",
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        )
        parser = argparse.ArgumentParser(
            description="Copy files from source directory to target directory."
        )
        parser.add_argument(
            "-l",
            "--list",
            default="fcopy.list",
            help="File containing the list of files to copy.",
        )
        parser.add_argument(
            "-s",
            "--source",
            required=True,
            help="source directory containing files to copy",
        )
        parser.add_argument(
            "-t", "--target", help="target directory where files will be copied"
        )
        parser.add_argument(
            "-m",
            "--mode",
            default="update",
            choices=CopyModes,
            help="copy mode: u|update, o|overwrite, r|rename",
        )
        parser.add_argument(
            "-i",
            "--interactive",
            action="store_true",
            help="Let the user edit the list of action plans to copy",
        )
        parser.add_argument(
            "-v",
            "--verbose",
            action="count",
            default=0,
            help="increase verbosity level (use -vv for more detail)",
        )
        parser.add_argument(
            "--filter", help="file containing blacklist regex patterns, one per line."
        )
        parser.add_argument(
            "--update-list",
            action="store_true",
            help="update the --list file with current --source contents (with confirmation)",
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="simulate operations without actually copying files",
        )
        parser.add_argument(
            "--strict",
            action="store_true",
            help="treat warnings as errors (exit with non-zero code on warnings)",
        )
        parser.add_argument(
            "--debug", action="store_true", default=False, help=argparse.SUPPRESS
        )

        try:
            args = parser.parse_args()
        except SystemExit:
            print("\n".join(parser.format_help().splitlines()[1:]))
            raise

        # argparse 默认会保留字符串中的引号
        for key in args.__dict__:
            if type(args.__dict__[key]) == str:
                args.__dict__[key] = args.__dict__[key].strip(" '\"")

        if args.debug:
            args.verbose = 2
            input("Wait for debugging and press Enter to continue...")
            
        # print trace info in verbose mode
        if args.verbose > 0:
            output(2, "Options:")
            for f in args.__dict__:
                output(2, f"  - {f}: {args.__dict__[f]}")

        if not args.list or not args.source:
            output(0, "Please provide the required arguments.")
            parser.print_help()
            return 1

        args.mode = args.mode.lower()
        args.source = os.path.normpath(os.path.abspath(args.source))
        if not os.path.isdir(args.source):
            output(0, f"Source directory '{args.source}' does not exist")
            return 1

        # Read the filter file
        args.filter_patterns = []
        if args.filter:
            args.filter = os.path.normpath(args.filter)
            args.filter_patterns = read_file_filter(args.filter)
            if not args.filter_patterns:
                output(0, f"No valid patterns found in filter file '{args.filter}'.")
                return 1

        # Check if running in the terminal, because editor is only available in terminal
        if args.interactive and not sys.stdout.isatty():
            output(
                1,
                "Not running in the terminal (may be a redirect or pipe)",
                strict=args.strict,
            )

        if args.update_list:
            return update_file_list(args)
        else:
            if args.target is None:
                output(0, "Please provide the target directory.")
                return 1
            args.target = os.path.normpath(os.path.abspath(args.target))
            return copy_files(args)

    except KeyboardInterrupt:
        output(2)
        output(0, "Keyboard Interrupt", end="")
        return 1


if __name__ == "__main__":
    sys.exit(main())
