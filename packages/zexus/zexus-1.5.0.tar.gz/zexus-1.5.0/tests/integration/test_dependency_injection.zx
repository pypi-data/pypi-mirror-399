# test_dependency_injection.zx
# Tests for Dependency Injection and Module Mocking

print("=== Test 1: EXTERNAL Dependency Declaration ===")

# This would be in an EXPORT block in actual syntax:
# EXPORT {
#     EXTERNAL DatabaseAPI
#     EXTERNAL CONST max_retries = 3
# }

# For testing, we simulate the concept
let max_retries = 3
let database_connected = false

# Mock DatabaseAPI for testing
let DatabaseAPI = {
    connect: action() {
        database_connected = true
        return true
    },
    query: action(id) {
        if (database_connected) {
            return { id: id, name: "Test User", data: "Sample Data" }
        } else {
            return null
        }
    },
    disconnect: action() {
        database_connected = false
        return true
    }
}

print("✓ External dependencies declared")
print("PASS: Dependency declaration")

print("\n=== Test 2: Dependency Injection ===")

# Function that depends on injected DatabaseAPI
action fetch_data(id) {
    let attempt = 0
    let result = null
    
    while (attempt < max_retries and result == null) {
        result = DatabaseAPI.query(id)
        attempt = attempt + 1
        
        if (result == null) {
            print("  Retry " + str(attempt) + "/" + str(max_retries))
        }
    }
    
    return result
}

# Connect to database
let connected = DatabaseAPI.connect()
if (connected) {
    print("✓ Database connected")
} else {
    print("✗ Database connection failed")
}

# Fetch data using injected dependency
let user_data = fetch_data(123)
if (user_data != null) {
    print("✓ Successfully fetched data: " + user_data.name)
} else {
    print("✗ Failed to fetch data")
}

print("PASS: Dependency injection")

print("\n=== Test 3: Module Mocking for Testing ===")

# Create a mock DatabaseAPI that simulates failure
let MockDatabaseAPI = {
    connect: action() {
        return false  # Simulate connection failure
    },
    query: action(id) {
        return null  # Always return null (simulating failure)
    },
    disconnect: action() {
        return true
    }
}

# Test with mock (in TEST mode, this would be automatically used)
let mock_result = MockDatabaseAPI.query(456)
if (mock_result == null) {
    print("✓ Mock correctly simulated failure")
} else {
    print("✗ Mock should have returned null")
}

# Test retry logic with mock
action test_retry_logic() {
    let original_api = DatabaseAPI
    
    # Swap in mock
    DatabaseAPI = MockDatabaseAPI
    
    let retries_executed = 0
    let attempt = 0
    let result = null
    
    # Connect should fail
    let can_connect = DatabaseAPI.connect()
    if (not can_connect) {
        print("  ✓ Mock simulated connection failure")
    }
    
    # Queries should fail and trigger retries
    while (attempt < max_retries and result == null) {
        result = DatabaseAPI.query(999)
        attempt = attempt + 1
        retries_executed = retries_executed + 1
    }
    
    # Restore original
    DatabaseAPI = original_api
    
    if (retries_executed == max_retries) {
        print("✓ Retry logic executed correctly: " + str(retries_executed) + " retries")
        return true
    } else {
        print("✗ Expected " + str(max_retries) + " retries, got " + str(retries_executed))
        return false
    }
}

let test_passed = test_retry_logic()
if (test_passed) {
    print("PASS: Module mocking")
} else {
    print("FAIL: Module mocking")
}

print("\n=== Test 4: Spy Functions ===")

# Create a spy that tracks calls
let call_count = 0
let call_args = []

let SpyAPI = {
    query: action(id) {
        call_count = call_count + 1
        call_args = call_args + [id]
        # Return real data
        return { id: id, name: "Spied User" }
    }
}

# Use the spy
let spy_result_1 = SpyAPI.query(100)
let spy_result_2 = SpyAPI.query(200)
let spy_result_3 = SpyAPI.query(300)

if (call_count == 3) {
    print("✓ Spy tracked " + str(call_count) + " calls")
} else {
    print("✗ Expected 3 calls, got " + str(call_count))
}

if (len(call_args) == 3) {
    print("✓ Spy captured arguments: " + str(call_args))
} else {
    print("✗ Spy failed to capture arguments")
}

print("PASS: Spy functions")

print("\n=== Test 5: Dependency Validation ===")

# Test missing required dependency
let has_error = false

action require_dependency(dep_name) {
    # In real implementation, this would check the DI registry
    let required_deps = ["DatabaseAPI", "max_retries"]
    
    let found = false
    for dep in required_deps {
        if (dep == dep_name) {
            found = true
        }
    }
    
    if (not found) {
        print("✗ Missing required dependency: " + dep_name)
        return false
    } else {
        print("✓ Required dependency satisfied: " + dep_name)
        return true
    }
}

let dep1_ok = require_dependency("DatabaseAPI")
let dep2_ok = require_dependency("max_retries")
let dep3_ok = require_dependency("MissingAPI")

if (dep1_ok and dep2_ok and not dep3_ok) {
    print("✓ Dependency validation working correctly")
    print("PASS: Dependency validation")
} else {
    print("✗ Dependency validation failed")
    print("FAIL: Dependency validation")
}

print("\n=== All Dependency Injection Tests Passed ===")
