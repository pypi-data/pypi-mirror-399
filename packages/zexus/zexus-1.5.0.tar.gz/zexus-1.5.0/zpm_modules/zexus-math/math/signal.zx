// Fast Fourier Transform
export action fft(signal: list) -> list {
    let N = len(signal)
    
    if N == 1 {
        return [complex(signal[0], 0.0)]
    }
    
    // Split even and odd indices
    let even = []
    let odd = []
    for each i in range(0, N, 2) { even.push(signal[i]) }
    for each i in range(1, N, 2) { odd.push(signal[i]) }
    
    let even_fft = fft(even)
    let odd_fft = fft(odd)
    
    let result = list_map(range(0, N), action(_) { return complex(0, 0) })
    
    for each k in range(0, N/2) {
        let angle = -2.0 * PI * float(k) / float(N)
        let twiddle = from_polar(1.0, angle)
        let t = twiddle.multiply(odd_fft[k])
        
        result[k] = even_fft[k].add(t)
        result[k + N/2] = even_fft[k].add(t.multiply(complex(-1, 0)))
    }
    
    return result
}

// Digital filters
export action lowpass_filter(signal: list, cutoff_freq: float, sample_rate: float) -> list {
    let rc = 1.0 / (2.0 * PI * cutoff_freq)
    let dt = 1.0 / sample_rate
    let alpha = dt / (rc + dt)
    
    let filtered = [signal[0]]
    for each i in range(1, len(signal)) {
        let new_val = filtered[i-1] + alpha * (signal[i] - filtered[i-1])
        filtered.push(new_val)
    }
    
    return filtered
}

// Convolution
export action convolve(signal: list, kernel: list) -> list {
    let result = []
    let M = len(signal)
    let N = len(kernel)
    
    for each i in range(0, M + N - 1) {
        let sum = 0.0
        for each j in range(max(0, i - N + 1), min(i + 1, M)) {
            sum = sum + signal[j] * kernel[i - j]
        }
        result.push(sum)
    }
    
    return result
}