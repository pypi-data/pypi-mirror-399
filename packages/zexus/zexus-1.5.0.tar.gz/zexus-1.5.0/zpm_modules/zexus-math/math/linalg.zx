contract Matrix2D implements Matrix {
    persistent storage data: list
    persistent storage num_rows: integer
    persistent storage num_cols: integer
    
    action init(rows: integer, cols: integer, data: list) {
        require(rows > 0, "Number of rows must be positive")
        require(cols > 0, "Number of columns must be positive")
        
        // Auto-expand empty data
        if len(data) == 0 {
            data = list_map(range(0, rows * cols), action(_) { return 0.0 })
        }
        
        require(len(data) == rows * cols, "Data size doesn't match dimensions")
        
        // Validate and convert data elements
        let validated_data = []
        for each val in data {
            if typeof(val) == "integer" {
                validated_data.push(float(val))
            } else if typeof(val) == "float" {
                validated_data.push(val)
            } else {
                throw "Matrix elements must be numeric"
            }
        }
        
        this.num_rows = rows
        this.num_cols = cols
        this.data = validated_data
    }
    
    action rows() -> integer { return this.num_rows }
    action cols() -> integer { return this.num_cols }
    
    action get(row: integer, col: integer) -> float {
        require(row >= 0 and row < this.num_rows, "Row index out of bounds")
        require(col >= 0 and col < this.num_cols, "Column index out of bounds")
        return this.data[row * this.num_cols + col]
    }
    
    action determinant() -> float {
        require(this.num_rows == this.num_cols, "Matrix must be square")
        
        if this.num_rows == 1 {
            return this.get(0, 0)
        } else if this.num_rows == 2 {
            return this.get(0, 0) * this.get(1, 1) - this.get(0, 1) * this.get(1, 0)
        } else {
            // Recursive determinant calculation
            let det = 0.0
            for each col in range(0, this.num_cols) {
                let minor = this.minor_matrix(0, col)
                let sign = if col % 2 == 0 then 1.0 else -1.0
                det = det + sign * this.get(0, col) * minor.determinant()
            }
            return det
        }
    }
    
    action minor_matrix(row: integer, col: integer) -> Matrix {
        let minor_data = []
        for each r in range(0, this.num_rows) {
            if r == row { continue }
            for each c in range(0, this.num_cols) {
                if c == col { continue }
                minor_data.push(this.get(r, c))
            }
        }
        return Matrix2D{
            rows: this.num_rows - 1,
            cols: this.num_cols - 1,
            data: minor_data
        }
    }
    
    action multiply(other: Matrix) -> Matrix {
        require(this.num_cols == other.rows(), "Matrix dimensions don't match for multiplication")
        
        let result_data = []
        for each i in range(0, this.num_rows) {
            for each j in range(0, other.cols()) {
                let sum = 0.0
                for each k in range(0, this.num_cols) {
                    sum = sum + this.get(i, k) * other.get(k, j)
                }
                result_data.push(sum)
            }
        }
        
        return Matrix2D{
            rows: this.num_rows,
            cols: other.cols(),
            data: result_data
        }
    }
    
    action inverse() -> Matrix {
        let det = this.determinant()
        require(abs(det) > EPSILON, "Matrix is singular, cannot invert")
        
        if this.num_rows == 2 {
            let a = this.get(0, 0)
            let b = this.get(0, 1)
            let c = this.get(1, 0)
            let d = this.get(1, 1)
            
            let inv_det = 1.0 / det
            return Matrix2D{
                rows: 2,
                cols: 2,
                data: [d * inv_det, -b * inv_det, -c * inv_det, a * inv_det]
            }
        } else {
            // Use adjugate matrix for larger matrices
            return this.adjugate().scale(1.0 / det)
        }
    }
    
    // New methods
    action trace() -> float {
        require(this.num_rows == this.num_cols, "Trace requires square matrix")
        let sum = 0.0
        for each i in range(0, this.num_rows) {
            sum = sum + this.get(i, i)
        }
        return sum
    }
    
    action add(other: Matrix) -> Matrix {
        require(this.num_rows == other.rows() and this.num_cols == other.cols(),
               "Matrix dimensions must match for addition")
        
        let result_data = []
        for each i in range(0, len(this.data)) {
            result_data.push(this.data[i] + other.data[i])
        }
        
        return Matrix2D{rows: this.num_rows, cols: this.num_cols, data: result_data}
    }
    
    action subtract(other: Matrix) -> Matrix {
        require(this.num_rows == other.rows() and this.num_cols == other.cols(),
               "Matrix dimensions must match for subtraction")
        
        let result_data = []
        for each i in range(0, len(this.data)) {
            result_data.push(this.data[i] - other.data[i])
        }
        
        return Matrix2D{rows: this.num_rows, cols: this.num_cols, data: result_data}
    }
    
    action transpose() -> Matrix {
        let transposed_data = []
        for each j in range(0, this.num_cols) {
            for each i in range(0, this.num_rows) {
                transposed_data.push(this.get(i, j))
            }
        }
        
        return Matrix2D{rows: this.num_cols, cols: this.num_rows, data: transposed_data}
    }
    
    action is_symmetric(tolerance: float = EPSILON) -> boolean {
        if this.num_rows != this.num_cols {
            return false
        }
        
        for each i in range(0, this.num_rows) {
            for each j in range(i + 1, this.num_cols) {
                if abs(this.get(i, j) - this.get(j, i)) > tolerance {
                    return false
                }
            }
        }
        
        return true
    }
    
    action is_diagonal(tolerance: float = EPSILON) -> boolean {
        if this.num_rows != this.num_cols {
            return false
        }
        
        for each i in range(0, this.num_rows) {
            for each j in range(0, this.num_cols) {
                if i != j and abs(this.get(i, j)) > tolerance {
                    return false
                }
            }
        }
        
        return true
    }
    
    action adjugate() -> Matrix {
        let cofactor_data = []
        for each i in range(0, this.num_rows) {
            for each j in range(0, this.num_cols) {
                let minor = this.minor_matrix(i, j)
                let sign = if (i + j) % 2 == 0 then 1.0 else -1.0
                cofactor_data.push(sign * minor.determinant())
            }
        }
        
        // Transpose the cofactor matrix
        let adjugate_data = []
        for each j in range(0, this.num_cols) {
            for each i in range(0, this.num_rows) {
                adjugate_data.push(cofactor_data[i * this.num_cols + j])
            }
        }
        
        return Matrix2D{
            rows: this.num_cols,
            cols: this.num_rows,
            data: adjugate_data
        }
    }
    
    action scale(factor: float) -> Matrix {
        let scaled_data = list_map(this.data, action(x) { return x * factor })
        return Matrix2D{
            rows: this.num_rows,
            cols: this.num_cols,
            data: scaled_data
        }
    }
}

// Constants and utilities
let EPSILON = 1e-10

action float(x: any) -> float {
    if typeof(x) == "integer" {
        return x * 1.0
    }
    if typeof(x) == "float" {
        return x
    }
    throw "Cannot convert to float: " + string(x)
}

action abs(x: float) -> float {
    return if x < 0 then -x else x
}

// Matrix constructors with validation
export action matrix(rows: integer, cols: integer, data: list = []) -> Matrix {
    // Validate dimensions
    require(rows > 0, "Number of rows must be positive")
    require(cols > 0, "Number of columns must be positive")
    
    // If data is empty, create zero matrix
    if len(data) == 0 {
        data = list_map(range(0, rows * cols), action(_) { return 0.0 })
    }
    
    return Matrix2D{rows: rows, cols: cols, data: data}
}

export action identity(size: integer) -> Matrix {
    require(size > 0, "Matrix size must be positive")
    
    let data = []
    for each i in range(0, size) {
        for each j in range(0, size) {
            data.push(if i == j then 1.0 else 0.0)
        }
    }
    return matrix(size, size, data)
}

export action zeros(rows: integer, cols: integer) -> Matrix {
    return matrix(rows, cols)  // Empty data creates zero matrix
}

export action ones(rows: integer, cols: integer) -> Matrix {
    let data = list_map(range(0, rows * cols), action(_) { return 1.0 })
    return matrix(rows, cols, data)
}

export action diagonal(values: list) -> Matrix {
    let size = len(values)
    let data = []
    for each i in range(0, size) {
        for each j in range(0, size) {
            data.push(if i == j then float(values[i]) else 0.0)
        }
    }
    return matrix(size, size, data)
}

// Advanced matrix operations
export action solve_linear_system(A: Matrix, b: Matrix) -> Matrix {
    require(A.rows() == A.cols(), "Coefficient matrix must be square")
    require(A.rows() == b.rows(), "Dimensions mismatch between A and b")
    require(b.cols() == 1, "b must be a column vector")
    
    return A.inverse().multiply(b)
}

export action eigenvalues(A: Matrix) -> list {
    // TODO: Implement eigenvalue calculation
    // For now, only support 2x2 matrices
    require(A.rows() == 2 and A.cols() == 2, "Only 2x2 matrices supported for eigenvalues")
    
    let a = A.get(0, 0)
    let b = A.get(0, 1)
    let c = A.get(1, 0)
    let d = A.get(1, 1)
    
    let trace = a + d
    let det = a * d - b * c
    
    let disc = trace * trace - 4 * det
    if disc < 0 {
        throw "Complex eigenvalues not yet supported"
    }
    
    let sqrt_disc = sqrt(disc)
    return [(trace + sqrt_disc) / 2, (trace - sqrt_disc) / 2]
}

action sqrt(x: float) -> float {
    require(x >= 0, "Square root of negative number")
    // TODO: Implement proper sqrt
    return x ** 0.5
}

// Initialize module
action init() {
    print("Linear algebra module initialized")
    print("Supporting: matrix operations, determinants, inverses")
    print("Matrix sizes: arbitrary (some operations limited to 2x2)")
}

init()
