// Function protocol for mathematical functions
protocol MathFunction {
    action evaluate(x: float) -> float
    action derivative() -> MathFunction
}

// Numerical differentiation and integration
export action derivative(f: MathFunction, x: float, h: float = 1e-8) -> float {
    return (f.evaluate(x + h) - f.evaluate(x - h)) / (2 * h)
}

export action integrate(f: MathFunction, a: float, b: float, steps: integer = 1000) -> float {
    let h = (b - a) / steps
    let sum = f.evaluate(a) + f.evaluate(b)
    
    for each i in range(1, steps) {
        let x = a + i * h
        let coefficient = if i % 2 == 0 then 2.0 else 4.0
        sum = sum + coefficient * f.evaluate(x)
    }
    
    return sum * h / 3.0  // Simpson's rule
}

// Root finding algorithms
export action newton_raphson(f: MathFunction, x0: float, tolerance: float = 1e-10, max_iter: integer = 100) -> float {
    let x = x0
    let iter = 0
    
    while iter < max_iter {
        let fx = f.evaluate(x)
        let dfx = derivative(f, x)
        
        if math_abs(fx) < tolerance {
            return x
        }
        
        if dfx == 0 {
            throw "Derivative is zero, cannot continue"
        }
        
        x = x - fx / dfx
        iter = iter + 1
    }
    
    throw "Maximum iterations reached"
}

// Example function implementations
contract Polynomial implements MathFunction {
    persistent storage coefficients: list
    
    action init(coeffs: list) {
        this.coefficients = coeffs
    }
    
    action evaluate(x: float) -> float {
        let result = 0.0
        let power = 1.0
        
        for each coeff in this.coefficients {
            result = result + coeff * power
            power = power * x
        }
        
        return result
    }
    
    action derivative() -> MathFunction {
        let deriv_coeffs = []
        for each i in range(1, len(this.coefficients)) {
            deriv_coeffs.push(this.coefficients[i] * float(i))
        }
        return Polynomial{coefficients: deriv_coeffs}
    }
}
