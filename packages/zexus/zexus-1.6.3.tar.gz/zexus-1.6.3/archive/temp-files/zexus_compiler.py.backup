# zexus_compiler.py
# This file combines all interpreter modules into one. (v1.1 - Final Corrected Version)

import sys

# --- CONTENTS OF renderer/main_renderer.py ---
# We will put this here temporarily. In a real project, it would be a separate file.
try:
    import tkinter as tk
    RENDERER_ENABLED = True
except ImportError:
    RENDERER_ENABLED = False

class Renderer:
    def __init__(self):
        if not RENDERER_ENABLED: return
        self.window = tk.Tk()
        self.window.title("Zexus App")
        self.window.geometry("400x600")

    def render(self, screen_node):
        if not RENDERER_ENABLED:
            print(f"[RENDER-SIM] Simulating screen '{screen_node.name.value}'... (Tkinter not found)")
            return
        print(f"[RENDER] Rendering screen '{screen_node.name.value}' in a real window...")
        self.window.mainloop()

# --- CONTENTS OF zexus_token.py ---
ILLEGAL, EOF = "ILLEGAL", "EOF"
IDENT, INT, STRING = "IDENT", "INT", "STRING"
ASSIGN, PLUS, MINUS, SLASH, STAR = "=", "+", "-", "/", "*"
BANG, LT, GT, EQ, NOT_EQ = "!", "<", ">", "==", "!="
COMMA, SEMICOLON = ",", ";"
LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET = "(", ")", "{", "}", "[", "]"
LET, PRINT, IF, ELSE, RETURN = "LET", "PRINT", "IF", "ELSE", "RETURN"
TRUE, FALSE, FOR, EACH, IN = "TRUE", "FALSE", "FOR", "EACH", "IN"
ACTION, SCREEN = "ACTION", "SCREEN"

class Token:
    def __init__(self, token_type, literal): self.type, self.literal = token_type, literal
    def __repr__(self): return f"Token({self.type}, '{self.literal}')"

# --- CONTENTS OF zexus_ast.py ---
class Node: pass
class Statement(Node): pass
class Expression(Node): pass
class Program(Node):
    def __init__(self): self.statements = []
class LetStatement(Statement):
    def __init__(self, name, value): self.name, self.value = name, value
class ReturnStatement(Statement):
    def __init__(self, return_value): self.return_value = return_value
class ExpressionStatement(Statement):
    def __init__(self, expression): self.expression = expression
class BlockStatement(Statement):
    def __init__(self): self.statements = []
class PrintStatement(Statement):
    def __init__(self, value): self.value = value
class ForEachStatement(Statement):
    def __init__(self, item, iterable, body): self.item, self.iterable, self.body = item, iterable, body
class ScreenStatement(Statement):
    def __init__(self, name, body): self.name, self.body = name, body
class Identifier(Expression):
    def __init__(self, value): self.value = value
class IntegerLiteral(Expression):
    def __init__(self, value): self.value = value
class StringLiteral(Expression):
    def __init__(self, value): self.value = value
class Boolean(Expression):
    def __init__(self, value): self.value = value
class ListLiteral(Expression):
    def __init__(self, elements): self.elements = elements
class ActionLiteral(Expression):
    def __init__(self, parameters, body): self.parameters, self.body = parameters, body
class CallExpression(Expression):
    def __init__(self, function, arguments): self.function, self.arguments = function, arguments
class PrefixExpression(Expression):
    def __init__(self, operator, right): self.operator, self.right = operator, right
class InfixExpression(Expression):
    def __init__(self, left, operator, right): self.left, self.operator, self.right = left, operator, right
class IfExpression(Expression):
    def __init__(self, condition, consequence, alternative=None): self.condition, self.consequence, self.alternative = condition, consequence, alternative

# --- CONTENTS OF object.py ---
class Object:
    def inspect(self): raise NotImplementedError("Subclasses must implement this method")
class Integer(Object):
    def __init__(self, value): self.value = value
    def inspect(self): return str(self.value)
    def type(self): return "INTEGER"
class Boolean(Object):
    def __init__(self, value): self.value = value
    def inspect(self): return "true" if self.value else "false"
    def type(self): return "BOOLEAN"
class Null(Object):
    def inspect(self): return "null"
    def type(self): return "NULL"
class String(Object):
    def __init__(self, value): self.value = value
    def inspect(self): return self.value
    def type(self): return "STRING"
class List(Object):
    def __init__(self, elements): self.elements = elements
    def inspect(self): return f"[{', '.join([el.inspect() for el in self.elements])}]"
    def type(self): return "LIST"
class ReturnValue(Object):
    def __init__(self, value): self.value = value
    def inspect(self): return self.value.inspect()
    def type(self): return "RETURN_VALUE"
class Action(Object):
    def __init__(self, parameters, body, env): self.parameters, self.body, self.env = parameters, body, env
    def inspect(self): return f"action({', '.join([p.value for p in self.parameters])}) {{...}}"
    def type(self): return "ACTION"
class Builtin(Object):
    def __init__(self, fn): self.fn = fn
    def inspect(self): return "<built-in function>"
    def type(self): return "BUILTIN"
class Environment:
    def __init__(self, outer=None): self.store, self.outer = {}, outer
    def get(self, name):
        val = self.store.get(name)
        if val is None and self.outer: return self.outer.get(name)
        return val
    def set(self, name, val): self.store[name] = val; return val

# --- CONTENTS OF lexer.py ---
class Lexer:
    def __init__(self, source_code):
        self.input, self.position, self.read_position, self.ch = source_code, 0, 0, ""
        self.read_char()
    def read_char(self):
        self.ch = self.input[self.read_position] if self.read_position < len(self.input) else ""
        self.position = self.read_position
        self.read_position += 1
    def peek_char(self):
        return self.input[self.read_position] if self.read_position < len(self.input) else ""
    def next_token(self):
        self.skip_whitespace()
        tok = None
        if self.ch == '=': tok = Token(EQ, "==") if self.peek_char() == '=' else Token(ASSIGN, '=')
        elif self.ch == '!': tok = Token(NOT_EQ, "!=") if self.peek_char() == '=' else Token(BANG, '!')
        elif self.ch == '"': tok = Token(STRING, self.read_string())
        elif self.ch == '[': tok = Token(LBRACKET, self.ch)
        elif self.ch == ']': tok = Token(RBRACKET, self.ch)
        elif self.ch == '(': tok = Token(LPAREN, self.ch)
        elif self.ch == ')': tok = Token(RPAREN, self.ch)
        elif self.ch == '{': tok = Token(LBRACE, self.ch)
        elif self.ch == '}': tok = Token(RBRACE, self.ch)
        elif self.ch == ',': tok = Token(COMMA, self.ch)
        elif self.ch == ';': tok = Token(SEMICOLON, self.ch)
        elif self.ch == '+': tok = Token(PLUS, self.ch)
        elif self.ch == '-': tok = Token(MINUS, self.ch)
        elif self.ch == '*': tok = Token(STAR, self.ch)
        elif self.ch == '/': tok = Token(SLASH, self.ch)
        elif self.ch == '<': tok = Token(LT, self.ch)
        elif self.ch == '>': tok = Token(GT, self.ch)
        elif self.ch == "": tok = Token(EOF, "")
        else:
            if self.is_letter(self.ch):
                literal = self.read_identifier()
                token_type = self.lookup_ident(literal)
                return Token(token_type, literal)
            elif self.is_digit(self.ch):
                return Token(INT, self.read_number())
            else: tok = Token(ILLEGAL, self.ch)
        if tok and (tok.type == EQ or tok.type == NOT_EQ): self.read_char()
        self.read_char()
        return tok
    def read_string(self):
        start_pos = self.position + 1
        while True:
            self.read_char()
            if self.ch == '"' or self.ch == "": break
        return self.input[start_pos:self.position]
    def read_identifier(self):
        start_pos = self.position
        while self.is_letter(self.ch): self.read_char()
        return self.input[start_pos:self.position]
    def read_number(self):
        start_pos = self.position
        while self.is_digit(self.ch): self.read_char()
        return self.input[start_pos:self.position]
    def lookup_ident(self, ident):
        keywords = {"let":LET, "print":PRINT, "if":IF, "else":ELSE, "true":TRUE, "false":FALSE, "return":RETURN, "for":FOR, "each":EACH, "in":IN, "action":ACTION, "screen":SCREEN}
        return keywords.get(ident, IDENT)
    def is_letter(self, char): return 'a' <= char <= 'z' or 'A' <= char <= 'Z' or char == '_'
    def is_digit(self, char): return '0' <= char <= '9'
    def skip_whitespace(self):
        while self.ch in [' ', '\t', '\n', '\r']: self.read_char()

# --- CONTENTS OF parser.py ---
LOWEST, EQUALS, LESSGREATER, SUM, PRODUCT, PREFIX, CALL = 1, 2, 3, 4, 5, 6, 7
precedences = {EQ: EQUALS, NOT_EQ: EQUALS, LT: LESSGREATER, GT: LESSGREATER, PLUS: SUM, MINUS: SUM, SLASH: PRODUCT, STAR: PRODUCT, LPAREN: CALL}
class Parser:
    def __init__(self, lexer):
        self.lexer, self.errors, self.cur_token, self.peek_token = lexer, [], None, None
        self.prefix_parse_fns = {IDENT:self.parse_identifier, INT:self.parse_integer_literal, STRING:self.parse_string_literal, BANG:self.parse_prefix_expression, MINUS:self.parse_prefix_expression, TRUE:self.parse_boolean, FALSE:self.parse_boolean, LPAREN:self.parse_grouped_expression, IF:self.parse_if_expression, LBRACKET:self.parse_list_literal, ACTION:self.parse_action_literal}
        self.infix_parse_fns = {PLUS:self.parse_infix_expression, MINUS:self.parse_infix_expression, SLASH:self.parse_infix_expression, STAR:self.parse_infix_expression, EQ:self.parse_infix_expression, NOT_EQ:self.parse_infix_expression, LT:self.parse_infix_expression, GT:self.parse_infix_expression, LPAREN:self.parse_call_expression}
        self.next_token(); self.next_token()
    def next_token(self): self.cur_token, self.peek_token = self.peek_token, self.lexer.next_token()
    def parse_program(self):
        program = Program()
        while not self.cur_token_is(EOF):
            stmt = self.parse_statement()
            if stmt: program.statements.append(stmt)
            self.next_token()
        return program
    def parse_statement(self):
        if self.cur_token_is(LET): return self.parse_let_statement()
        elif self.cur_token_is(RETURN): return self.parse_return_statement()
        elif self.cur_token_is(PRINT): return self.parse_print_statement()
        elif self.cur_token_is(FOR): return self.parse_for_each_statement()
        elif self.cur_token_is(SCREEN): return self.parse_screen_statement()
        else: return self.parse_expression_statement()
    def parse_let_statement(self):
        stmt = LetStatement(name=None, value=None)
        if not self.expect_peek(IDENT): return None
        stmt.name = Identifier(value=self.cur_token.literal)
        if not self.expect_peek(ASSIGN): return None
        self.next_token(); stmt.value = self.parse_expression(LOWEST)
        if self.peek_token_is(SEMICOLON): self.next_token()
        return stmt
    def parse_return_statement(self):
        stmt = ReturnStatement(return_value=None); self.next_token()
        stmt.return_value = self.parse_expression(LOWEST)
        if self.peek_token_is(SEMICOLON): self.next_token()
        return stmt
    def parse_print_statement(self):
        stmt = PrintStatement(value=None); self.next_token()
        stmt.value = self.parse_expression(LOWEST)
        if self.peek_token_is(SEMICOLON): self.next_token()
        return stmt
    def parse_for_each_statement(self):
        stmt = ForEachStatement(item=None, iterable=None, body=None)
        if not self.expect_peek(EACH) or not self.expect_peek(IDENT): return None
        stmt.item = Identifier(value=self.cur_token.literal)
        if not self.expect_peek(IN): return None
        self.next_token(); stmt.iterable = self.parse_expression(LOWEST)
        if not self.expect_peek(LBRACE): return None
        stmt.body = self.parse_block_statement()
        return stmt
    def parse_screen_statement(self):
        stmt = ScreenStatement(name=None, body=None)
        if not self.expect_peek(IDENT): return None
        stmt.name = Identifier(value=self.cur_token.literal)
        if not self.expect_peek(LBRACE): return None
        stmt.body = self.parse_block_statement()
        return stmt
    def parse_expression_statement(self):
        stmt = ExpressionStatement(expression=self.parse_expression(LOWEST))
        if self.peek_token_is(SEMICOLON): self.next_token()
        return stmt
    def parse_expression(self, precedence):
        if self.cur_token.type not in self.prefix_parse_fns: return None
        prefix = self.prefix_parse_fns[self.cur_token.type]
        left_exp = prefix()
        while not self.peek_token_is(SEMICOLON) and precedence < self.peek_precedence():
            if self.peek_token.type not in self.infix_parse_fns: return left_exp
            infix = self.infix_parse_fns[self.peek_token.type]
            self.next_token(); left_exp = infix(left_exp)
        return left_exp
    def parse_identifier(self): return Identifier(value=self.cur_token.literal)
    def parse_integer_literal(self): return IntegerLiteral(value=int(self.cur_token.literal))
    def parse_string_literal(self): return StringLiteral(value=self.cur_token.literal)
    def parse_boolean(self): return Boolean(value=self.cur_token_is(TRUE))
    def parse_list_literal(self): return ListLiteral(elements=self.parse_expression_list(RBRACKET))
    def parse_action_literal(self):
        lit = ActionLiteral(parameters=[], body=None)
        if not self.expect_peek(LPAREN): return None
        lit.parameters = self.parse_action_parameters()
        if not self.expect_peek(LBRACE): return None
        lit.body = self.parse_block_statement()
        return lit
    def parse_prefix_expression(self):
        expression = PrefixExpression(operator=self.cur_token.literal, right=None); self.next_token()
        expression.right = self.parse_expression(PREFIX)
        return expression
    def parse_infix_expression(self, left):
        expression = InfixExpression(left=left, operator=self.cur_token.literal, right=None)
        precedence = self.cur_precedence(); self.next_token()
        expression.right = self.parse_expression(precedence)
        return expression
    def parse_grouped_expression(self):
        self.next_token(); exp = self.parse_expression(LOWEST)
        if not self.expect_peek(RPAREN): return None
        return exp
    def parse_if_expression(self):
        expression = IfExpression(condition=None, consequence=None, alternative=None)
        if not self.expect_peek(LPAREN): return None
        self.next_token(); expression.condition = self.parse_expression(LOWEST)
        if not self.expect_peek(RPAREN) or not self.expect_peek(LBRACE): return None
        expression.consequence = self.parse_block_statement()
        if self.peek_token_is(ELSE):
            self.next_token()
            if not self.expect_peek(LBRACE): return None
            expression.alternative = self.parse_block_statement()
        return expression
    def parse_call_expression(self, function):
        return CallExpression(function=function, arguments=self.parse_expression_list(RPAREN))
    def parse_block_statement(self):
        block = BlockStatement(); self.next_token()
        while not self.cur_token_is(RBRACE) and not self.cur_token_is(EOF):
            stmt = self.parse_statement()
            if stmt: block.statements.append(stmt)
            self.next_token()
        return block
    def parse_action_parameters(self):
        params = []
        if self.peek_token_is(RPAREN): self.next_token(); return params
        self.next_token(); params.append(Identifier(value=self.cur_token.literal))
        while self.peek_token_is(COMMA):
            self.next_token(); self.next_token()
            params.append(Identifier(value=self.cur_token.literal))
        if not self.expect_peek(RPAREN): return None
        return params
    def parse_expression_list(self, end):
        elements = []
        if self.peek_token_is(end): self.next_token(); return elements
        self.next_token(); elements.append(self.parse_expression(LOWEST))
        while self.peek_token_is(COMMA):
            self.next_token(); self.next_token()
            elements.append(self.parse_expression(LOWEST))
        if not self.expect_peek(end): return None
        return elements
    def cur_token_is(self, t): return self.cur_token.type == t
    def peek_token_is(self, t): return self.peek_token.type == t
    def expect_peek(self, t):
        if self.peek_token_is(t): self.next_token(); return True
        return False
    def peek_precedence(self): return precedences.get(self.peek_token.type, LOWEST)
    def cur_precedence(self): return precedences.get(self.cur_token.type, LOWEST)

# --- CONTENTS OF evaluator.py ---
NULL, TRUE, FALSE = Null(), Boolean(True), Boolean(False)
def native_bool_to_boolean_object(value): return TRUE if value else FALSE
def builtin_len(*args):
    if len(args)!=1: return NULL
    arg = args[0]
    if isinstance(arg, String): return Integer(len(arg.value))
    elif isinstance(arg, List): return Integer(len(arg.elements))
    return NULL
def builtin_first(*args):
    if len(args)!=1 or not isinstance(args[0], List) or not args[0].elements: return NULL
    return args[0].elements[0]
def builtin_last(*args):
    if len(args)!=1 or not isinstance(args[0], List) or not args[0].elements: return NULL
    return args[0].elements[-1]
def builtin_rest(*args):
    if len(args)!=1 or not isinstance(args[0], List) or not args[0].elements: return NULL
    return List(args[0].elements[1:])
def builtin_push(*args):
    if len(args)!=2 or not isinstance(args[0], List): return NULL
    return List(args[0].elements + [args[1]])
builtins = {"len":Builtin(builtin_len), "first":Builtin(builtin_first), "last":Builtin(builtin_last), "rest":Builtin(builtin_rest), "push":Builtin(builtin_push)}

def eval_node(node, env):
    node_type = type(node)
    if node_type == Program: return eval_program(node.statements, env)
    elif node_type == ExpressionStatement: return eval_node(node.expression, env)
    elif node_type == BlockStatement: return eval_block_statement(node, env)
    elif node_type == ReturnStatement: return ReturnValue(eval_node(node.return_value, env))
    elif node_type == LetStatement: env.set(node.name.value, eval_node(node.value, env)); return NULL
    elif node_type == PrintStatement: val = eval_node(node.value, env); print(val.inspect() if val else 'null'); return NULL
    elif node_type == ForEachStatement: return eval_for_each_statement(node, env)
    elif node_type == ScreenStatement:
        renderer = Renderer()
        renderer.render(node)
        return NULL
    elif node_type == IntegerLiteral: return Integer(node.value)
    elif node_type == StringLiteral: return String(node.value)
    elif node_type == Boolean: return TRUE if node.value else FALSE
    elif node_type == ListLiteral: return List(eval_expressions(node.elements, env))
    elif node_type == Identifier: return eval_identifier(node, env)
    elif node_type == ActionLiteral: return Action(node.parameters, node.body, env)
    elif node_type == CallExpression: function=eval_node(node.function, env); args=eval_expressions(node.arguments, env); return apply_function(function, args)
    elif node_type == PrefixExpression: right=eval_node(node.right, env); return eval_prefix_expression(node.operator, right)
    elif node_type == InfixExpression: left, right = eval_node(node.left, env), eval_node(node.right, env); return eval_infix_expression(node.operator, left, right)
    elif node_type == IfExpression: return eval_if_expression(node, env)
    return NULL
def eval_program(stmts, env):
    result = NULL
    for statement in stmts:
        result = eval_node(statement, env)
        if isinstance(result, ReturnValue): return result.value
    return result
def eval_block_statement(block, env):
    result = NULL
    for statement in block.statements:
        result = eval_node(statement, env)
        if result and result.type() == "RETURN_VALUE": return result
    return result
def apply_function(fn, args):
    if isinstance(fn, Action):
        extended_env = Environment(outer=fn.env)
        for i, param in enumerate(fn.parameters): extended_env.set(param.value, args[i])
        evaluated = eval_node(fn.body, extended_env)
        if isinstance(evaluated, ReturnValue): return evaluated.value
        return evaluated
    elif isinstance(fn, Builtin): return fn.fn(*args)
    return NULL
def eval_identifier(node, env):
    val = env.get(node.value)
    if val: return val
    builtin = builtins.get(node.value)
    if builtin: return builtin
    return NULL
def eval_expressions(exps, env):
    result = []
    for e in exps: result.append(eval_node(e, env))
    return result
def eval_prefix_expression(operator, right):
    if operator == "!": return native_bool_to_boolean_object(not is_truthy(right))
    if operator == "-": return Integer(-right.value) if right.type() == "INTEGER" else NULL
    return NULL
def eval_infix_expression(operator, left, right):
    if left.type() == "INTEGER" and right.type() == "INTEGER": return eval_integer_infix_expression(operator, left, right)
    elif left.type() == "STRING" and right.type() == "STRING" and operator == "+": return String(left.value + right.value)
    elif operator == "==": return native_bool_to_boolean_object(left.value == right.value)
    elif operator == "!=": return native_bool_to_boolean_object(left.value != right.value)
    return NULL
def eval_if_expression(if_node, env):
    condition = eval_node(if_node.condition, env)
    if is_truthy(condition): return eval_node(if_node.consequence, env)
    elif if_node.alternative: return eval_node(if_node.alternative, env)
    else: return NULL
def is_truthy(obj): return obj not in [NULL, FALSE]
def eval_integer_infix_expression(operator, left, right):
    l, r = left.value, right.value
    ops = {'+': l + r, '-': l - r, '*': l * r, '/': l // r}
    if operator in ops: return Integer(ops[operator])
    bool_ops = {'<': l < r, '>': l > r, '==': l == r, '!=': l != r}
    if operator in bool_ops: return native_bool_to_boolean_object(bool_ops[operator])
    return NULL

# --- CONTENTS OF main.py ---
def run_file(filepath):
    try:
        with open(filepath, 'r') as f: code = f.read()
        env = Environment()
        l = Lexer(code)
        p = Parser(l)
        program = p.parse_program()
        if p.errors:
            for err in p.errors: print(f"PARSER ERROR: {err}")
            return
        eval_node(program, env)
    except FileNotFoundError: print(f"Error: File not found at '{filepath}'")

if __name__ == "__main__":
    if len(sys.argv) > 1: run_file(sys.argv[1])
    else:
        print("Zexus v1.1 Interactive REPL")
        env = Environment()
        while True:
            try:
                line = input(">> ")
                if not line: continue
                l = Lexer(line)
                p = Parser(l)
                program = p.parse_program()
                if p.errors:
                    for err in p.errors: print(f"PARSER ERROR: {err}")
                    continue
                evaluated = eval_node(program, env)
                if evaluated and evaluated.inspect() != "null":
                    print(evaluated.inspect())
            except (EOFError, KeyboardInterrupt): break
