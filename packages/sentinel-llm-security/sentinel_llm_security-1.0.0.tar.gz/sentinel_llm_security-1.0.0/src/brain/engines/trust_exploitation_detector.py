"""
Human-Agent Trust Exploitation Detector - ASI09 Protection

OWASP Agentic Top 10 2026 ASI09: Human-Agent Trust Exploitation

Detects social engineering attacks where agents:
- Impersonate trusted authorities
- Create false urgency
- Exploit emotional vulnerabilities
- Manipulate through familiarity
- Abuse delegated trust

Author: SENTINEL Team
Date: 2025-12-26
"""

import logging
import re
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional
from enum import Enum

logger = logging.getLogger("TrustExploitation")


# ============================================================================
# Enums and Data Classes
# ============================================================================


class TrustExploitationType(str, Enum):
    """Types of trust exploitation attacks."""
    AUTHORITY_IMPERSONATION = "authority_impersonation"
    FALSE_URGENCY = "false_urgency"
    EMOTIONAL_MANIPULATION = "emotional_manipulation"
    FAMILIARITY_ABUSE = "familiarity_abuse"
    DELEGATED_TRUST_ABUSE = "delegated_trust_abuse"
    FAKE_SYSTEM_MESSAGE = "fake_system_message"
    SOCIAL_PROOF_FABRICATION = "social_proof_fabrication"


@dataclass
class TrustExploitationResult:
    """Result from trust exploitation analysis."""
    is_safe: bool
    risk_score: float
    exploitations: List[TrustExploitationType]
    evidence: List[str]
    blocked: bool = False

    def to_dict(self) -> dict:
        return {
            "is_safe": self.is_safe,
            "risk_score": self.risk_score,
            "exploitations": [e.value for e in self.exploitations],
            "evidence": self.evidence,
            "blocked": self.blocked
        }


# ============================================================================
# Pattern Databases
# ============================================================================


# Authority impersonation patterns
AUTHORITY_PATTERNS = [
    # IT/Security impersonation
    r"(i am|this is|speaking as)\s+(your\s+)?(IT|security|admin|system)\s*(team|department|support)?",
    r"(from|on behalf of)\s+(the\s+)?(IT|security|compliance|legal)\s*(team|department)?",
    r"(security|IT)\s+(requires|needs|demands)\s+(you to|that you)",

    # Executive impersonation
    r"(this is|i am)\s+(the\s+)?(CEO|CFO|CTO|director|manager|boss)",
    r"(as|speaking as)\s+(your\s+)?(supervisor|manager|executive)",
    r"on\s+behalf\s+of\s+(the\s+)?exec(utive)?\s+(team|leadership)",

    # System message forgery
    r"\[SYSTEM\s*(MESSAGE|ALERT|WARNING)\]",
    r"\[OFFICIAL\s*(NOTICE|COMMUNICATION)\]",
    r"\[AUTOMATED\s*(MESSAGE|NOTIFICATION)\]",
    r"---\s*SYSTEM\s*(OVERRIDE|NOTICE)\s*---",
]

# Urgency manipulation patterns
URGENCY_PATTERNS = [
    # Time pressure
    r"(immediately|right\s+now|urgent(ly)?|asap|this\s+instant)",
    r"(within|in\s+the\s+next)\s+\d+\s+(minute|hour|second)s?",
    r"(before|by)\s+(midnight|end\s+of\s+(day|hour))",
    r"(deadline|time\s+limit|expir(es?|ation|ing))\s*(is\s+)?(soon|imminent|now)",

    # Threat of consequences
    r"(or\s+else|otherwise|if\s+not).*?(lose|suspended|terminated|deleted|locked)",
    r"(account|access|service)\s+will\s+be\s+(suspended|terminated|deleted|revoked)",
    r"(failure|refusal)\s+to\s+comply\s+will\s+(result|lead)",
    r"(last|final)\s+(chance|warning|notice)",
]

# Emotional manipulation patterns
EMOTIONAL_PATTERNS = [
    # Fear/threat
    r"(you\s+will|you'll)\s+(lose|be\s+fired|face\s+consequences)",
    r"(threat|danger|risk)\s+to\s+(your|company|organization)",
    r"(breach|hack|attack|compromise)\s+(detected|identified|discovered)",

    # Flattery/reciprocity
    r"(you're|you\s+are)\s+(the\s+only\s+one|specially\s+selected|trusted)",
    r"(i\s+trust|we\s+trust)\s+only\s+you",
    r"(as\s+a\s+favor|please\s+help\s+me|i\s+need\s+your\s+help)",

    # Guilt/obligation
    r"(disappoint(ed)?|let\s+(me|us|the\s+team)\s+down)",
    r"(everyone\s+else|others)\s+(has|have)\s+already",
    r"(i\s+thought|we\s+expected)\s+you\s+(would|could)",
]

# Familiarity exploitation patterns
FAMILIARITY_PATTERNS = [
    # Casual/friendly tone manipulation
    r"(hey|hi)\s+(friend|buddy|pal|mate)",
    r"(remember\s+me|we\s+spoke\s+(before|earlier|last\s+time))",
    r"(as\s+we\s+discussed|following\s+up\s+on\s+our\s+conversation)",

    # False prior relationship
    r"(we\s+met|you\s+helped\s+me)\s+(at|during|last)",
    r"(your\s+colleague|our\s+mutual\s+friend)\s+(suggested|recommended)",
    r"(john|jane|mike|sarah|the\s+boss)\s+(said|told\s+me|suggested)",
]

# Delegated trust abuse patterns
DELEGATED_PATTERNS = [
    # Acting on behalf of
    r"(on\s+behalf\s+of|representing|acting\s+for)\s+\w+",
    r"(delegated|authorized)\s+(by|from)\s+\w+",
    r"\w+\s+(sent|asked)\s+me\s+to\s+(tell|ask|inform)\s+you",

    # Permission claims
    r"(i\s+have|we\s+have)\s+(permission|authorization|approval)",
    r"(approved|signed\s+off)\s+by\s+(management|leadership|the\s+director)",
    r"(pre-?approved|already\s+verified|cleared)\s+(by|with)",
]


# ============================================================================
# Trust Exploitation Detector
# ============================================================================


class TrustExploitationDetector:
    """
    Detects human-agent trust exploitation (ASI09).

    Protects against social engineering where AI agents are used to:
    - Impersonate trusted entities
    - Create artificial urgency
    - Manipulate through emotion
    - Exploit existing relationships
    """

    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}

        # Compile all patterns
        self.authority_patterns = [
            re.compile(p, re.IGNORECASE) for p in AUTHORITY_PATTERNS
        ]
        self.urgency_patterns = [
            re.compile(p, re.IGNORECASE) for p in URGENCY_PATTERNS
        ]
        self.emotional_patterns = [
            re.compile(p, re.IGNORECASE) for p in EMOTIONAL_PATTERNS
        ]
        self.familiarity_patterns = [
            re.compile(p, re.IGNORECASE) for p in FAMILIARITY_PATTERNS
        ]
        self.delegated_patterns = [
            re.compile(p, re.IGNORECASE) for p in DELEGATED_PATTERNS
        ]

        logger.info(
            "TrustExploitationDetector initialized: %d patterns total",
            len(AUTHORITY_PATTERNS) + len(URGENCY_PATTERNS) +
            len(EMOTIONAL_PATTERNS) + len(FAMILIARITY_PATTERNS) +
            len(DELEGATED_PATTERNS)
        )

    def analyze(self, content: str) -> TrustExploitationResult:
        """Analyze content for trust exploitation attempts."""
        exploitations = []
        evidence = []
        risk_score = 0.0

        # Check authority impersonation
        for pattern in self.authority_patterns:
            match = pattern.search(content)
            if match:
                exploitations.append(
                    TrustExploitationType.AUTHORITY_IMPERSONATION)
                evidence.append(f"Authority claim: '{match.group()}'")
                risk_score += 30.0
                break  # One per category

        # Check urgency manipulation
        for pattern in self.urgency_patterns:
            match = pattern.search(content)
            if match:
                exploitations.append(TrustExploitationType.FALSE_URGENCY)
                evidence.append(f"Urgency trigger: '{match.group()}'")
                risk_score += 25.0
                break

        # Check emotional manipulation
        for pattern in self.emotional_patterns:
            match = pattern.search(content)
            if match:
                exploitations.append(
                    TrustExploitationType.EMOTIONAL_MANIPULATION)
                evidence.append(f"Emotional trigger: '{match.group()}'")
                risk_score += 25.0
                break

        # Check familiarity abuse
        for pattern in self.familiarity_patterns:
            match = pattern.search(content)
            if match:
                exploitations.append(TrustExploitationType.FAMILIARITY_ABUSE)
                evidence.append(f"Familiarity claim: '{match.group()}'")
                risk_score += 20.0
                break

        # Check delegated trust abuse
        for pattern in self.delegated_patterns:
            match = pattern.search(content)
            if match:
                exploitations.append(
                    TrustExploitationType.DELEGATED_TRUST_ABUSE)
                evidence.append(f"Delegation claim: '{match.group()}'")
                risk_score += 25.0
                break

        # Compound scoring - multiple categories is worse
        if len(exploitations) >= 3:
            risk_score *= 1.5
        elif len(exploitations) >= 2:
            risk_score *= 1.2

        risk_score = min(100.0, risk_score)
        is_safe = len(exploitations) == 0
        blocked = risk_score >= 70.0

        if exploitations:
            logger.warning(
                "Trust exploitation detected: %s (score=%.1f)",
                [e.value for e in exploitations], risk_score
            )

        return TrustExploitationResult(
            is_safe=is_safe,
            risk_score=risk_score,
            exploitations=exploitations,
            evidence=evidence,
            blocked=blocked
        )


# ============================================================================
# Factory
# ============================================================================


_detector: Optional[TrustExploitationDetector] = None


def get_trust_exploitation_detector() -> TrustExploitationDetector:
    """Get singleton trust exploitation detector."""
    global _detector
    if _detector is None:
        _detector = TrustExploitationDetector()
    return _detector
