# SPDX-License-Identifier: MIT
# Copyright © 2025 Bijan Mousavi

"""Builds the documentation page for Software Bill of Materials (SBOM) artifacts.

This module defines `SBOMArtifactPage`, which implements the
`StandardArtifactPage` base class to find, parse, and display CycloneDX JSON
SBOMs and related files.

Module Constants:
    SBOM_DIR: The directory where SBOM artifacts are stored.
"""

from __future__ import annotations

import json
from pathlib import Path
from typing import Iterable

from scripts.docs_builder.artifacts_pages.base import StandardArtifactPage
from scripts.docs_builder.artifacts_pages.base import Bullet
from scripts.docs_builder.helpers import anchor_for
from scripts.docs_builder.helpers import indent

SBOM_DIR = Path("artifacts/sbom")


def _env_from_name(name: str) -> str | None:
    """Infers the environment from an SBOM filename.

    Args:
        name: The filename to inspect.

    Returns:
        'development', 'production', or None if no environment can be inferred.
    """
    n = name.lower()
    if ".dev." in n or n.endswith(".dev.json") or n.endswith(".dev.cdx.json"):
        return "development"
    if ".prod." in n or n.endswith(".prod.json") or n.endswith(".prod.cdx.json"):
        return "production"
    return None


def _is_cdx_json(p: Path) -> bool:
    """Checks if a file is a CycloneDX JSON file based on its name.

    Args:
        p: The path to the file.

    Returns:
        True if the filename matches common CycloneDX JSON patterns,
        False otherwise.
    """
    n = p.name.lower()
    return n.endswith(".cdx.json") or n.endswith(".cyclonedx.json") or ("cyclonedx" in n and n.endswith(".json"))


def _parse_cyclonedx(fp: Path) -> dict:
    """Parses a CycloneDX JSON file to extract shallow metadata.

    This function is used to gather key information for display on the
    documentation page without needing a full CycloneDX library.

    Args:
        fp: The path to the CycloneDX JSON file.

    Returns:
        A dictionary containing metadata such as 'bomFormat', 'specVersion',
        'components_count', 'app_name', etc. Returns an empty dictionary if
        the file cannot be read or parsed.
    """
    try:
        data = json.loads(fp.read_text(encoding="utf-8"))
    except (OSError, json.JSONDecodeError):
        return {}
    comps = data.get("components")
    meta = data.get("metadata") or {}
    comp = meta.get("component") or {}
    return {
        "bomFormat": data.get("bomFormat"),
        "specVersion": data.get("specVersion"),
        "serialNumber": data.get("serialNumber"),
        "components_count": len(comps) if isinstance(comps, list) else None,
        "app_name": comp.get("name"),
        "app_version": comp.get("version"),
        "timestamp": meta.get("timestamp"),
    }


class SBOMArtifactPage(StandardArtifactPage):
    """Generates the documentation page for CycloneDX SBOM artifacts."""

    out_md = Path("artifacts/sbom.md")

    def title(self) -> str:
        """Returns the main title for the SBOM artifacts page."""
        return "SBOM Artifacts"

    def intro(self) -> str:
        """Returns the introductory text for the SBOM artifacts page."""
        return (
            "CycloneDX **Software Bill of Materials** (SBOM) generated by `make sbom`.\n\n"
            "- **Prod SBOM** from `requirements/prod.txt`; **Dev SBOM** from `requirements/dev.txt` "
            "(both via `pip-audit --format cyclonedx-json`).\n"
            "- Optional **validation** via `make sbom-validate` (CycloneDX CLI), and a brief **summary** via "
            "`make sbom-summary`.\n"
            "\n"
            "Key variables: `PACKAGE_NAME`, `SBOM_DIR`, `SBOM_IGNORE_IDS`, and `SBOM_CLI`.\n"
        )

    def iter_items(self) -> Iterable[tuple[str, Path]]:
        """Yields the SBOM artifacts to be documented, in a prioritized order.

        The sorting logic ensures a consistent layout:
        1. Production SBOMs
        2. Development SBOMs
        3. Other CycloneDX SBOMs (sorted by name)
        4. The summary.txt file

        Yields:
            An iterable of (label, path) tuples for each artifact.
        """
        if not SBOM_DIR.is_dir():
            return []
        files = [p for p in SBOM_DIR.iterdir() if p.is_file()]
        cdx = [p for p in files if _is_cdx_json(p)]
        other = [p for p in files if p.name == "summary.txt"]

        def _rank(p: Path) -> tuple[int, str]:
            """Assigns a sort rank to a path."""
            env = _env_from_name(p.name) or ""
            if env == "production":
                return 0, p.name
            if env == "development":
                return 1, p.name
            return 2, p.name

        cdx_sorted = sorted(cdx, key=_rank)
        other_sorted = sorted(other, key=lambda p: p.name)
        return [(p.name, p) for p in cdx_sorted + other_sorted]

    def bullet_for(self, label: str, path: Path, content: str) -> Bullet:
        """Builds a detailed summary bullet for a specific SBOM artifact.

        This method has specific logic for CycloneDX JSON files, `summary.txt`,
        and a generic fallback for any other files found. For CycloneDX files,
        it parses the content to create a rich, dynamic summary.

        Args:
            label: The filename of the artifact.
            path: The path to the artifact file.
            content: The raw string content of the artifact file.

        Returns:
            A `Bullet` object populated with a title, summary, and usage guidance.
        """
        if _is_cdx_json(path):
            md = _parse_cyclonedx(path)
            parts = ["CycloneDX JSON"]
            env = _env_from_name(label)
            if env:
                parts.append(env)
            if md.get("app_name"):
                app = md["app_name"] + (f" {md['app_version']}" if md.get("app_version") else "")
                parts.append(app)
            if md.get("components_count") is not None:
                parts.append(f"{md['components_count']} components")
            if md.get("specVersion"):
                parts.append(f"spec {md['specVersion']}")
            title = f"[{label}](#{anchor_for(label)}) — " + " • ".join(parts)

            good_template = "Valid CycloneDX; includes app metadata; reasonable component count."
            extra = []
            if md.get("components_count") is not None:
                extra.append(f"components={md['components_count']}")
            if md.get("specVersion"):
                extra.append(f"spec={md['specVersion']}")
            good_line = good_template + ((" — " + ", ".join(extra)) if extra else "")

            usage = (
                f"Validate with `make sbom-validate`; scan with `grype sbom:cyclonedx:{label}` or "
                f"`osv-scanner --sbom {label}`; diff prod↔dev to spot drift."
            )
            return Bullet(title=title, good=good_line, usage=usage)

        if label == "summary.txt":
            title = f"[{label}](#{anchor_for(label)}) — SBOM components summary"
            good_line = "Up-to-date snapshot lines for each SBOM file present."
            usage = "Open at a glance; keep in CI logs; regenerate with `make sbom-summary`."
            return Bullet(title=title, good=good_line, usage=usage)

        title = f"[{label}](#{anchor_for(label)}) — {path.stat().st_size} bytes"
        return Bullet(title=title, good="Parsable artifact present.", usage="Inspect contents below.")

    def detail_for(self, label: str, path: Path, content: str) -> str:
        """Creates the detailed description for a given SBOM artifact.

        For CycloneDX files, this method generates a rich 'info' block by
        parsing the file's metadata. It includes key details like the component
        count and spec version, as well as a list of practical commands for
        validating and scanning the SBOM with common tools. For other files
        like 'summary.txt', it provides a simpler, static description.

        Args:
            label: The filename of the artifact.
            path: The path to the artifact file.
            content: The raw string content of the artifact file.

        Returns:
            A formatted Markdown string for the artifact's detail section.
        """
        if _is_cdx_json(path):
            md = _parse_cyclonedx(path)
            env = _env_from_name(label)
            lines = []
            if env:
                lines.append(f"**Type:** {env.capitalize()} CycloneDX SBOM")
            if md.get("app_name"):
                app = md["app_name"] + (f" {md['app_version']}" if md.get("app_version") else "")
                lines.append(f"**Application:** {app}")
            if md.get("components_count") is not None:
                lines.append(f"**Components:** {md['components_count']}")
            if md.get("specVersion"):
                lines.append(f"**CycloneDX spec:** {md['specVersion']}")
            if md.get("serialNumber"):
                lines.append(f"**Serial:** `{md['serialNumber']}`")
            if md.get("timestamp"):
                lines.append(f"**Generated:** {md['timestamp']}")
            uses = [
                "**Validate:** `make sbom-validate` (requires `SBOM_CLI={cyclonedx}` in PATH).",
                f"**Vuln scan (grype):** `grype sbom:cyclonedx:{label}`.",
                f"**Vuln scan (OSV):** `osv-scanner --sbom {label}`.",
                "**License review:** inspect `components[].licenses` or import into your compliance tool.",
                "**Diff SBOMs:** compare dev vs prod JSON to catch environment drift.",
            ]
            return '!!! info "About this SBOM & how to use it"\n\n' + indent(
                "\n".join(lines) + "\n\n- " + "\n- ".join(uses) + "\n"
            )

        if label == "summary.txt":
            return '!!! info "About this artifact"\n\n' + indent(
                "A short components count per SBOM file, created by `make sbom-summary`.\n"
            )

        return '!!! info "About this artifact"\n\n' + indent("Additional SBOM-related file.\n")
