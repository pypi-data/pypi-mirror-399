name: Publish to PyPI

on:
  push:
    tags: ["v*"]
  workflow_dispatch:

permissions:
  contents: read
  actions: read

concurrency:
  group: publish-${{ github.sha }}
  cancel-in-progress: true

jobs:
  publish:
    # Only run on tag push or manual dispatch
    if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest

    outputs:
      publish:    ${{ steps.decide.outputs.publish }}
      tag:        ${{ steps.decide.outputs.tag }}
      version:    ${{ steps.decide.outputs.version }}
      ci_run_id:  ${{ steps.ci.outputs.run_id }}
      pypi_ready: ${{ steps.pypi_ready.outputs.ok }}

    steps:
      - name: Determine target SHA
        id: sha
        run: echo "value=${{ github.sha }}" >> "$GITHUB_OUTPUT"

      - name: Checkout (tags + history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ steps.sha.outputs.value }}

      - name: Ensure tags present
        run: git fetch --tags --force --prune

      - name: Decide publish (SemVer tag on this SHA?)
        id: decide
        shell: bash
        run: |
          set -euo pipefail
          SHA="${{ steps.sha.outputs.value }}"
          TAGS=$(git tag --points-at "$SHA" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
          if [ -z "$TAGS" ] && [ "${{ github.event_name }}" = "push" ]; then
            if [[ "${GITHUB_REF_NAME}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              TAGS="${GITHUB_REF_NAME}"
            fi
          fi
          if [ -z "$TAGS" ]; then
            echo "publish=false"  >> "$GITHUB_OUTPUT"
            exit 0
          fi
          TAG=$(echo "$TAGS" | head -n1)
          VERSION=${TAG#v}
          {
            echo "publish=true"
            echo "tag=$TAG"
            echo "version=$VERSION"
          } >> "$GITHUB_OUTPUT"

      - name: Wait for CI success & capture run id
        if: steps.decide.outputs.publish == 'true'
        id: ci
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            const timeoutMs = 20 * 60 * 1000, pollMs = 15000;
            const deadline = Date.now() + timeoutMs;

            async function latestCI() {
              const res = await github.rest.actions.listWorkflowRunsForRepo({
                owner, repo, head_sha: sha, per_page: 100
              });
              return (res.data.workflow_runs || [])
                .filter(r => r.name === 'CI')
                .sort((a,b) => new Date(b.run_started_at) - new Date(a.run_started_at))[0];
            }

            while (true) {
              const run = await latestCI();
              if (run && run.status === 'completed') {
                if (run.conclusion === 'success') {
                  core.setOutput('run_id', String(run.id));
                  return;
                }
                core.setFailed(`CI concluded: ${run.conclusion}`);
                return;
              }
              if (Date.now() > deadline) { core.setFailed('CI wait timeout'); return; }
              await new Promise(r => setTimeout(r, pollMs));
            }

      - name: Check if version already on PyPI
        if: steps.decide.outputs.publish == 'true'
        id: precheck_pypi
        shell: bash
        run: |
          VERSION="${{ steps.decide.outputs.version }}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/bijux-rar/$VERSION/json" || true)
          if [ "$STATUS" = "200" ]; then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Preflight â€” ensure PyPI token is set
        if: steps.decide.outputs.publish == 'true'
        shell: bash
        run: |
          if [ -z "${{ secrets.PYPI_API_TOKEN }}" ]; then
            echo "::error::Missing PYPI_API_TOKEN secret"
            exit 1
          fi

      - name: Download dist from CI artifacts
        if: steps.decide.outputs.publish == 'true' && steps.precheck_pypi.outputs.exists == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts/build
          gh run download "${{ steps.ci.outputs.run_id }}" -n dist -D artifacts/build || true
          ls -la artifacts/build || true

      - name: Set up Python (fallback build)
        if: steps.decide.outputs.publish == 'true' && steps.precheck_pypi.outputs.exists == 'false'
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Fallback build (only if dist missing)
        if: steps.decide.outputs.publish == 'true' && steps.precheck_pypi.outputs.exists == 'false' && hashFiles('artifacts/build/**') == ''
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install -U pip build
          python -m build --outdir artifacts/build
          # Fail if still no dist
          if [ ! -d artifacts/build ] || ! compgen -G "artifacts/build/*" >/dev/null; then
            echo "::error::No dist artifacts available after fallback build"
            exit 1
          fi

      - name: Publish to PyPI
        if: steps.decide.outputs.publish == 'true' && steps.precheck_pypi.outputs.exists == 'false'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          packages-dir: artifacts/build
          skip-existing: true
          verbose: true

      - name: Verify version is visible on PyPI
        if: steps.decide.outputs.publish == 'true'
        id: pypi_ready
        shell: bash
        run: |
          set -euo pipefail
          V="${{ steps.decide.outputs.version }}"
          # If it already existed, we're good.
          if [ "${{ steps.precheck_pypi.outputs.exists }}" = "true" ]; then
            echo "ok=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # Otherwise, poll for a short time after upload.
          for i in {1..12}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/bijux-rar/$V/json" || true)
            if [ "$code" = "200" ]; then
              echo "ok=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            sleep 5
          done
          echo "ok=false" >> "$GITHUB_OUTPUT"
          echo "::warning::Version $V not visible on PyPI yet"

  create-release:
    name: Create GitHub Release
    needs: publish
    if: needs.publish.outputs.publish == 'true' && needs.publish.outputs.pypi_ready == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download all CI artifacts
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p artifacts
          gh run download "${{ needs.publish.outputs.ci_run_id }}" \
            --repo "${{ github.repository }}" \
            -D artifacts
          echo "--- Downloaded artifacts layout ---"
          find artifacts -maxdepth 2 -type d -print | sort || true
          echo "-----------------------------------"

      - name: Package curated bundles (zip)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p _release
  
          # Tests: create test-<env>.zip for each env (e.g., artifacts/test-py311)
          for d in artifacts/test-*; do
            [ -d "$d" ] || continue
            env="${d##*/test-}"
            zip -r -q "_release/test-${env}.zip" "$d"
          done
  
          # Single-dir bundles
          for name in lint quality security api docs sbom citation; do
            if [ -d "artifacts/${name}" ]; then
              zip -r -q "_release/${name}.zip" "artifacts/${name}"
            fi
          done
  
          # Build bundle from dist (keep raw dist files as well)
          if [ -d "artifacts/dist" ] && compgen -G "artifacts/dist/*" >/dev/null; then
            zip -r -q "_release/build.zip" "artifacts/dist"
          fi
  
          # Checksums (avoid path issues by referencing full globs)
          chks="_release/checksums-${{ needs.publish.outputs.tag }}.txt"
          : > "$chks"
          if compgen -G "_release/*.zip" >/dev/null; then
            sha256sum _release/*.zip >> "$chks"
          fi
          if compgen -G "artifacts/dist/*" >/dev/null; then
            sha256sum artifacts/dist/* >> "$chks"
          fi
  
          echo "Release payload:"
          ls -lh _release || true

      - name: Compute changelog anchor
        id: anchor
        shell: bash
        run: |
          ref="${{ needs.publish.outputs.version }}"
          echo "anchor=v${ref//./-}" >> "$GITHUB_OUTPUT"

      # Delete the existing release for this tag so assets are replaced cleanly
      - name: Delete existing release (if it exists)
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          gh release delete "${{ needs.publish.outputs.tag }}" --yes || true

      - name: Create release (curated assets only)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.publish.outputs.tag }}
          name:     ${{ needs.publish.outputs.tag }}
          body: |
            See the full changelog entry at https://bijux.github.io/bijux-cli/changelog/#${{ steps.anchor.outputs.anchor }}
          files: |
            _release/*.zip
            _release/checksums-${{ needs.publish.outputs.tag }}.txt
            artifacts/dist/*
          fail_on_unmatched_files: false
          make_latest: true
