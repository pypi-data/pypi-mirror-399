"""Claude.ai export functionality for marketplace assets.

This module provides functions to export marketplace assets for use in
Claude.ai Projects, Claude Artifacts, and other Claude interfaces.

Export formats:
- Project Instructions: Markdown formatted for Claude.ai Project Instructions
- Artifacts: Formatted as Claude Artifacts for sharing
- Style Instructions: Response style rules for Claude.ai
- Prompt Templates: Reusable prompt templates

Usage:
    from repotoire.marketplace import (
        export_as_project_instructions,
        export_as_artifact,
        export_style_instructions,
    )

    # Export a skill as project instructions
    instructions = export_as_project_instructions([asset], format="markdown")

    # Export a style as instructions
    style_doc = export_style_instructions(style_asset)

    # Export as a Claude Artifact
    artifact = export_as_artifact(asset)
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from repotoire.logging_config import get_logger

logger = get_logger(__name__)


@dataclass
class ExportedAsset:
    """Information about an exported asset.

    Attributes:
        name: Asset name.
        slug: Asset slug.
        publisher: Publisher slug.
        version: Asset version.
        asset_type: Type of asset (command, skill, style, hook, prompt).
        description: Asset description.
        content: Asset content (varies by type).
    """

    name: str
    slug: str
    publisher: str
    version: str
    asset_type: str
    description: str
    content: dict[str, Any] | str


def export_as_project_instructions(
    assets: list[ExportedAsset],
    format: str = "markdown",
    include_header: bool = True,
) -> str:
    """Export assets as Claude.ai Project Instructions.

    This generates markdown-formatted instructions that can be copied
    into a Claude.ai Project's custom instructions.

    Args:
        assets: List of assets to export.
        format: Output format ("markdown" or "text").
        include_header: Whether to include a header with metadata.

    Returns:
        Formatted project instructions string.

    Example output:
        # Custom Project Instructions

        ## Response Style

        - Write concise, professional responses
        - Use code blocks for all code examples
        ...

        ## Available Skills

        ### Code Review Assistant
        When asked to review code, analyze for:
        ...
    """
    sections = []

    if include_header:
        sections.append(_generate_header(assets))

    # Group assets by type
    commands = [a for a in assets if a.asset_type == "command"]
    skills = [a for a in assets if a.asset_type == "skill"]
    styles = [a for a in assets if a.asset_type == "style"]
    prompts = [a for a in assets if a.asset_type == "prompt"]
    hooks = [a for a in assets if a.asset_type == "hook"]

    # Add style section
    if styles:
        sections.append(_export_styles_section(styles))

    # Add skills section
    if skills:
        sections.append(_export_skills_section(skills))

    # Add commands section
    if commands:
        sections.append(_export_commands_section(commands))

    # Add prompts section
    if prompts:
        sections.append(_export_prompts_section(prompts))

    # Add hooks notice (can't be used in Claude.ai)
    if hooks:
        sections.append(_export_hooks_notice(hooks))

    return "\n\n".join(sections)


def _generate_header(assets: list[ExportedAsset]) -> str:
    """Generate a header section with metadata."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

    asset_names = ", ".join(f"@{a.publisher}/{a.slug}" for a in assets[:3])
    if len(assets) > 3:
        asset_names += f", and {len(assets) - 3} more"

    return f"""# Custom Project Instructions

> Generated by Repotoire Marketplace on {timestamp}
> Assets: {asset_names}

These instructions configure Claude to use capabilities from installed marketplace assets.
"""


def _export_styles_section(styles: list[ExportedAsset]) -> str:
    """Export style assets as response style instructions."""
    lines = ["## Response Style"]
    lines.append("")
    lines.append("Apply the following response style rules:")
    lines.append("")

    for style in styles:
        lines.append(f"### {style.name}")
        lines.append(f"*Source: @{style.publisher}/{style.slug} v{style.version}*")
        lines.append("")

        content = style.content
        if isinstance(content, dict):
            # Extract style rules from content
            rules = content.get("rules", content.get("style", []))
            if isinstance(rules, list):
                for rule in rules:
                    lines.append(f"- {rule}")
            elif isinstance(rules, str):
                lines.append(rules)

            # Extract examples if present
            examples = content.get("examples", [])
            if examples:
                lines.append("")
                lines.append("**Examples:**")
                for example in examples[:3]:  # Limit to 3 examples
                    lines.append(f"- {example}")
        else:
            lines.append(str(content))

        lines.append("")

    return "\n".join(lines)


def _export_skills_section(skills: list[ExportedAsset]) -> str:
    """Export skill assets as available capabilities."""
    lines = ["## Available Skills"]
    lines.append("")
    lines.append("The following specialized skills are available:")
    lines.append("")

    for skill in skills:
        lines.append(f"### {skill.name}")
        lines.append(f"*Source: @{skill.publisher}/{skill.slug} v{skill.version}*")
        lines.append("")
        lines.append(skill.description)
        lines.append("")

        content = skill.content
        if isinstance(content, dict):
            # Extract capabilities
            capabilities = content.get("capabilities", content.get("tools", []))
            if capabilities:
                lines.append("**Capabilities:**")
                for cap in capabilities:
                    if isinstance(cap, dict):
                        cap_name = cap.get("name", "")
                        cap_desc = cap.get("description", "")
                        lines.append(f"- **{cap_name}**: {cap_desc}")
                    else:
                        lines.append(f"- {cap}")

            # Extract usage instructions
            usage = content.get("usage", content.get("instructions", ""))
            if usage:
                lines.append("")
                lines.append("**Usage:**")
                lines.append(usage)

        lines.append("")

    return "\n".join(lines)


def _export_commands_section(commands: list[ExportedAsset]) -> str:
    """Export command assets as available templates."""
    lines = ["## Available Commands"]
    lines.append("")
    lines.append("The following command templates are available. Use them by mentioning the command name:")
    lines.append("")

    for cmd in commands:
        lines.append(f"### /{cmd.slug}")
        lines.append(f"**{cmd.name}** - {cmd.description}")
        lines.append(f"*Source: @{cmd.publisher}/{cmd.slug} v{cmd.version}*")
        lines.append("")

        content = cmd.content
        if isinstance(content, dict):
            prompt = content.get("prompt", "")
            if prompt:
                # Show truncated prompt
                if len(prompt) > 500:
                    prompt = prompt[:500] + "..."
                lines.append("```")
                lines.append(prompt)
                lines.append("```")
        elif isinstance(content, str):
            if len(content) > 500:
                content = content[:500] + "..."
            lines.append("```")
            lines.append(content)
            lines.append("```")

        lines.append("")

    return "\n".join(lines)


def _export_prompts_section(prompts: list[ExportedAsset]) -> str:
    """Export prompt assets as reusable templates."""
    lines = ["## Prompt Templates"]
    lines.append("")
    lines.append("The following prompt templates are available:")
    lines.append("")

    for prompt in prompts:
        lines.append(f"### {prompt.name}")
        lines.append(f"*Source: @{prompt.publisher}/{prompt.slug} v{prompt.version}*")
        lines.append("")

        content = prompt.content
        if isinstance(content, dict):
            template = content.get("template", content.get("prompt", ""))
            variables = content.get("variables", [])

            if variables:
                lines.append("**Variables:**")
                for var in variables:
                    if isinstance(var, dict):
                        var_name = var.get("name", "")
                        var_desc = var.get("description", "")
                        lines.append(f"- `{var_name}`: {var_desc}")
                    else:
                        lines.append(f"- `{var}`")
                lines.append("")

            if template:
                lines.append("**Template:**")
                lines.append("```")
                lines.append(template)
                lines.append("```")
        elif isinstance(content, str):
            lines.append("**Template:**")
            lines.append("```")
            lines.append(content)
            lines.append("```")

        lines.append("")

    return "\n".join(lines)


def _export_hooks_notice(hooks: list[ExportedAsset]) -> str:
    """Generate a notice about hooks not being available in Claude.ai."""
    hook_names = ", ".join(f"@{h.publisher}/{h.slug}" for h in hooks)
    return f"""---

> **Note:** The following hooks are installed but cannot be used in Claude.ai Projects:
> {hook_names}
>
> Hooks require Claude Code or Claude Desktop to execute."""


def export_as_artifact(
    asset: ExportedAsset,
    artifact_type: str | None = None,
) -> dict[str, Any]:
    """Export an asset as a Claude Artifact.

    Artifacts are structured content that can be shared and rendered
    in Claude's UI.

    Args:
        asset: Asset to export.
        artifact_type: Override the artifact type (default: auto-detect).

    Returns:
        Dictionary formatted as a Claude Artifact.
    """
    # Determine artifact type
    if artifact_type is None:
        type_mapping = {
            "command": "text/markdown",
            "skill": "application/json",
            "style": "application/json",
            "prompt": "text/markdown",
            "hook": "application/json",
        }
        artifact_type = type_mapping.get(asset.asset_type, "text/plain")

    # Build artifact content
    if artifact_type == "application/json":
        if isinstance(asset.content, dict):
            content = json.dumps(asset.content, indent=2)
        else:
            content = json.dumps({"content": asset.content}, indent=2)
    elif artifact_type == "text/markdown":
        content = _asset_to_markdown(asset)
    else:
        content = str(asset.content)

    return {
        "type": "artifact",
        "title": asset.name,
        "language": artifact_type,
        "content": content,
        "metadata": {
            "source": f"@{asset.publisher}/{asset.slug}",
            "version": asset.version,
            "asset_type": asset.asset_type,
            "generated_at": datetime.now().isoformat(),
            "generator": "repotoire-marketplace",
        },
    }


def _asset_to_markdown(asset: ExportedAsset) -> str:
    """Convert an asset to markdown format."""
    lines = [
        f"# {asset.name}",
        "",
        f"> @{asset.publisher}/{asset.slug} v{asset.version}",
        "",
        asset.description,
        "",
    ]

    content = asset.content
    if isinstance(content, dict):
        # Handle command/prompt content
        prompt = content.get("prompt", content.get("template", ""))
        if prompt:
            lines.append("## Content")
            lines.append("")
            lines.append("```")
            lines.append(prompt)
            lines.append("```")

        # Handle variables
        variables = content.get("variables", [])
        if variables:
            lines.append("")
            lines.append("## Variables")
            lines.append("")
            for var in variables:
                if isinstance(var, dict):
                    lines.append(f"- **{var.get('name', '')}**: {var.get('description', '')}")
                else:
                    lines.append(f"- `{var}`")

    elif isinstance(content, str):
        lines.append("## Content")
        lines.append("")
        lines.append("```")
        lines.append(content)
        lines.append("```")

    return "\n".join(lines)


def export_style_instructions(
    asset: ExportedAsset,
) -> str:
    """Export a style asset as response style instructions.

    This generates a concise set of rules that can be added to
    Claude.ai's custom instructions.

    Args:
        asset: Style asset to export.

    Returns:
        Formatted style instructions string.
    """
    if asset.asset_type != "style":
        raise ValueError(f"Expected style asset, got {asset.asset_type}")

    lines = [
        f"# Response Style: {asset.name}",
        "",
        asset.description,
        "",
        "## Rules",
        "",
    ]

    content = asset.content
    if isinstance(content, dict):
        rules = content.get("rules", content.get("style", []))
        if isinstance(rules, list):
            for i, rule in enumerate(rules, 1):
                lines.append(f"{i}. {rule}")
        elif isinstance(rules, str):
            lines.append(rules)

        # Add tone if present
        tone = content.get("tone", "")
        if tone:
            lines.append("")
            lines.append(f"**Tone:** {tone}")

        # Add examples
        examples = content.get("examples", [])
        if examples:
            lines.append("")
            lines.append("## Examples")
            lines.append("")
            for example in examples:
                if isinstance(example, dict):
                    lines.append(f"**{example.get('type', 'Example')}:**")
                    lines.append(f"> {example.get('content', '')}")
                else:
                    lines.append(f"> {example}")
                lines.append("")

    elif isinstance(content, str):
        lines.append(content)

    return "\n".join(lines)


def export_prompt_template(
    asset: ExportedAsset,
    variables: dict[str, str] | None = None,
) -> str:
    """Export a prompt asset with optional variable substitution.

    Args:
        asset: Prompt asset to export.
        variables: Dictionary of variable values to substitute.

    Returns:
        Formatted prompt string.
    """
    if asset.asset_type not in ("prompt", "command"):
        raise ValueError(f"Expected prompt or command asset, got {asset.asset_type}")

    content = asset.content
    if isinstance(content, dict):
        template = content.get("template", content.get("prompt", ""))
    else:
        template = str(content)

    # Substitute variables if provided
    if variables:
        for key, value in variables.items():
            # Support both {{key}} and {key} formats
            template = template.replace(f"{{{{{key}}}}}", value)
            template = template.replace(f"{{{key}}}", value)

    return template


def generate_clipboard_text(
    assets: list[ExportedAsset],
    format: str = "project",
) -> str:
    """Generate text optimized for copying to clipboard.

    Args:
        assets: Assets to export.
        format: Export format ("project", "artifact", "snippet").

    Returns:
        Formatted text for clipboard.
    """
    if format == "project":
        return export_as_project_instructions(assets)
    elif format == "artifact":
        # Export first asset as artifact
        if assets:
            artifact = export_as_artifact(assets[0])
            return artifact["content"]
        return ""
    elif format == "snippet":
        # Generate a compact snippet
        lines = []
        for asset in assets:
            content = asset.content
            if isinstance(content, dict):
                snippet = content.get("prompt", content.get("template", str(content)))
            else:
                snippet = str(content)

            # Truncate long snippets
            if len(snippet) > 1000:
                snippet = snippet[:1000] + "..."

            lines.append(f"# {asset.name}")
            lines.append(snippet)
            lines.append("")

        return "\n".join(lines)
    else:
        return export_as_project_instructions(assets)


def load_asset_from_file(path: Path) -> ExportedAsset | None:
    """Load an asset from a local file.

    Args:
        path: Path to asset file or directory.

    Returns:
        Loaded asset or None if invalid.
    """
    try:
        if path.is_file():
            # Single file (command or prompt)
            if path.suffix == ".md":
                content = path.read_text()
                return ExportedAsset(
                    name=path.stem,
                    slug=path.stem,
                    publisher="local",
                    version="local",
                    asset_type="command" if "commands" in str(path) else "prompt",
                    description=f"Local asset from {path.name}",
                    content=content,
                )
            elif path.suffix == ".json":
                with open(path, "r") as f:
                    content = json.load(f)

                asset_type = content.get("type", "prompt")
                return ExportedAsset(
                    name=content.get("name", path.stem),
                    slug=path.stem,
                    publisher="local",
                    version=content.get("version", "local"),
                    asset_type=asset_type,
                    description=content.get("description", ""),
                    content=content,
                )

        elif path.is_dir():
            # Directory with manifest
            manifest_path = path / "manifest.json"
            if manifest_path.exists():
                with open(manifest_path, "r") as f:
                    manifest = json.load(f)

                return ExportedAsset(
                    name=manifest.get("name", path.name),
                    slug=path.name,
                    publisher=manifest.get("publisher", "local"),
                    version=manifest.get("version", "local"),
                    asset_type=manifest.get("type", "skill"),
                    description=manifest.get("description", ""),
                    content=manifest,
                )

        return None

    except Exception as e:
        logger.warning(f"Failed to load asset from {path}: {e}")
        return None
