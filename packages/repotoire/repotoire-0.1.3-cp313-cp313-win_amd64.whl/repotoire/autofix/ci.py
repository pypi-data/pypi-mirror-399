"""CI/CD integration helpers for auto-fix.

Provides functionality for:
- Creating GitHub PRs
- Creating GitLab MRs
- Generating PR/MR descriptions
- Running auto-fix in CI environments
- Safety features for automated fixes
"""

import subprocess
import json
from pathlib import Path
from typing import List, Dict, Optional, Any
from datetime import datetime

from repotoire.autofix.models import FixBatch, FixProposal, FixStatus, FixConfidence
from repotoire.logging_config import get_logger

logger = get_logger(__name__)


class PRDescriptionGenerator:
    """Generates PR/MR descriptions from fix batches."""

    def generate(self, fix_batch: FixBatch, test_results: Optional[Dict] = None) -> str:
        """Generate PR/MR description from fix batch.

        Args:
            fix_batch: Batch of fixes that were applied
            test_results: Optional test results

        Returns:
            Markdown PR/MR description
        """
        # Group by fix type
        by_type: Dict[str, List[FixProposal]] = {}
        by_confidence: Dict[str, int] = {
            "high": 0,
            "medium": 0,
            "low": 0,
        }

        for fix in fix_batch.fixes:
            fix_type = fix.fix_type.value
            by_type.setdefault(fix_type, []).append(fix)

            # Count by confidence
            conf = fix.confidence.value
            if conf in by_confidence:
                by_confidence[conf] += 1

        # Generate description
        desc = "## ðŸ¤– Auto-Fix Summary\n\n"
        desc += "Automated code quality fixes generated by Repotoire.\n\n"

        # Changes section
        desc += "### Changes\n\n"
        for fix_type, fixes in sorted(by_type.items()):
            emoji = self._get_type_emoji(fix_type)
            desc += f"- {emoji} **{fix_type.replace('_', ' ').title()}**: {len(fixes)} fix(es)\n"

        desc += "\n"

        # Confidence section
        desc += "### Confidence Levels\n\n"
        for level, count in by_confidence.items():
            if count > 0:
                emoji = "ðŸŸ¢" if level == "high" else "ðŸŸ¡" if level == "medium" else "ðŸŸ "
                desc += f"- {emoji} **{level.title()} confidence**: {count} fix(es)\n"

        desc += "\n"

        # Evidence section
        desc += "### Evidence\n\n"
        desc += "All fixes are backed by:\n"
        desc += "- ðŸŽ¯ Industry best practices\n"
        desc += "- ðŸ“š Code quality standards\n"
        desc += "- ðŸ” Similar patterns in codebase\n"
        desc += "- ðŸ¤– AI analysis with RAG context\n\n"

        # Test results if available
        if test_results:
            desc += "### Testing\n\n"
            if test_results.get("passed"):
                desc += "- âœ… All tests passing\n"
                desc += f"- âœ… {test_results.get('test_count', 0)} tests passed\n"
            else:
                desc += "- âš ï¸ Some tests failed\n"
                desc += f"- âŒ {test_results.get('failed_count', 0)} tests failed\n"

            desc += "\n"

        # Files changed
        changed_files = set()
        for fix in fix_batch.fixes:
            for change in fix.changes:
                changed_files.add(change.file_path)

        if changed_files:
            desc += f"### Files Modified ({len(changed_files)})\n\n"
            for file_path in sorted(changed_files)[:10]:  # Limit to 10
                desc += f"- `{file_path}`\n"

            if len(changed_files) > 10:
                desc += f"\n_...and {len(changed_files) - 10} more files_\n"

            desc += "\n"

        # Footer
        desc += "---\n\n"
        desc += f"ðŸ¤– Generated by **Repotoire Auto-Fix** on {datetime.now().strftime('%Y-%m-%d %H:%M UTC')}\n"

        return desc

    def _get_type_emoji(self, fix_type: str) -> str:
        """Get emoji for fix type."""
        emoji_map = {
            "security": "ðŸ”’",
            "bug": "ðŸ›",
            "style": "âœ¨",
            "documentation": "ðŸ“",
            "performance": "âš¡",
            "refactoring": "â™»ï¸",
            "test": "ðŸ§ª",
            "type_hint": "ðŸ·ï¸",
        }
        return emoji_map.get(fix_type, "âœ…")


class GitHubPRCreator:
    """Creates GitHub pull requests using gh CLI."""

    def __init__(self, repository_path: Path):
        """Initialize GitHub PR creator.

        Args:
            repository_path: Path to git repository
        """
        self.repository_path = Path(repository_path)

    def create_pr(
        self,
        branch_name: str,
        title: str,
        body: str,
        labels: Optional[List[str]] = None,
        reviewers: Optional[List[str]] = None,
        draft: bool = False,
    ) -> Dict[str, Any]:
        """Create a GitHub pull request.

        Args:
            branch_name: Name of the branch with fixes
            title: PR title
            body: PR description
            labels: Optional labels to add
            reviewers: Optional reviewers to assign
            draft: Whether to create as draft PR

        Returns:
            PR information dictionary

        Raises:
            RuntimeError: If PR creation fails
        """
        logger.info(f"Creating GitHub PR: {title}")

        # Build gh command
        cmd = [
            "gh", "pr", "create",
            "--title", title,
            "--body", body,
            "--head", branch_name,
        ]

        if draft:
            cmd.append("--draft")

        if labels:
            for label in labels:
                cmd.extend(["--label", label])

        if reviewers:
            for reviewer in reviewers:
                cmd.extend(["--reviewer", reviewer])

        try:
            result = subprocess.run(
                cmd,
                cwd=self.repository_path,
                capture_output=True,
                text=True,
                timeout=60,
            )

            if result.returncode != 0:
                logger.error(f"Failed to create PR: {result.stderr}")
                raise RuntimeError(f"PR creation failed: {result.stderr}")

            # Extract PR URL from output
            pr_url = result.stdout.strip()

            logger.info(f"PR created successfully: {pr_url}")

            return {
                "url": pr_url,
                "branch": branch_name,
                "title": title,
            }

        except subprocess.TimeoutExpired:
            raise RuntimeError("PR creation timed out")
        except FileNotFoundError:
            raise RuntimeError(
                "GitHub CLI (gh) not found. Install from https://cli.github.com/"
            )
        except Exception as e:
            raise RuntimeError(f"Failed to create PR: {e}")


class GitLabMRCreator:
    """Creates GitLab merge requests using glab CLI."""

    def __init__(self, repository_path: Path):
        """Initialize GitLab MR creator.

        Args:
            repository_path: Path to git repository
        """
        self.repository_path = Path(repository_path)

    def create_mr(
        self,
        branch_name: str,
        title: str,
        description: str,
        labels: Optional[List[str]] = None,
        reviewers: Optional[List[str]] = None,
        draft: bool = False,
    ) -> Dict[str, Any]:
        """Create a GitLab merge request.

        Args:
            branch_name: Name of the branch with fixes
            title: MR title
            description: MR description
            labels: Optional labels to add
            reviewers: Optional reviewers to assign
            draft: Whether to create as draft MR

        Returns:
            MR information dictionary

        Raises:
            RuntimeError: If MR creation fails
        """
        logger.info(f"Creating GitLab MR: {title}")

        # Build glab command
        cmd = [
            "glab", "mr", "create",
            "--title", title,
            "--description", description,
            "--source-branch", branch_name,
        ]

        if draft:
            cmd.append("--draft")

        if labels:
            cmd.extend(["--label", ",".join(labels)])

        if reviewers:
            cmd.extend(["--reviewer", ",".join(reviewers)])

        try:
            result = subprocess.run(
                cmd,
                cwd=self.repository_path,
                capture_output=True,
                text=True,
                timeout=60,
            )

            if result.returncode != 0:
                logger.error(f"Failed to create MR: {result.stderr}")
                raise RuntimeError(f"MR creation failed: {result.stderr}")

            # Extract MR URL from output
            mr_url = result.stdout.strip().split("\n")[-1]

            logger.info(f"MR created successfully: {mr_url}")

            return {
                "url": mr_url,
                "branch": branch_name,
                "title": title,
            }

        except subprocess.TimeoutExpired:
            raise RuntimeError("MR creation timed out")
        except FileNotFoundError:
            raise RuntimeError(
                "GitLab CLI (glab) not found. Install from https://gitlab.com/gitlab-org/cli"
            )
        except Exception as e:
            raise RuntimeError(f"Failed to create MR: {e}")


class CIRunner:
    """Runs auto-fix in CI/CD environments with safety features."""

    def __init__(
        self,
        repository_path: Path,
        max_fixes: int = 50,
        dry_run: bool = False,
    ):
        """Initialize CI runner.

        Args:
            repository_path: Path to repository
            max_fixes: Maximum number of fixes to apply
            dry_run: Whether to run in dry-run mode
        """
        self.repository_path = Path(repository_path)
        self.max_fixes = max_fixes
        self.dry_run = dry_run

    def should_create_pr(self, fix_batch: FixBatch) -> bool:
        """Determine if PR should be created based on fixes.

        Args:
            fix_batch: Batch of fixes

        Returns:
            True if PR should be created
        """
        # Don't create PR if no fixes or dry-run
        if not fix_batch.fixes or self.dry_run:
            return False

        # Don't create PR if all fixes are low confidence
        has_high_conf = any(
            fix.confidence == FixConfidence.HIGH
            for fix in fix_batch.fixes
        )

        if not has_high_conf:
            logger.warning("All fixes are low/medium confidence, skipping PR creation")
            return False

        return True

    def create_branch(self, branch_name: str) -> None:
        """Create and checkout a new git branch.

        Args:
            branch_name: Name of branch to create
        """
        try:
            # Create branch
            subprocess.run(
                ["git", "checkout", "-b", branch_name],
                cwd=self.repository_path,
                check=True,
                capture_output=True,
            )

            logger.info(f"Created branch: {branch_name}")

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to create branch: {e.stderr.decode()}")
            raise RuntimeError(f"Branch creation failed: {e}")

    def commit_changes(self, message: str) -> None:
        """Commit changes to git.

        Args:
            message: Commit message
        """
        try:
            # Add all changes
            subprocess.run(
                ["git", "add", "-A"],
                cwd=self.repository_path,
                check=True,
                capture_output=True,
            )

            # Commit
            subprocess.run(
                ["git", "commit", "-m", message],
                cwd=self.repository_path,
                check=True,
                capture_output=True,
            )

            logger.info("Changes committed")

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to commit: {e.stderr.decode()}")
            raise RuntimeError(f"Commit failed: {e}")

    def push_branch(self, branch_name: str) -> None:
        """Push branch to remote.

        Args:
            branch_name: Name of branch to push
        """
        try:
            subprocess.run(
                ["git", "push", "-u", "origin", branch_name],
                cwd=self.repository_path,
                check=True,
                capture_output=True,
            )

            logger.info(f"Pushed branch: {branch_name}")

        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to push: {e.stderr.decode()}")
            raise RuntimeError(f"Push failed: {e}")

    def run_tests(self) -> Dict[str, Any]:
        """Run tests to validate fixes.

        Returns:
            Test results dictionary
        """
        try:
            # Try pytest first
            result = subprocess.run(
                ["pytest", "--tb=short", "-q"],
                cwd=self.repository_path,
                capture_output=True,
                text=True,
                timeout=300,
            )

            passed = result.returncode == 0

            return {
                "passed": passed,
                "test_count": self._count_tests(result.stdout) if passed else 0,
                "failed_count": self._count_failures(result.stdout) if not passed else 0,
                "output": result.stdout,
            }

        except (FileNotFoundError, subprocess.TimeoutExpired):
            logger.warning("Could not run tests (pytest not found or timeout)")
            return {
                "passed": True,  # Assume pass if tests can't run
                "test_count": 0,
                "failed_count": 0,
                "output": "Tests not run",
            }

    def _count_tests(self, output: str) -> int:
        """Count passed tests from pytest output."""
        import re
        match = re.search(r"(\d+) passed", output)
        return int(match.group(1)) if match else 0

    def _count_failures(self, output: str) -> int:
        """Count failed tests from pytest output."""
        import re
        match = re.search(r"(\d+) failed", output)
        return int(match.group(1)) if match else 0
