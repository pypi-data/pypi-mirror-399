"""
Adapter Configuration Factory

This module provides translation from ClientConfig to mcp_proxy_adapter JsonRpcClient parameters.

Author: Vasiliy Zdanovskiy
email: vasilyvz@gmail.com
"""

from typing import TYPE_CHECKING, Any, Dict, Optional
from urllib.parse import urlparse
import os

if TYPE_CHECKING:
    from embed_client.config import ClientConfig


class AdapterConfigFactory:
    """
    Factory for converting ClientConfig/config_dict to adapter JsonRpcClient parameters.

    Translates embed-client configuration format to mcp_proxy_adapter JsonRpcClient
    initialization parameters, handling all security modes and authentication methods.
    """

    @staticmethod
    def from_config_dict(config_dict: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert config_dict to adapter parameters.

        Args:
            config_dict: Configuration dictionary with server, auth, ssl sections

        Returns:
            Dictionary with adapter parameters: protocol, host, port, token_header,
            token, cert, key, ca, check_hostname, timeout
        """
        server_config = config_dict.get("server", {})
        auth_config = config_dict.get("auth", {})
        ssl_config = config_dict.get("ssl", {})
        client_config = config_dict.get("client", {})

        # Extract base URL and parse it
        base_url = server_config.get("base_url") or server_config.get(
            "host", "http://localhost"
        )
        port = server_config.get("port", 8001)

        parsed = urlparse(base_url)
        protocol = parsed.scheme or "http"
        host = parsed.hostname or "localhost"

        # If port is in URL, use it; otherwise use config port
        if parsed.port:
            port = parsed.port
        elif ":" in base_url and not base_url.startswith("http"):
            # Handle edge case where port might be in hostname
            pass

        # Determine protocol for adapter (http, https, mtls)
        adapter_protocol = "http"
        if protocol == "https" or ssl_config.get("enabled", False):
            if ssl_config.get("cert_file") and ssl_config.get("key_file"):
                adapter_protocol = "mtls"
            else:
                adapter_protocol = "https"

        # Extract authentication parameters
        token_header: Optional[str] = None
        token: Optional[str] = None
        auth_method = auth_config.get("method", "none")

        if auth_method == "api_key":
            api_keys = auth_config.get("api_keys", {})
            if api_keys:
                # Use first available API key
                token = list(api_keys.values())[0]
                token_header = auth_config.get("api_key_header", "X-API-Key")
        elif auth_method == "jwt":
            # JWT tokens are created dynamically, but we can set header
            token_header = "Authorization"
            # Token will be generated by auth manager
            jwt_config = auth_config.get("jwt", {})
            if jwt_config.get("username") and jwt_config.get("password"):
                # Store credentials for later token generation
                token = None  # Will be generated on demand
        elif auth_method == "basic":
            token_header = "Authorization"
            # Basic auth will be handled via adapter's token mechanism
            basic_config = auth_config.get("basic", {})
            if basic_config.get("username") and basic_config.get("password"):
                token = None  # Will be generated on demand

        # Extract SSL/TLS parameters
        cert: Optional[str] = None
        key: Optional[str] = None
        ca: Optional[str] = None
        check_hostname = ssl_config.get("check_hostname", True)

        if adapter_protocol in ("https", "mtls"):
            cert = ssl_config.get("cert_file")
            key = ssl_config.get("key_file")
            ca = ssl_config.get("ca_cert_file")

            # If mTLS, ensure cert and key are set
            if adapter_protocol == "mtls" and not (cert and key):
                # Fallback to auth certificate config
                cert = auth_config.get("certificate", {}).get("cert_file")
                key = auth_config.get("certificate", {}).get("key_file")

        # Extract timeout
        timeout = client_config.get("timeout", 30.0)

        return {
            "protocol": adapter_protocol,
            "host": host,
            "port": port,
            "token_header": token_header,
            "token": token,
            "cert": cert,
            "key": key,
            "ca": ca,
            "check_hostname": check_hostname,
            "timeout": timeout,
            # Store original config for auth manager integration
            "_original_config": config_dict,
        }

    @staticmethod
    def from_client_config(config: "ClientConfig") -> Dict[str, Any]:
        """
        Convert ClientConfig object to adapter parameters.

        Args:
            config: ClientConfig instance

        Returns:
            Dictionary with adapter parameters
        """
        return AdapterConfigFactory.from_config_dict(config.get_all())

    @staticmethod
    def from_legacy_params(
        base_url: str,
        port: Optional[int] = None,
        auth_method: Optional[str] = None,
        ssl_enabled: Optional[bool] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """
        Convert legacy factory parameters to adapter parameters.

        Args:
            base_url: Server base URL
            port: Server port
            auth_method: Authentication method
            ssl_enabled: Whether SSL is enabled
            **kwargs: Additional parameters (cert_file, key_file, api_key, etc.)

        Returns:
            Dictionary with adapter parameters
        """
        parsed = urlparse(base_url)
        protocol = parsed.scheme or "http"
        host = parsed.hostname or "localhost"
        actual_port = port or parsed.port or (443 if protocol == "https" else 80)

        # Determine protocol
        adapter_protocol = "http"
        if ssl_enabled or protocol == "https":
            if kwargs.get("cert_file") and kwargs.get("key_file"):
                adapter_protocol = "mtls"
            else:
                adapter_protocol = "https"

        # Extract auth
        token_header: Optional[str] = None
        token: Optional[str] = None

        if auth_method == "api_key":
            token = kwargs.get("api_key") or os.environ.get("EMBED_CLIENT_API_KEY")
            token_header = kwargs.get("api_key_header", "X-API-Key")
        elif auth_method == "jwt":
            token_header = "Authorization"
            # JWT will be generated on demand
        elif auth_method == "basic":
            token_header = "Authorization"
            # Basic auth will be generated on demand

        # Extract SSL
        cert = kwargs.get("cert_file")
        key = kwargs.get("key_file")
        ca = kwargs.get("ca_cert_file")
        check_hostname = kwargs.get("check_hostname", True)

        timeout = kwargs.get("timeout", 30.0)

        return {
            "protocol": adapter_protocol,
            "host": host,
            "port": actual_port,
            "token_header": token_header,
            "token": token,
            "cert": cert,
            "key": key,
            "ca": ca,
            "check_hostname": check_hostname,
            "timeout": timeout,
        }
