"""
Embed contract test runner on localhost:8001.

Author: Vasiliy Zdanovskiy
email: vasilyvz@gmail.com
"""

import asyncio
import json
import sys
from pathlib import Path
from typing import Any, Dict, List

from embed_client.async_client import EmbeddingServiceAsyncClient, EmbeddingServiceError
from embed_client.config_generator import ClientConfigGenerator


class EmbedContract8001Tester:
    """
    Test runner that validates the embed contract on a real server at localhost:8001.

    For each of the 8 security modes generated by ClientConfigGenerator it:
    - performs a health check; and
    - issues an embed request with error_policy="continue" and a mix of valid/invalid texts,
      verifying that:
        * the positional mapping between input texts and results is preserved;
        * per-item errors are reported for invalid texts instead of a top-level error.
    """

    def __init__(self) -> None:
        self.test_texts: List[str] = ["valid text", "   ", "!!!"]
        self.base_port: int = 8001
        self.mtls_certs_dir: Path = Path(__file__).parent.parent / "mtls_certificates"
        self.config_generator = ClientConfigGenerator()
        self.test_results: Dict[str, bool] = {}

    def create_configs(self) -> Dict[str, Dict[str, Any]]:
        """Create configurations for all 8 security modes using the generator."""
        cert_file = str(self.mtls_certs_dir / "client" / "embedding-service.crt")
        key_file = str(self.mtls_certs_dir / "client" / "embedding-service.key")
        ca_cert_file = str(self.mtls_certs_dir / "ca" / "ca.crt")

        configs = self.config_generator.generate_all_configs(
            host="localhost",
            port=self.base_port,
            output_dir=None,
            cert_file=cert_file if Path(cert_file).exists() else None,
            key_file=key_file if Path(key_file).exists() else None,
            ca_cert_file=ca_cert_file if Path(ca_cert_file).exists() else None,
        )
        return configs

    async def test_mode(self, mode_name: str, config: Dict[str, Any]) -> bool:
        """Test embed contract for a specific security mode."""
        print(f"\nðŸ” Testing embed contract for mode: {mode_name}")
        print(f"   Config: {json.dumps(config, indent=2)}")

        try:
            async with EmbeddingServiceAsyncClient(config_dict=config) as client:
                # Health check
                print("   â³ Health check...")
                try:
                    health = await client.health()
                    print(f"   âœ… Health: {health}")
                except Exception as e:  # noqa: BLE001
                    print(f"   âš ï¸  Health check failed (may be expected): {e}")

                # Embed contract check
                print(f"   â³ Embed contract test with {len(self.test_texts)} texts...")
                try:
                    data = await client.embed(self.test_texts, error_policy="continue")
                except EmbeddingServiceError as e:
                    print(f"   âŒ Embed failed with EmbeddingServiceError: {e}")
                    return False
                except Exception as e:  # noqa: BLE001
                    print(f"   âŒ Unexpected error during embed: {e}")
                    return False

                if not isinstance(data, dict):
                    print(f"   âŒ Data is not a dict: {type(data)}")
                    return False

                results = data.get("results")
                embeddings = data.get("embeddings")

                if not results:
                    print("   âŒ No 'results' in data â€“ new contract not satisfied.")
                    return False

                if len(results) != len(self.test_texts):
                    print(
                        f"   âŒ Wrong number of results: expected {len(self.test_texts)}, "
                        f"got {len(results)}"
                    )
                    return False

                if embeddings is not None and len(embeddings) != len(self.test_texts):
                    print(
                        f"   âŒ Wrong number of embeddings: expected {len(self.test_texts)}, "
                        f"got {len(embeddings)}"
                    )
                    return False

                # Validate per-item behavior according to the memo
                ok = True
                for idx, (text, item) in enumerate(zip(self.test_texts, results)):
                    err = item.get("error")
                    emb = item.get("embedding")

                    if idx == 0:
                        # First text should be valid: embedding present, error is None
                        if err is not None or emb is None:
                            print(
                                f"   âŒ Item 0 expected to be valid, got error={err}, embedding={emb}"
                            )
                            ok = False
                    else:
                        # Invalid texts should produce per-item error and null embedding
                        if emb is not None or err is None:
                            print(
                                f"   âŒ Item {idx} expected to have per-item error and null embedding, "
                                f"got error={err}, embedding={emb}"
                            )
                            ok = False
                        else:
                            if (
                                not isinstance(err, dict)
                                or "code" not in err
                                or "message" not in err
                            ):
                                print(
                                    f"   âŒ Item {idx} error does not contain code/message: {err}"
                                )
                                ok = False

                if ok:
                    print("   âœ… Embed contract satisfied for this mode.")
                else:
                    print("   âŒ Embed contract NOT satisfied for this mode.")

                return ok

        except Exception as e:  # noqa: BLE001
            print(f"   âŒ Failed to create client or connect: {e}")
            return False

    async def run_all_tests(self) -> bool:
        """Run embed contract tests for all security modes on localhost:8001."""
        print("=" * 80)
        print("ðŸ§ª Embed Contract Test Runner for All Security Modes on localhost:8001")
        print("=" * 80)
        print(f"ðŸ“ Test texts: {self.test_texts}")
        print(f"ðŸŒ Server: localhost:{self.base_port}")
        print("=" * 80)

        configs = self.create_configs()

        for mode_name, config in configs.items():
            success = await self.test_mode(mode_name, config)
            self.test_results[mode_name] = success
            await asyncio.sleep(0.5)

        print("\n" + "=" * 80)
        print("ðŸ“Š Embed Contract Test Results")
        print("=" * 80)

        total = len(self.test_results)
        passed = sum(1 for v in self.test_results.values() if v)
        failed = total - passed

        for mode_name, success in self.test_results.items():
            status = "âœ… PASS" if success else "âŒ FAIL"
            print(f"{mode_name:20} {status}")

        print("=" * 80)
        print(f"ðŸ“ˆ Total: {total} | âœ… Passed: {passed} | âŒ Failed: {failed}")
        print("=" * 80)

        if failed == 0:
            print("\nðŸŽ‰ Embed contract is satisfied for all modes!")
            return True

        print("\nâš ï¸  Embed contract FAILED for some modes.")
        return False


async def main() -> None:
    """Main entry point for manual embed contract testing."""
    tester = EmbedContract8001Tester()
    success = await tester.run_all_tests()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    asyncio.run(main())
