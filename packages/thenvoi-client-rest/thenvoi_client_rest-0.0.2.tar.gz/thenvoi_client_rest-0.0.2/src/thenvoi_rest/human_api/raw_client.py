# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.agent_register_request import AgentRegisterRequest
from ..types.chat_message_request import ChatMessageRequest
from ..types.error import Error
from ..types.validation_error import ValidationError
from .types.add_my_chat_participant_request_participant import AddMyChatParticipantRequestParticipant
from .types.add_my_chat_participant_response import AddMyChatParticipantResponse
from .types.create_my_chat_room_request_chat import CreateMyChatRoomRequestChat
from .types.create_my_chat_room_response import CreateMyChatRoomResponse
from .types.delete_my_agent_response import DeleteMyAgentResponse
from .types.get_my_chat_room_response import GetMyChatRoomResponse
from .types.get_my_profile_response import GetMyProfileResponse
from .types.list_my_agents_response import ListMyAgentsResponse
from .types.list_my_chat_messages_request_message_type import ListMyChatMessagesRequestMessageType
from .types.list_my_chat_messages_response import ListMyChatMessagesResponse
from .types.list_my_chat_participants_request_participant_type import ListMyChatParticipantsRequestParticipantType
from .types.list_my_chat_participants_response import ListMyChatParticipantsResponse
from .types.list_my_chats_response import ListMyChatsResponse
from .types.list_my_peers_request_type import ListMyPeersRequestType
from .types.list_my_peers_response import ListMyPeersResponse
from .types.register_my_agent_response import RegisterMyAgentResponse
from .types.remove_my_chat_participant_response import RemoveMyChatParticipantResponse
from .types.send_my_chat_message_response import SendMyChatMessageResponse
from .types.update_my_profile_request_user import UpdateMyProfileRequestUser
from .types.update_my_profile_response import UpdateMyProfileResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawHumanApiClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_my_agents(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyAgentsResponse]:
        """
        Returns a paginated list of agents that you own.

        This includes both platform agents and external agents you have registered.
        Global agents owned by you are also included.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyAgentsResponse]
            Your Agents
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/agents",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyAgentsResponse,
                    parse_obj_as(
                        type_=ListMyAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def register_my_agent(
        self, *, agent: AgentRegisterRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RegisterMyAgentResponse]:
        """
        Registers a new external agent and returns its API key.

        External agents run their own reasoning loop and connect to the platform
        to participate in chat rooms and execute tasks.

        **Important**: The API key is only shown once - store it securely.

        Parameters
        ----------
        agent : AgentRegisterRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RegisterMyAgentResponse]
            Registered Agent
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/agents/register",
            method="POST",
            json={
                "agent": convert_and_respect_annotation_metadata(
                    object_=agent, annotation=AgentRegisterRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegisterMyAgentResponse,
                    parse_obj_as(
                        type_=RegisterMyAgentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_my_agent(
        self, id: str, *, force: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteMyAgentResponse]:
        """
        Deletes an agent that you own.

        **Default behavior**: Returns 422 if agent has execution history.
        This protects audit trails and task history.

        **Force deletion** (`?force=true`): Deletes all execution history first,
        then deletes the agent. Use with caution - this is irreversible.

        Deletion will:
        - Revoke the agent's API key
        - Remove the agent from all chat rooms (soft delete)
        - Delete associated memories and tool configurations
        - With `force=true`: Delete all execution history

        Parameters
        ----------
        id : str
            Agent ID

        force : typing.Optional[bool]
            Force deletion including all execution history

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteMyAgentResponse]
            Agent Deleted
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/agents/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "force": force,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteMyAgentResponse,
                    parse_obj_as(
                        type_=DeleteMyAgentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_my_chats(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyChatsResponse]:
        """
        Returns a paginated list of all chat rooms where you are a participant.

        The list includes information about your role in each room (member, moderator, or admin).
        Shows only rooms you have access to based on your participation.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number for pagination

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyChatsResponse]
            Chat Rooms
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatsResponse,
                    parse_obj_as(
                        type_=ListMyChatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_my_chat_room(
        self, *, chat: CreateMyChatRoomRequestChat, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateMyChatRoomResponse]:
        """
        Creates a new chat room with you as the owner.

        The chat room title is auto-generated from the first message.
        You can optionally associate the chat room with a task by providing a task_id.

        Parameters
        ----------
        chat : CreateMyChatRoomRequestChat

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateMyChatRoomResponse]
            Created Chat Room
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="POST",
            json={
                "chat": convert_and_respect_annotation_metadata(
                    object_=chat, annotation=CreateMyChatRoomRequestChat, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateMyChatRoomResponse,
                    parse_obj_as(
                        type_=CreateMyChatRoomResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_my_chat_messages(
        self,
        chat_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        message_type: typing.Optional[ListMyChatMessagesRequestMessageType] = None,
        since: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyChatMessagesResponse]:
        """
        Returns a paginated list of ALL messages in a chat room where you are a participant.

        This includes all message types: text, tool_call, tool_result, thought, error.
        Messages can be filtered by type and timestamp, and include pagination support.

        Use the `message_type` parameter to filter by specific type(s).

        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        message_type : typing.Optional[ListMyChatMessagesRequestMessageType]
            Filter by message type (text, tool_call, tool_result, thought, error)

        since : typing.Optional[dt.datetime]
            Filter messages after this timestamp

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyChatMessagesResponse]
            Chat Messages
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "message_type": message_type,
                "since": serialize_datetime(since) if since is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatMessagesResponse,
                    parse_obj_as(
                        type_=ListMyChatMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_my_chat_message(
        self, chat_id: str, *, message: ChatMessageRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[SendMyChatMessageResponse]:
        """
        Creates a new text message in a chat room. The user must be a participant in the room.

        This endpoint only supports `text` message type. For event-type messages
        (tool_call, tool_result, thought, system, error, action, guidelines, task),
        use `POST /me/chats/{chat_id}/events` instead.

        Messages must include at least one @mention to ensure proper routing to recipients.

        Example request:
        ```json
        {
          "message": {
            "content": "@Agent Assistant please help me with this task",
            "mentions": [
              {"id": "agent-uuid", "name": "Agent Assistant"}
            ]
          }
        }
        ```

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        message : ChatMessageRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SendMyChatMessageResponse]
            Created Message
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="POST",
            json={
                "message": convert_and_respect_annotation_metadata(
                    object_=message, annotation=ChatMessageRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMyChatMessageResponse,
                    parse_obj_as(
                        type_=SendMyChatMessageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_my_chat_participants(
        self,
        chat_id: str,
        *,
        participant_type: typing.Optional[ListMyChatParticipantsRequestParticipantType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyChatParticipantsResponse]:
        """
        Returns a list of participants in a chat room where you are a participant.

        Returns 404 if the chat room doesn't exist or you're not a participant
        (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        participant_type : typing.Optional[ListMyChatParticipantsRequestParticipantType]
            Filter by participant type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyChatParticipantsResponse]
            Chat Room Participants
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants",
            method="GET",
            params={
                "participant_type": participant_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatParticipantsResponse,
                    parse_obj_as(
                        type_=ListMyChatParticipantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def add_my_chat_participant(
        self,
        chat_id: str,
        *,
        participant: AddMyChatParticipantRequestParticipant,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[AddMyChatParticipantResponse]:
        """
        Adds a new participant to a chat room where you have permission to add participants.

        You can add:
        - Your own agents
        - Global agents

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        participant : AddMyChatParticipantRequestParticipant

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[AddMyChatParticipantResponse]
            Participant Added
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants",
            method="POST",
            json={
                "participant": convert_and_respect_annotation_metadata(
                    object_=participant, annotation=AddMyChatParticipantRequestParticipant, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddMyChatParticipantResponse,
                    parse_obj_as(
                        type_=AddMyChatParticipantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def remove_my_chat_participant(
        self, chat_id: str, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RemoveMyChatParticipantResponse]:
        """
        Removes a participant from a chat room where you have permission to remove participants.

        Requires owner or admin role in the chat room.

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        id : str
            Participant ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RemoveMyChatParticipantResponse]
            Participant Removed
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveMyChatParticipantResponse,
                    parse_obj_as(
                        type_=RemoveMyChatParticipantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_my_chat_room(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetMyChatRoomResponse]:
        """
        Returns details of a specific chat room where you are a participant.

        Returns 404 if the room doesn't exist or if you're not a participant
        (security-first: doesn't leak room existence).

        Parameters
        ----------
        id : str
            Chat Room ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetMyChatRoomResponse]
            Chat Room
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetMyChatRoomResponse,
                    parse_obj_as(
                        type_=GetMyChatRoomResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_my_peers(
        self,
        *,
        not_in_chat: typing.Optional[str] = None,
        type: typing.Optional[ListMyPeersRequestType] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyPeersResponse]:
        """
        Lists entities that you can interact with in chat rooms.

        Peers include:
        - Other users in your organization
        - Agents you own
        - Global agents

        Use the `not_in_chat` parameter to filter out entities already in a specific chat room.
        Use the `type` parameter to filter by entity type (User or Agent).

        Parameters
        ----------
        not_in_chat : typing.Optional[str]
            Exclude entities already in this chat room

        type : typing.Optional[ListMyPeersRequestType]
            Filter by entity type

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyPeersResponse]
            Peers list
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/peers",
            method="GET",
            params={
                "not_in_chat": not_in_chat,
                "type": type,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyPeersResponse,
                    parse_obj_as(
                        type_=ListMyPeersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_my_profile(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetMyProfileResponse]:
        """
        Returns your profile details

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetMyProfileResponse]
            User Details
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/profile",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetMyProfileResponse,
                    parse_obj_as(
                        type_=GetMyProfileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_my_profile(
        self, *, user: UpdateMyProfileRequestUser, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[UpdateMyProfileResponse]:
        """
        Updates your profile details

        Parameters
        ----------
        user : UpdateMyProfileRequestUser
            User profile fields to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateMyProfileResponse]
            Updated User Details
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/v1/me/profile",
            method="PUT",
            json={
                "user": convert_and_respect_annotation_metadata(
                    object_=user, annotation=UpdateMyProfileRequestUser, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateMyProfileResponse,
                    parse_obj_as(
                        type_=UpdateMyProfileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawHumanApiClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_my_agents(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyAgentsResponse]:
        """
        Returns a paginated list of agents that you own.

        This includes both platform agents and external agents you have registered.
        Global agents owned by you are also included.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyAgentsResponse]
            Your Agents
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/agents",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyAgentsResponse,
                    parse_obj_as(
                        type_=ListMyAgentsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def register_my_agent(
        self, *, agent: AgentRegisterRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RegisterMyAgentResponse]:
        """
        Registers a new external agent and returns its API key.

        External agents run their own reasoning loop and connect to the platform
        to participate in chat rooms and execute tasks.

        **Important**: The API key is only shown once - store it securely.

        Parameters
        ----------
        agent : AgentRegisterRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RegisterMyAgentResponse]
            Registered Agent
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/agents/register",
            method="POST",
            json={
                "agent": convert_and_respect_annotation_metadata(
                    object_=agent, annotation=AgentRegisterRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RegisterMyAgentResponse,
                    parse_obj_as(
                        type_=RegisterMyAgentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_my_agent(
        self, id: str, *, force: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteMyAgentResponse]:
        """
        Deletes an agent that you own.

        **Default behavior**: Returns 422 if agent has execution history.
        This protects audit trails and task history.

        **Force deletion** (`?force=true`): Deletes all execution history first,
        then deletes the agent. Use with caution - this is irreversible.

        Deletion will:
        - Revoke the agent's API key
        - Remove the agent from all chat rooms (soft delete)
        - Delete associated memories and tool configurations
        - With `force=true`: Delete all execution history

        Parameters
        ----------
        id : str
            Agent ID

        force : typing.Optional[bool]
            Force deletion including all execution history

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteMyAgentResponse]
            Agent Deleted
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/agents/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "force": force,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteMyAgentResponse,
                    parse_obj_as(
                        type_=DeleteMyAgentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_my_chats(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyChatsResponse]:
        """
        Returns a paginated list of all chat rooms where you are a participant.

        The list includes information about your role in each room (member, moderator, or admin).
        Shows only rooms you have access to based on your participation.

        Parameters
        ----------
        page : typing.Optional[int]
            Page number for pagination

        page_size : typing.Optional[int]
            Number of items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyChatsResponse]
            Chat Rooms
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatsResponse,
                    parse_obj_as(
                        type_=ListMyChatsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_my_chat_room(
        self, *, chat: CreateMyChatRoomRequestChat, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateMyChatRoomResponse]:
        """
        Creates a new chat room with you as the owner.

        The chat room title is auto-generated from the first message.
        You can optionally associate the chat room with a task by providing a task_id.

        Parameters
        ----------
        chat : CreateMyChatRoomRequestChat

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateMyChatRoomResponse]
            Created Chat Room
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/chats",
            method="POST",
            json={
                "chat": convert_and_respect_annotation_metadata(
                    object_=chat, annotation=CreateMyChatRoomRequestChat, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateMyChatRoomResponse,
                    parse_obj_as(
                        type_=CreateMyChatRoomResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_my_chat_messages(
        self,
        chat_id: str,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        message_type: typing.Optional[ListMyChatMessagesRequestMessageType] = None,
        since: typing.Optional[dt.datetime] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyChatMessagesResponse]:
        """
        Returns a paginated list of ALL messages in a chat room where you are a participant.

        This includes all message types: text, tool_call, tool_result, thought, error.
        Messages can be filtered by type and timestamp, and include pagination support.

        Use the `message_type` parameter to filter by specific type(s).

        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        message_type : typing.Optional[ListMyChatMessagesRequestMessageType]
            Filter by message type (text, tool_call, tool_result, thought, error)

        since : typing.Optional[dt.datetime]
            Filter messages after this timestamp

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyChatMessagesResponse]
            Chat Messages
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="GET",
            params={
                "page": page,
                "page_size": page_size,
                "message_type": message_type,
                "since": serialize_datetime(since) if since is not None else None,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatMessagesResponse,
                    parse_obj_as(
                        type_=ListMyChatMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_my_chat_message(
        self, chat_id: str, *, message: ChatMessageRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[SendMyChatMessageResponse]:
        """
        Creates a new text message in a chat room. The user must be a participant in the room.

        This endpoint only supports `text` message type. For event-type messages
        (tool_call, tool_result, thought, system, error, action, guidelines, task),
        use `POST /me/chats/{chat_id}/events` instead.

        Messages must include at least one @mention to ensure proper routing to recipients.

        Example request:
        ```json
        {
          "message": {
            "content": "@Agent Assistant please help me with this task",
            "mentions": [
              {"id": "agent-uuid", "name": "Agent Assistant"}
            ]
          }
        }
        ```

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        message : ChatMessageRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SendMyChatMessageResponse]
            Created Message
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="POST",
            json={
                "message": convert_and_respect_annotation_metadata(
                    object_=message, annotation=ChatMessageRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SendMyChatMessageResponse,
                    parse_obj_as(
                        type_=SendMyChatMessageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_my_chat_participants(
        self,
        chat_id: str,
        *,
        participant_type: typing.Optional[ListMyChatParticipantsRequestParticipantType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyChatParticipantsResponse]:
        """
        Returns a list of participants in a chat room where you are a participant.

        Returns 404 if the chat room doesn't exist or you're not a participant
        (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        participant_type : typing.Optional[ListMyChatParticipantsRequestParticipantType]
            Filter by participant type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyChatParticipantsResponse]
            Chat Room Participants
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants",
            method="GET",
            params={
                "participant_type": participant_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatParticipantsResponse,
                    parse_obj_as(
                        type_=ListMyChatParticipantsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def add_my_chat_participant(
        self,
        chat_id: str,
        *,
        participant: AddMyChatParticipantRequestParticipant,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[AddMyChatParticipantResponse]:
        """
        Adds a new participant to a chat room where you have permission to add participants.

        You can add:
        - Your own agents
        - Global agents

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        participant : AddMyChatParticipantRequestParticipant

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[AddMyChatParticipantResponse]
            Participant Added
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants",
            method="POST",
            json={
                "participant": convert_and_respect_annotation_metadata(
                    object_=participant, annotation=AddMyChatParticipantRequestParticipant, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    AddMyChatParticipantResponse,
                    parse_obj_as(
                        type_=AddMyChatParticipantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def remove_my_chat_participant(
        self, chat_id: str, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RemoveMyChatParticipantResponse]:
        """
        Removes a participant from a chat room where you have permission to remove participants.

        Requires owner or admin role in the chat room.

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        id : str
            Participant ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RemoveMyChatParticipantResponse]
            Participant Removed
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/participants/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RemoveMyChatParticipantResponse,
                    parse_obj_as(
                        type_=RemoveMyChatParticipantResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_my_chat_room(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetMyChatRoomResponse]:
        """
        Returns details of a specific chat room where you are a participant.

        Returns 404 if the room doesn't exist or if you're not a participant
        (security-first: doesn't leak room existence).

        Parameters
        ----------
        id : str
            Chat Room ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetMyChatRoomResponse]
            Chat Room
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetMyChatRoomResponse,
                    parse_obj_as(
                        type_=GetMyChatRoomResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_my_peers(
        self,
        *,
        not_in_chat: typing.Optional[str] = None,
        type: typing.Optional[ListMyPeersRequestType] = None,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyPeersResponse]:
        """
        Lists entities that you can interact with in chat rooms.

        Peers include:
        - Other users in your organization
        - Agents you own
        - Global agents

        Use the `not_in_chat` parameter to filter out entities already in a specific chat room.
        Use the `type` parameter to filter by entity type (User or Agent).

        Parameters
        ----------
        not_in_chat : typing.Optional[str]
            Exclude entities already in this chat room

        type : typing.Optional[ListMyPeersRequestType]
            Filter by entity type

        page : typing.Optional[int]
            Page number

        page_size : typing.Optional[int]
            Items per page

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyPeersResponse]
            Peers list
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/peers",
            method="GET",
            params={
                "not_in_chat": not_in_chat,
                "type": type,
                "page": page,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyPeersResponse,
                    parse_obj_as(
                        type_=ListMyPeersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_my_profile(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetMyProfileResponse]:
        """
        Returns your profile details

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetMyProfileResponse]
            User Details
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/profile",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetMyProfileResponse,
                    parse_obj_as(
                        type_=GetMyProfileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_my_profile(
        self, *, user: UpdateMyProfileRequestUser, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[UpdateMyProfileResponse]:
        """
        Updates your profile details

        Parameters
        ----------
        user : UpdateMyProfileRequestUser
            User profile fields to update

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateMyProfileResponse]
            Updated User Details
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/v1/me/profile",
            method="PUT",
            json={
                "user": convert_and_respect_annotation_metadata(
                    object_=user, annotation=UpdateMyProfileRequestUser, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateMyProfileResponse,
                    parse_obj_as(
                        type_=UpdateMyProfileResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
