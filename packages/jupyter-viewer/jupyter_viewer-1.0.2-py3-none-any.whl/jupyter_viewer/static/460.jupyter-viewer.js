"use strict";
(self["webpackChunk_datalayer_jupyter_viewer"] = self["webpackChunk_datalayer_jupyter_viewer"] || []).push([[460],{

/***/ 90460
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  xml: () => (/* binding */ xml)
});

// UNUSED EXPORTS: autoCloseTags, completeFromSchema, xmlLanguage

// EXTERNAL MODULE: ./node_modules/@lezer/lr/dist/index.js
var dist = __webpack_require__(21661);
// EXTERNAL MODULE: ./node_modules/@lezer/highlight/dist/index.js
var highlight_dist = __webpack_require__(12555);
;// ./node_modules/@lezer/xml/dist/index.js



// This file was generated by lezer-generator. You probably shouldn't edit it.
const StartTag = 1,
  StartCloseTag = 2,
  MissingCloseTag = 3,
  mismatchedStartCloseTag = 4,
  incompleteStartCloseTag = 5,
  commentContent$1 = 36,
  piContent$1 = 37,
  cdataContent$1 = 38,
  Element = 11,
  OpenTag = 13;

/* Hand-written tokenizer for XML tag matching. */

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
let cachedName = null,
  cachedInput = null,
  cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedInput == input && cachedPos == pos) return cachedName;
  while (isSpace(input.peek(offset))) offset++;
  let name = "";
  for (;;) {
    let next = input.peek(offset);
    if (!nameChar(next)) break;
    name += String.fromCharCode(next);
    offset++;
  }
  cachedInput = input;
  cachedPos = pos;
  return cachedName = name || null;
}
function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
}
const elementContext = new dist/* ContextTracker */.Aj({
  start: null,
  shift(context, term, stack, input) {
    return term == StartTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context;
  },
  reuse(context, node, _stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  strict: false
});
const startTag = new dist/* ExternalTokenizer */.Lu((input, stack) => {
  if (input.next != 60 /* '<' */) return;
  input.advance();
  if (input.next == 47 /* '/' */) {
    input.advance();
    let name = tagNameAfter(input, 0);
    if (!name) return input.acceptToken(incompleteStartCloseTag);
    if (stack.context && name == stack.context.name) return input.acceptToken(StartCloseTag);
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return input.acceptToken(MissingCloseTag, -2);
    input.acceptToken(mismatchedStartCloseTag);
  } else if (input.next != 33 /* '!' */ && input.next != 63 /* '?' */) {
    return input.acceptToken(StartTag);
  }
}, {
  contextual: true
});
function scanTo(type, end) {
  return new dist/* ExternalTokenizer */.Lu(input => {
    let len = 0,
      first = end.charCodeAt(0);
    scan: for (;; input.advance(), len++) {
      if (input.next < 0) break;
      if (input.next == first) {
        for (let i = 1; i < end.length; i++) if (input.peek(i) != end.charCodeAt(i)) continue scan;
        break;
      }
    }
    if (len) input.acceptToken(type);
  });
}
const commentContent = scanTo(commentContent$1, "-->");
const piContent = scanTo(piContent$1, "?>");
const cdataContent = scanTo(cdataContent$1, "]]>");
const xmlHighlighting = (0,highlight_dist/* styleTags */.pn)({
  Text: highlight_dist/* tags */._A.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": highlight_dist/* tags */._A.angleBracket,
  TagName: highlight_dist/* tags */._A.tagName,
  "MismatchedCloseTag/TagName": [highlight_dist/* tags */._A.tagName, highlight_dist/* tags */._A.invalid],
  AttributeName: highlight_dist/* tags */._A.attributeName,
  AttributeValue: highlight_dist/* tags */._A.attributeValue,
  Is: highlight_dist/* tags */._A.definitionOperator,
  "EntityReference CharacterReference": highlight_dist/* tags */._A.character,
  Comment: highlight_dist/* tags */._A.blockComment,
  ProcessingInst: highlight_dist/* tags */._A.processingInstruction,
  DoctypeDecl: highlight_dist/* tags */._A.documentMeta,
  Cdata: highlight_dist/* tags */._A.special(highlight_dist/* tags */._A.string)
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = dist/* LRParser */.U1.deserialize({
  version: 14,
  states: ",lOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DT'#DTOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C|'#C|O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C}'#C}O$dOrO,59^OOOP,59^,59^OOOS'#DO'#DOO$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6z-E6zOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6{-E6{OOOP1G.x1G.xOOOS-E6|-E6|OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'mO!bO,59eOOOO-E6w-E6wO'{OpO1G.uO'{OpO1G.uOOOP1G.u1G.uO(TOpO7+$fOOOP7+$f7+$fO(]O!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(hO#tO'#CnO(vO&jO'#CnOOOO1G.q1G.qO)UOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO)^O#tO,59YOOOO,59Y,59YOOOO'#C{'#C{O)lO&jO,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.tOOOO-E6y-E6y",
  stateData: ")z~OPQOSVOTWOVWOWWOXWOiXOyPO!QTO!SUO~OvZOx]O~O^`Oz^O~OPQOQcOSVOTWOVWOWWOXWOyPO!QTO!SUO~ORdO~P!SOteO!PgO~OuhO!RjO~O^lOz^O~OvZOxoO~O^qOz^O~O[vO`sOdwOz^O~ORyO~P!SO^{Oz^O~OteO!P}O~OuhO!R!PO~O^!QOz^O~O[!SOz^O~O[!VO`sOd!WOz^O~Oa!YOz^O~Oz^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oz^O~O[!_Oz^O~O[!aOz^O~O[!cO`sOd!dOz^O~O[!cO`sOd!dO~Oa!eOz^O~Oz^O{!gO}!hO~Oz^O[ma`madma~O[!kOz^O~O[!lOz^O~O[!mO`sOd!nO~OW!qOX!qO{!sO|!qO~OW!tOX!tO}!sO!O!tO~O[!vOz^O~OW!qOX!qO{!yO|!qO~OW!tOX!tO}!yO!O!tO~O",
  goto: "%cxPPPPPPPPPPyyP!PP!VPP!`!jP!pyyyP!v!|#S$[$k$q$w$}%TPPPP%ZXWORYbXRORYb_t`qru!T!U!bQ!i!YS!p!e!fR!w!oQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!j!oQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!j!]R!o!eQu`S!UqrU![u!U!bR!b!TQ!r!gR!x!rQ!u!hR!z!uQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 50,
  context: elementContext,
  nodeProps: [["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"], ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"], ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]],
  propSources: [xmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!)v~R!YOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs*vsv$qvw+fwx/ix}$q}!O0[!O!P$q!P!Q2z!Q![$q![!]4n!]!^$q!^!_8U!_!`!#t!`!a!$l!a!b!%d!b!c$q!c!}4n!}#P$q#P#Q!'W#Q#R$q#R#S4n#S#T$q#T#o4n#o%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U$q4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qi$zXVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qa%nVVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%gP&YTVPOv&Tw!^&T!_;'S&T;'S;=`&i<%lO&TP&lP;=`<%l&T`&tS!O`Ov&ox;'S&o;'S;=`'Q<%lO&o`'TP;=`<%l&oa'ZP;=`<%l%gX'eWVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^W(ST|WOr'}sv'}w;'S'};'S;=`(c<%lO'}W(fP;=`<%l'}X(lP;=`<%l'^h(vV|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oh)`P;=`<%l(oi)fP;=`<%l$qo)t`VP|W!O`zUOX$qXY)iYZ)iZ]$q]^)i^p$qpq)iqr$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk+PV{YVP!O`Ov%gwx&Tx!^%g!^!_&o!_;'S%g;'S;=`'W<%lO%g~+iast,n![!]-r!c!}-r#R#S-r#T#o-r%W%o-r%p&a-r&b1p-r4U4d-r4e$IS-r$I`$Ib-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~,qQ!Q![,w#l#m-V~,zQ!Q![,w!]!^-Q~-VOX~~-YR!Q![-c!c!i-c#T#Z-c~-fS!Q![-c!]!^-Q!c!i-c#T#Z-c~-ug}!O-r!O!P-r!Q![-r![!]-r!]!^/^!c!}-r#R#S-r#T#o-r$}%O-r%W%o-r%p&a-r&b1p-r1p4U-r4U4d-r4e$IS-r$I`$Ib-r$Je$Jg-r$Kh%#t-r&/x&Et-r&FV;'S-r;'S;:j/c?&r?Ah-r?BY?Mn-r~/cOW~~/fP;=`<%l-rk/rW}bVP|WOr'^rs&Tsv'^w!^'^!^!_'}!_;'S'^;'S;=`(i<%lO'^k0eZVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O1W!O!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk1aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a2S!a;'S$q;'S;=`)c<%lO$qk2_X!PQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qm3TZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a3v!a;'S$q;'S;=`)c<%lO$qm4RXdSVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo4{!P`S^QVP|W!O`Or$qrs%gsv$qwx'^x}$q}!O4n!O!P4n!P!Q$q!Q![4n![!]4n!]!^$q!^!_(o!_!c$q!c!}4n!}#R$q#R#S4n#S#T$q#T#o4n#o$}$q$}%O4n%O%W$q%W%o4n%o%p$q%p&a4n&a&b$q&b1p4n1p4U4n4U4d4n4d4e$q4e$IS4n$IS$I`$q$I`$Ib4n$Ib$Je$q$Je$Jg4n$Jg$Kh$q$Kh%#t4n%#t&/x$q&/x&Et4n&Et&FV$q&FV;'S4n;'S;:j8O;:j;=`)c<%l?&r$q?&r?Ah4n?Ah?BY$q?BY?Mn4n?MnO$qo8RP;=`<%l4ni8]Y|W!O`Oq(oqr8{rs&osv(owx'}x!a(o!a!b!#U!b;'S(o;'S;=`)]<%lO(oi9S_|W!O`Or(ors&osv(owx'}x}(o}!O:R!O!f(o!f!g;e!g!}(o!}#ODh#O#W(o#W#XLp#X;'S(o;'S;=`)]<%lO(oi:YX|W!O`Or(ors&osv(owx'}x}(o}!O:u!O;'S(o;'S;=`)]<%lO(oi;OV!QP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oi;lX|W!O`Or(ors&osv(owx'}x!q(o!q!r<X!r;'S(o;'S;=`)]<%lO(oi<`X|W!O`Or(ors&osv(owx'}x!e(o!e!f<{!f;'S(o;'S;=`)]<%lO(oi=SX|W!O`Or(ors&osv(owx'}x!v(o!v!w=o!w;'S(o;'S;=`)]<%lO(oi=vX|W!O`Or(ors&osv(owx'}x!{(o!{!|>c!|;'S(o;'S;=`)]<%lO(oi>jX|W!O`Or(ors&osv(owx'}x!r(o!r!s?V!s;'S(o;'S;=`)]<%lO(oi?^X|W!O`Or(ors&osv(owx'}x!g(o!g!h?y!h;'S(o;'S;=`)]<%lO(oi@QY|W!O`Or?yrs@psv?yvwA[wxBdx!`?y!`!aCr!a;'S?y;'S;=`Db<%lO?ya@uV!O`Ov@pvxA[x!`@p!`!aAy!a;'S@p;'S;=`B^<%lO@pPA_TO!`A[!`!aAn!a;'SA[;'S;=`As<%lOA[PAsOiPPAvP;=`<%lA[aBQSiP!O`Ov&ox;'S&o;'S;=`'Q<%lO&oaBaP;=`<%l@pXBiX|WOrBdrsA[svBdvwA[w!`Bd!`!aCU!a;'SBd;'S;=`Cl<%lOBdXC]TiP|WOr'}sv'}w;'S'};'S;=`(c<%lO'}XCoP;=`<%lBdiC{ViP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiDeP;=`<%l?yiDoZ|W!O`Or(ors&osv(owx'}x!e(o!e!fEb!f#V(o#V#WIr#W;'S(o;'S;=`)]<%lO(oiEiX|W!O`Or(ors&osv(owx'}x!f(o!f!gFU!g;'S(o;'S;=`)]<%lO(oiF]X|W!O`Or(ors&osv(owx'}x!c(o!c!dFx!d;'S(o;'S;=`)]<%lO(oiGPX|W!O`Or(ors&osv(owx'}x!v(o!v!wGl!w;'S(o;'S;=`)]<%lO(oiGsX|W!O`Or(ors&osv(owx'}x!c(o!c!dH`!d;'S(o;'S;=`)]<%lO(oiHgX|W!O`Or(ors&osv(owx'}x!}(o!}#OIS#O;'S(o;'S;=`)]<%lO(oiI]V|W!O`yPOr(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(oiIyX|W!O`Or(ors&osv(owx'}x#W(o#W#XJf#X;'S(o;'S;=`)]<%lO(oiJmX|W!O`Or(ors&osv(owx'}x#T(o#T#UKY#U;'S(o;'S;=`)]<%lO(oiKaX|W!O`Or(ors&osv(owx'}x#h(o#h#iK|#i;'S(o;'S;=`)]<%lO(oiLTX|W!O`Or(ors&osv(owx'}x#T(o#T#UH`#U;'S(o;'S;=`)]<%lO(oiLwX|W!O`Or(ors&osv(owx'}x#c(o#c#dMd#d;'S(o;'S;=`)]<%lO(oiMkX|W!O`Or(ors&osv(owx'}x#V(o#V#WNW#W;'S(o;'S;=`)]<%lO(oiN_X|W!O`Or(ors&osv(owx'}x#h(o#h#iNz#i;'S(o;'S;=`)]<%lO(oi! RX|W!O`Or(ors&osv(owx'}x#m(o#m#n! n#n;'S(o;'S;=`)]<%lO(oi! uX|W!O`Or(ors&osv(owx'}x#d(o#d#e!!b#e;'S(o;'S;=`)]<%lO(oi!!iX|W!O`Or(ors&osv(owx'}x#X(o#X#Y?y#Y;'S(o;'S;=`)]<%lO(oi!#_V!SP|W!O`Or(ors&osv(owx'}x;'S(o;'S;=`)]<%lO(ok!$PXaQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qo!$wX[UVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!%mZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!&`!a;'S$q;'S;=`)c<%lO$qk!&kX!RQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$qk!'aZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_#P$q#P#Q!(S#Q;'S$q;'S;=`)c<%lO$qk!(]ZVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_!`$q!`!a!)O!a;'S$q;'S;=`)c<%lO$qk!)ZXxQVP|W!O`Or$qrs%gsv$qwx'^x!^$q!^!_(o!_;'S$q;'S;=`)c<%lO$q",
  tokenizers: [startTag, commentContent, piContent, cdataContent, 0, 1, 2, 3, 4],
  topRules: {
    "Document": [0, 6]
  },
  tokenPrec: 0
});

// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var language_dist = __webpack_require__(69753);
// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js + 1 modules
var state_dist = __webpack_require__(81490);
// EXTERNAL MODULE: ./node_modules/@codemirror/view/dist/index.js + 1 modules
var view_dist = __webpack_require__(44898);
;// ./node_modules/@codemirror/lang-xml/dist/index.js




function tagName(doc, tag) {
  let name = tag && tag.getChild("TagName");
  return name ? doc.sliceString(name.from, name.to) : "";
}
function elementName$1(doc, tree) {
  let tag = tree && tree.firstChild;
  return !tag || tag.name != "OpenTag" ? "" : tagName(doc, tag);
}
function attrName(doc, tag, pos) {
  let attr = tag && tag.getChildren("Attribute").find(a => a.from <= pos && a.to >= pos);
  let name = attr && attr.getChild("AttributeName");
  return name ? doc.sliceString(name.from, name.to) : "";
}
function findParentElement(tree) {
  for (let cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == "Element") return cur;
  return null;
}
function findLocation(state, pos) {
  var _a;
  let at = (0,language_dist/* syntaxTree */.mv)(state).resolveInner(pos, -1),
    inTag = null;
  for (let cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == "OpenTag" || cur.name == "CloseTag" || cur.name == "SelfClosingTag" || cur.name == "MismatchedCloseTag") inTag = cur;
  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {
    let elt = inTag.parent;
    if (at.name == "TagName") return inTag.name == "CloseTag" || inTag.name == "MismatchedCloseTag" ? {
      type: "closeTag",
      from: at.from,
      context: elt
    } : {
      type: "openTag",
      from: at.from,
      context: findParentElement(elt)
    };
    if (at.name == "AttributeName") return {
      type: "attrName",
      from: at.from,
      context: inTag
    };
    if (at.name == "AttributeValue") return {
      type: "attrValue",
      from: at.from,
      context: inTag
    };
    let before = at == inTag || at.name == "Attribute" ? at.childBefore(pos) : at;
    if ((before === null || before === void 0 ? void 0 : before.name) == "StartTag") return {
      type: "openTag",
      from: pos,
      context: findParentElement(elt)
    };
    if ((before === null || before === void 0 ? void 0 : before.name) == "StartCloseTag" && before.to <= pos) return {
      type: "closeTag",
      from: pos,
      context: elt
    };
    if ((before === null || before === void 0 ? void 0 : before.name) == "Is") return {
      type: "attrValue",
      from: pos,
      context: inTag
    };
    if (before) return {
      type: "attrName",
      from: pos,
      context: inTag
    };
    return null;
  } else if (at.name == "StartCloseTag") {
    return {
      type: "closeTag",
      from: pos,
      context: at.parent
    };
  }
  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;
  if (at.name == "Element" || at.name == "Text" || at.name == "Document") return {
    type: "tag",
    from: pos,
    context: at.name == "Element" ? at : findParentElement(at)
  };
  return null;
}
class dist_Element {
  constructor(spec, attrs, attrValues) {
    this.attrs = attrs;
    this.attrValues = attrValues;
    this.children = [];
    this.name = spec.name;
    this.completion = Object.assign(Object.assign({
      type: "type"
    }, spec.completion || {}), {
      label: this.name
    });
    this.openCompletion = Object.assign(Object.assign({}, this.completion), {
      label: "<" + this.name
    });
    this.closeCompletion = Object.assign(Object.assign({}, this.completion), {
      label: "</" + this.name + ">",
      boost: 2
    });
    this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {
      label: this.name + ">"
    });
    this.text = spec.textContent ? spec.textContent.map(s => ({
      label: s,
      type: "text"
    })) : [];
  }
}
const Identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function attrCompletion(spec) {
  return Object.assign(Object.assign({
    type: "property"
  }, spec.completion || {}), {
    label: spec.name
  });
}
function valueCompletion(spec) {
  return typeof spec == "string" ? {
    label: `"${spec}"`,
    type: "constant"
  } : /^"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {
    label: `"${spec.label}"`
  });
}
/**
Create a completion source for the given schema.
*/
function completeFromSchema(eltSpecs, attrSpecs) {
  let allAttrs = [],
    globalAttrs = [];
  let attrValues = Object.create(null);
  for (let s of attrSpecs) {
    let completion = attrCompletion(s);
    allAttrs.push(completion);
    if (s.global) globalAttrs.push(completion);
    if (s.values) attrValues[s.name] = s.values.map(valueCompletion);
  }
  let allElements = [],
    topElements = [];
  let byName = Object.create(null);
  for (let s of eltSpecs) {
    let attrs = globalAttrs,
      attrVals = attrValues;
    if (s.attributes) attrs = attrs.concat(s.attributes.map(s => {
      if (typeof s == "string") return allAttrs.find(a => a.label == s) || {
        label: s,
        type: "property"
      };
      if (s.values) {
        if (attrVals == attrValues) attrVals = Object.create(attrVals);
        attrVals[s.name] = s.values.map(valueCompletion);
      }
      return attrCompletion(s);
    }));
    let elt = new dist_Element(s, attrs, attrVals);
    byName[elt.name] = elt;
    allElements.push(elt);
    if (s.top) topElements.push(elt);
  }
  if (!topElements.length) topElements = allElements;
  for (let i = 0; i < allElements.length; i++) {
    let s = eltSpecs[i],
      elt = allElements[i];
    if (s.children) {
      for (let ch of s.children) if (byName[ch]) elt.children.push(byName[ch]);
    } else {
      elt.children = allElements;
    }
  }
  return cx => {
    var _a;
    let {
        doc
      } = cx.state,
      loc = findLocation(cx.state, cx.pos);
    if (!loc || loc.type == "tag" && !cx.explicit) return null;
    let {
      type,
      from,
      context
    } = loc;
    if (type == "openTag") {
      let children = topElements;
      let parentName = elementName$1(doc, context);
      if (parentName) {
        let parent = byName[parentName];
        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;
      }
      return {
        from,
        options: children.map(ch => ch.completion),
        validFor: Identifier
      };
    } else if (type == "closeTag") {
      let parentName = elementName$1(doc, context);
      return parentName ? {
        from,
        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == ">" ? 1 : 0),
        options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {
          label: parentName + ">",
          type: "type"
        }],
        validFor: Identifier
      } : null;
    } else if (type == "attrName") {
      let parent = byName[tagName(doc, context)];
      return {
        from,
        options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,
        validFor: Identifier
      };
    } else if (type == "attrValue") {
      let attr = attrName(doc, context, from);
      if (!attr) return null;
      let parent = byName[tagName(doc, context)];
      let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];
      if (!values || !values.length) return null;
      return {
        from,
        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '"' ? 1 : 0),
        options: values,
        validFor: /^"[^"]*"?$/
      };
    } else if (type == "tag") {
      let parentName = elementName$1(doc, context),
        parent = byName[parentName];
      let closing = [],
        last = context && context.lastChild;
      if (parentName && (!last || last.name != "CloseTag" || tagName(doc, last) != parentName)) closing.push(parent ? parent.closeCompletion : {
        label: "</" + parentName + ">",
        type: "type",
        boost: 2
      });
      let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));
      if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {
        let openTag = context.firstChild;
        if (openTag.to > cx.pos - 20 && !/\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(parent.text);
      }
      return {
        from,
        options,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else {
      return null;
    }
  };
}

/**
A language provider based on the [Lezer XML
parser](https://github.com/lezer-parser/xml), extended with
highlighting and indentation information.
*/
const xmlLanguage = /*@__PURE__*/language_dist/* LRLanguage */.bj.define({
  name: "xml",
  parser: /*@__PURE__*/parser.configure({
    props: [/*@__PURE__*/language_dist/* indentNodeProp */.Oh.add({
      Element(context) {
        let closed = /^\s*<\//.test(context.textAfter);
        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
      },
      "OpenTag CloseTag SelfClosingTag"(context) {
        return context.column(context.node.from) + context.unit;
      }
    }), /*@__PURE__*/language_dist/* foldNodeProp */.b_.add({
      Element(subtree) {
        let first = subtree.firstChild,
          last = subtree.lastChild;
        if (!first || first.name != "OpenTag") return null;
        return {
          from: first.to,
          to: last.name == "CloseTag" ? last.from : subtree.to
        };
      }
    }), /*@__PURE__*/language_dist/* bracketMatchingHandle */.Q_.add({
      "OpenTag CloseTag": node => node.getChild("TagName")
    })]
  }),
  languageData: {
    commentTokens: {
      block: {
        open: "<!--",
        close: "-->"
      }
    },
    indentOnInput: /^\s*<\/$/
  }
});
/**
XML language support. Includes schema-based autocompletion when
configured.
*/
function xml(conf = {}) {
  let support = [xmlLanguage.data.of({
    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])
  })];
  if (conf.autoCloseTags !== false) support.push(autoCloseTags);
  return new language_dist/* LanguageSupport */.Yy(xmlLanguage, support);
}
function elementName(doc, tree, max = doc.length) {
  if (!tree) return "";
  let tag = tree.firstChild;
  let name = tag && tag.getChild("TagName");
  return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/view_dist/* EditorView */.Lz.inputHandler.of((view, from, to, text, insertTransaction) => {
  if (view.composing || view.state.readOnly || from != to || text != ">" && text != "/" || !xmlLanguage.isActiveAt(view.state, from, -1)) return false;
  let base = insertTransaction(),
    {
      state
    } = base;
  let closeTags = state.changeByRange(range => {
    var _a, _b, _c;
    let {
      head
    } = range;
    let didType = state.doc.sliceString(head - 1, head) == text;
    let after = (0,language_dist/* syntaxTree */.mv)(state).resolveInner(head, -1),
      name;
    if (didType && text == ">" && after.name == "EndTag") {
      let tag = after.parent;
      if (((_b = (_a = tag.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name = elementName(state.doc, tag.parent, head))) {
        let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert = `</${name}>`;
        return {
          range,
          changes: {
            from: head,
            to,
            insert
          }
        };
      }
    } else if (didType && text == "/" && after.name == "StartCloseTag") {
      let base = after.parent;
      if (after.from == head - 2 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name = elementName(state.doc, base, head))) {
        let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
        let insert = `${name}>`;
        return {
          range: state_dist/* EditorSelection */.OF.cursor(head + insert.length, -1),
          changes: {
            from: head,
            to,
            insert
          }
        };
      }
    }
    return {
      range
    };
  });
  if (closeTags.changes.empty) return false;
  view.dispatch([base, state.update(closeTags, {
    userEvent: "input.complete",
    scrollIntoView: true
  })]);
  return true;
});


/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYwLmp1cHl0ZXItdmlld2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AbGV6ZXIveG1sL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5nLXhtbC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRleHRUcmFja2VyLCBFeHRlcm5hbFRva2VuaXplciwgTFJQYXJzZXIgfSBmcm9tICdAbGV6ZXIvbHInO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgU3RhcnRUYWcgPSAxLFxuICBTdGFydENsb3NlVGFnID0gMixcbiAgTWlzc2luZ0Nsb3NlVGFnID0gMyxcbiAgbWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcgPSA0LFxuICBpbmNvbXBsZXRlU3RhcnRDbG9zZVRhZyA9IDUsXG4gIGNvbW1lbnRDb250ZW50JDEgPSAzNixcbiAgcGlDb250ZW50JDEgPSAzNyxcbiAgY2RhdGFDb250ZW50JDEgPSAzOCxcbiAgRWxlbWVudCA9IDExLFxuICBPcGVuVGFnID0gMTM7XG5cbi8qIEhhbmQtd3JpdHRlbiB0b2tlbml6ZXIgZm9yIFhNTCB0YWcgbWF0Y2hpbmcuICovXG5cbmZ1bmN0aW9uIG5hbWVDaGFyKGNoKSB7XG4gIHJldHVybiBjaCA9PSA0NSB8fCBjaCA9PSA0NiB8fCBjaCA9PSA1OCB8fCBjaCA+PSA2NSAmJiBjaCA8PSA5MCB8fCBjaCA9PSA5NSB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMjIgfHwgY2ggPj0gMTYxO1xufVxuZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICByZXR1cm4gY2ggPT0gOSB8fCBjaCA9PSAxMCB8fCBjaCA9PSAxMyB8fCBjaCA9PSAzMjtcbn1cbmxldCBjYWNoZWROYW1lID0gbnVsbCxcbiAgY2FjaGVkSW5wdXQgPSBudWxsLFxuICBjYWNoZWRQb3MgPSAwO1xuZnVuY3Rpb24gdGFnTmFtZUFmdGVyKGlucHV0LCBvZmZzZXQpIHtcbiAgbGV0IHBvcyA9IGlucHV0LnBvcyArIG9mZnNldDtcbiAgaWYgKGNhY2hlZElucHV0ID09IGlucHV0ICYmIGNhY2hlZFBvcyA9PSBwb3MpIHJldHVybiBjYWNoZWROYW1lO1xuICB3aGlsZSAoaXNTcGFjZShpbnB1dC5wZWVrKG9mZnNldCkpKSBvZmZzZXQrKztcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IG5leHQgPSBpbnB1dC5wZWVrKG9mZnNldCk7XG4gICAgaWYgKCFuYW1lQ2hhcihuZXh0KSkgYnJlYWs7XG4gICAgbmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQpO1xuICAgIG9mZnNldCsrO1xuICB9XG4gIGNhY2hlZElucHV0ID0gaW5wdXQ7XG4gIGNhY2hlZFBvcyA9IHBvcztcbiAgcmV0dXJuIGNhY2hlZE5hbWUgPSBuYW1lIHx8IG51bGw7XG59XG5mdW5jdGlvbiBFbGVtZW50Q29udGV4dChuYW1lLCBwYXJlbnQpIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59XG5jb25zdCBlbGVtZW50Q29udGV4dCA9IG5ldyBDb250ZXh0VHJhY2tlcih7XG4gIHN0YXJ0OiBudWxsLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtLCBzdGFjaywgaW5wdXQpIHtcbiAgICByZXR1cm4gdGVybSA9PSBTdGFydFRhZyA/IG5ldyBFbGVtZW50Q29udGV4dCh0YWdOYW1lQWZ0ZXIoaW5wdXQsIDEpIHx8IFwiXCIsIGNvbnRleHQpIDogY29udGV4dDtcbiAgfSxcbiAgcmVkdWNlKGNvbnRleHQsIHRlcm0pIHtcbiAgICByZXR1cm4gdGVybSA9PSBFbGVtZW50ICYmIGNvbnRleHQgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHQ7XG4gIH0sXG4gIHJldXNlKGNvbnRleHQsIG5vZGUsIF9zdGFjaywgaW5wdXQpIHtcbiAgICBsZXQgdHlwZSA9IG5vZGUudHlwZS5pZDtcbiAgICByZXR1cm4gdHlwZSA9PSBTdGFydFRhZyB8fCB0eXBlID09IE9wZW5UYWcgPyBuZXcgRWxlbWVudENvbnRleHQodGFnTmFtZUFmdGVyKGlucHV0LCAxKSB8fCBcIlwiLCBjb250ZXh0KSA6IGNvbnRleHQ7XG4gIH0sXG4gIHN0cmljdDogZmFsc2Vcbn0pO1xuY29uc3Qgc3RhcnRUYWcgPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBpZiAoaW5wdXQubmV4dCAhPSA2MCAvKiAnPCcgKi8pIHJldHVybjtcbiAgaW5wdXQuYWR2YW5jZSgpO1xuICBpZiAoaW5wdXQubmV4dCA9PSA0NyAvKiAnLycgKi8pIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgbGV0IG5hbWUgPSB0YWdOYW1lQWZ0ZXIoaW5wdXQsIDApO1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKGluY29tcGxldGVTdGFydENsb3NlVGFnKTtcbiAgICBpZiAoc3RhY2suY29udGV4dCAmJiBuYW1lID09IHN0YWNrLmNvbnRleHQubmFtZSkgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0Q2xvc2VUYWcpO1xuICAgIGZvciAobGV0IGN4ID0gc3RhY2suY29udGV4dDsgY3g7IGN4ID0gY3gucGFyZW50KSBpZiAoY3gubmFtZSA9PSBuYW1lKSByZXR1cm4gaW5wdXQuYWNjZXB0VG9rZW4oTWlzc2luZ0Nsb3NlVGFnLCAtMik7XG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obWlzbWF0Y2hlZFN0YXJ0Q2xvc2VUYWcpO1xuICB9IGVsc2UgaWYgKGlucHV0Lm5leHQgIT0gMzMgLyogJyEnICovICYmIGlucHV0Lm5leHQgIT0gNjMgLyogJz8nICovKSB7XG4gICAgcmV0dXJuIGlucHV0LmFjY2VwdFRva2VuKFN0YXJ0VGFnKTtcbiAgfVxufSwge1xuICBjb250ZXh0dWFsOiB0cnVlXG59KTtcbmZ1bmN0aW9uIHNjYW5Ubyh0eXBlLCBlbmQpIHtcbiAgcmV0dXJuIG5ldyBFeHRlcm5hbFRva2VuaXplcihpbnB1dCA9PiB7XG4gICAgbGV0IGxlbiA9IDAsXG4gICAgICBmaXJzdCA9IGVuZC5jaGFyQ29kZUF0KDApO1xuICAgIHNjYW46IGZvciAoOzsgaW5wdXQuYWR2YW5jZSgpLCBsZW4rKykge1xuICAgICAgaWYgKGlucHV0Lm5leHQgPCAwKSBicmVhaztcbiAgICAgIGlmIChpbnB1dC5uZXh0ID09IGZpcnN0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZW5kLmxlbmd0aDsgaSsrKSBpZiAoaW5wdXQucGVlayhpKSAhPSBlbmQuY2hhckNvZGVBdChpKSkgY29udGludWUgc2NhbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZW4pIGlucHV0LmFjY2VwdFRva2VuKHR5cGUpO1xuICB9KTtcbn1cbmNvbnN0IGNvbW1lbnRDb250ZW50ID0gc2NhblRvKGNvbW1lbnRDb250ZW50JDEsIFwiLS0+XCIpO1xuY29uc3QgcGlDb250ZW50ID0gc2NhblRvKHBpQ29udGVudCQxLCBcIj8+XCIpO1xuY29uc3QgY2RhdGFDb250ZW50ID0gc2NhblRvKGNkYXRhQ29udGVudCQxLCBcIl1dPlwiKTtcbmNvbnN0IHhtbEhpZ2hsaWdodGluZyA9IHN0eWxlVGFncyh7XG4gIFRleHQ6IHRhZ3MuY29udGVudCxcbiAgXCJTdGFydFRhZyBTdGFydENsb3NlVGFnIEVuZFRhZyBTZWxmQ2xvc2VFbmRUYWdcIjogdGFncy5hbmdsZUJyYWNrZXQsXG4gIFRhZ05hbWU6IHRhZ3MudGFnTmFtZSxcbiAgXCJNaXNtYXRjaGVkQ2xvc2VUYWcvVGFnTmFtZVwiOiBbdGFncy50YWdOYW1lLCB0YWdzLmludmFsaWRdLFxuICBBdHRyaWJ1dGVOYW1lOiB0YWdzLmF0dHJpYnV0ZU5hbWUsXG4gIEF0dHJpYnV0ZVZhbHVlOiB0YWdzLmF0dHJpYnV0ZVZhbHVlLFxuICBJczogdGFncy5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIFwiRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZVwiOiB0YWdzLmNoYXJhY3RlcixcbiAgQ29tbWVudDogdGFncy5ibG9ja0NvbW1lbnQsXG4gIFByb2Nlc3NpbmdJbnN0OiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbixcbiAgRG9jdHlwZURlY2w6IHRhZ3MuZG9jdW1lbnRNZXRhLFxuICBDZGF0YTogdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIixsT1FPYU9PT3JPeE8nI0NmT3pPcE8nI0NpTyF0T2FPJyNDZ09PT1AnI0NnJyNDZ08he09yTycjQ3JPI1RPdE8nI0NzTyNdT3BPJyNDdE9PT1AnI0RUJyNEVE9PT1AnI0N2JyNDdlFRT2FPT09PT1cnI0N3JyNDd08jZU94Tyw1OVFPT09QLDU5USw1OVFPT09PJyNDeCcjQ3hPI21PcE8sNTlUTyN1TyFiTyw1OVRPT09QJyNDfCcjQ3xPJFRPYU8sNTlSTyRbT3BPJyNDb09PT1AsNTlSLDU5Uk9PT1EnI0N9JyNDfU8kZE9yTyw1OV5PT09QLDU5Xiw1OV5PT09TJyNETycjRE9PJGxPdE8sNTlfT09PUCw1OV8sNTlfTyR0T3BPLDU5YE8kfE9wTyw1OWBPT09QLUU2dC1FNnRPT09XLUU2dS1FNnVPT09QMUcubDFHLmxPT09PLUU2di1FNnZPJVVPIWJPMUcub08lVU8hYk8xRy5vTyVkT3BPJyNDa08lbE8hYk8nI0N5TyV6TyFiTzFHLm9PT09QMUcubzFHLm9PT09QMUcudzFHLndPT09QLUU2ei1FNnpPT09QMUcubTFHLm1PJlZPcE8sNTlaTyZfT3BPLDU5Wk9PT1EtRTZ7LUU2e09PT1AxRy54MUcueE9PT1MtRTZ8LUU2fE9PT1AxRy55MUcueU8mZ09wTzFHLnpPJmdPcE8xRy56T09PUDFHLnoxRy56TyZvTyFiTzcrJFpPJn1PIWJPNyskWk9PT1A3KyRaNyskWk9PT1A3KyRjNyskY08nWU9wTyw1OVZPJ2JPcE8sNTlWTydtTyFiTyw1OWVPT09PLUU2dy1FNndPJ3tPcE8xRy51Tyd7T3BPMUcudU9PT1AxRy51MUcudU8oVE9wTzcrJGZPT09QNyskZjcrJGZPKF1PIWJPPDxHdU9PT1A8PEd1PDxHdU9PT1A8PEd9PDxHfU8nYk9wTzFHLnFPJ2JPcE8xRy5xTyhoTyN0TycjQ25PKHZPJmpPJyNDbk9PT08xRy5xMUcucU8pVU9wTzcrJGFPT09QNyskYTcrJGFPT09QPDxIUTw8SFFPT09QQU49YUFOPWFPT09QQU49aUFOPWlPJ2JPcE83KyRdT09PTzcrJF03KyRdT09PTycjQ3onI0N6TyleTyN0Tyw1OVlPT09PLDU5WSw1OVlPT09PJyNDeycjQ3tPKWxPJmpPLDU5WU9PT1A8PEd7PDxHe09PT088PEd3PDxHd09PT08tRTZ4LUU2eE9PT08xRy50MUcudE9PT08tRTZ5LUU2eVwiLFxuICBzdGF0ZURhdGE6IFwiKXp+T1BRT1NWT1RXT1ZXT1dXT1hXT2lYT3lQTyFRVE8hU1VPfk92Wk94XU9+T15gT3peT35PUFFPUWNPU1ZPVFdPVldPV1dPWFdPeVBPIVFUTyFTVU9+T1JkT35QIVNPdGVPIVBnT35PdWhPIVJqT35PXmxPel5Pfk92Wk94b09+T15xT3peT35PW3ZPYHNPZHdPel5Pfk9SeU9+UCFTT157T3peT35PdGVPIVB9T35PdWhPIVIhUE9+T14hUU96Xk9+T1shU096Xk9+T1shVk9gc09kIVdPel5Pfk9hIVlPel5Pfk96Xk9bbVhgbVhkbVh+T1shVk9gc09kIVdPfk9eIV1Pel5Pfk9bIV9Pel5Pfk9bIWFPel5Pfk9bIWNPYHNPZCFkT3peT35PWyFjT2BzT2QhZE9+T2EhZU96Xk9+T3peT3shZ099IWhPfk96Xk9bbWFgbWFkbWF+T1sha096Xk9+T1shbE96Xk9+T1shbU9gc09kIW5Pfk9XIXFPWCFxT3shc098IXFPfk9XIXRPWCF0T30hc08hTyF0T35PWyF2T3peT35PVyFxT1ghcU97IXlPfCFxT35PVyF0T1ghdE99IXlPIU8hdE9+T1wiLFxuICBnb3RvOiBcIiVjeFBQUFBQUFBQUFB5eVAhUFAhVlBQIWAhalAhcHl5eVAhdiF8I1MkWyRrJHEkdyR9JVRQUFBQJVpYV09SWWJYUk9SWWJfdGBxcnUhVCFVIWJRIWkhWVMhcCFlIWZSIXchb1FkUlJ5YlhTT1JZYlFZT1JtWVFbUFJuW1FfUVFrVmpwX2tyeiFSIVQhWCFaIV4hYCFmIWohb1FyYFF6Y1EhUmxRIVRxUSFYc1EhWnRRIV57USFgIVFRIWYhWVEhaiFdUiFvIWVRdWBTIVVxclUhW3UhVSFiUiFiIVRRIXIhZ1IheCFyUSF1IWhSIXohdVFiUlJ4YlFmVFJ8ZlFpVVIhT2lTWE9ZVGFSYlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIFN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgTWlzc2luZ0Nsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBEb2N1bWVudCBUZXh0IEVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2UgQ2RhdGEgRWxlbWVudCBFbmRUYWcgT3BlblRhZyBUYWdOYW1lIEF0dHJpYnV0ZSBBdHRyaWJ1dGVOYW1lIElzIEF0dHJpYnV0ZVZhbHVlIENsb3NlVGFnIFNlbGZDbG9zZUVuZFRhZyBTZWxmQ2xvc2luZ1RhZyBDb21tZW50IFByb2Nlc3NpbmdJbnN0IE1pc21hdGNoZWRDbG9zZVRhZyBEb2N0eXBlRGVjbFwiLFxuICBtYXhUZXJtOiA1MCxcbiAgY29udGV4dDogZWxlbWVudENvbnRleHQsXG4gIG5vZGVQcm9wczogW1tcImNsb3NlZEJ5XCIsIDEsIFwiU2VsZkNsb3NlRW5kVGFnIEVuZFRhZ1wiLCAxMywgXCJDbG9zZVRhZyBNaXNzaW5nQ2xvc2VUYWdcIl0sIFtcIm9wZW5lZEJ5XCIsIDEyLCBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWdcIiwgMTksIFwiT3BlblRhZ1wiLCAyMCwgXCJTdGFydFRhZ1wiXSwgW1wiaXNvbGF0ZVwiLCAtNiwgMTMsIDE4LCAxOSwgMjEsIDIyLCAyNCwgXCJcIl1dLFxuICBwcm9wU291cmNlczogW3htbEhpZ2hsaWdodGluZ10sXG4gIHNraXBwZWROb2RlczogWzBdLFxuICByZXBlYXROb2RlQ291bnQ6IDksXG4gIHRva2VuRGF0YTogXCIhKXZ+UiFZT1gkcVhZKWlZWilpWl0kcV1eKWlecCRxcHEpaXFyJHFycyp2c3YkcXZ3K2Z3eC9peH0kcX0hTzBbIU8hUCRxIVAhUTJ6IVEhWyRxIVshXTRuIV0hXiRxIV4hXzhVIV8hYCEjdCFgIWEhJGwhYSFiISVkIWIhYyRxIWMhfTRuIX0jUCRxI1AjUSEnVyNRI1IkcSNSI1M0biNTI1QkcSNUI280biNvJVckcSVXJW80biVvJXAkcSVwJmE0biZhJmIkcSZiMXA0bjFwNFUkcTRVNGQ0bjRkNGUkcTRlJElTNG4kSVMkSWAkcSRJYCRJYjRuJEliJEtoJHEkS2glI3Q0biUjdCYveCRxJi94JkV0NG4mRXQmRlYkcSZGVjsnUzRuOydTOzpqOE87Omo7PWApYzwlbD8mciRxPyZyP0FoNG4/QWg/QlkkcT9CWT9NbjRuP01uTyRxaSR6WFZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFhJW5WVlAhT2BPdiVnd3gmVHghXiVnIV4hXyZvIV87J1MlZzsnUzs9YCdXPCVsTyVnUCZZVFZQT3YmVHchXiZUIV87J1MmVDsnUzs9YCZpPCVsTyZUUCZsUDs9YDwlbCZUYCZ0UyFPYE92Jm94OydTJm87J1M7PWAnUTwlbE8mb2AnVFA7PWA8JWwmb2EnWlA7PWA8JWwlZ1gnZVdWUHxXT3InXnJzJlRzdidedyFeJ14hXiFfJ30hXzsnUydeOydTOz1gKGk8JWxPJ15XKFNUfFdPcid9c3YnfXc7J1MnfTsnUzs9YChjPCVsTyd9VyhmUDs9YDwlbCd9WChsUDs9YDwlbCdeaCh2VnxXIU9gT3Iob3JzJm9zdihvd3gnfXg7J1MobzsnUzs9YCldPCVsTyhvaClgUDs9YDwlbChvaSlmUDs9YDwlbCRxbyl0YFZQfFchT2B6VU9YJHFYWSlpWVopaVpdJHFdXilpXnAkcXBxKWlxciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFrK1BWe1lWUCFPYE92JWd3eCZUeCFeJWchXiFfJm8hXzsnUyVnOydTOz1gJ1c8JWxPJWd+K2lhc3QsbiFbIV0tciFjIX0tciNSI1MtciNUI28tciVXJW8tciVwJmEtciZiMXAtcjRVNGQtcjRlJElTLXIkSWAkSWItciRLaCUjdC1yJi94JkV0LXImRlY7J1MtcjsnUzs6ai9jPyZyP0FoLXI/Qlk/TW4tcn4scVEhUSFbLHcjbCNtLVZ+LHpRIVEhWyx3IV0hXi1Rfi1WT1h+fi1ZUiFRIVstYyFjIWktYyNUI1otY34tZlMhUSFbLWMhXSFeLVEhYyFpLWMjVCNaLWN+LXVnfSFPLXIhTyFQLXIhUSFbLXIhWyFdLXIhXSFeL14hYyF9LXIjUiNTLXIjVCNvLXIkfSVPLXIlVyVvLXIlcCZhLXImYjFwLXIxcDRVLXI0VTRkLXI0ZSRJUy1yJElgJEliLXIkSmUkSmctciRLaCUjdC1yJi94JkV0LXImRlY7J1MtcjsnUzs6ai9jPyZyP0FoLXI/Qlk/TW4tcn4vY09Xfn4vZlA7PWA8JWwtcmsvcld9YlZQfFdPcidecnMmVHN2J153IV4nXiFeIV8nfSFfOydTJ147J1M7PWAoaTwlbE8nXmswZVpWUHxXIU9gT3IkcXJzJWdzdiRxd3gnXnh9JHF9IU8xVyFPIV4kcSFeIV8obyFfOydTJHE7J1M7PWApYzwlbE8kcWsxYVpWUHxXIU9gT3IkcXJzJWdzdiRxd3gnXnghXiRxIV4hXyhvIV8hYCRxIWAhYTJTIWE7J1MkcTsnUzs9YCljPCVsTyRxazJfWCFQUVZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFtM1RaVlB8VyFPYE9yJHFycyVnc3YkcXd4J154IV4kcSFeIV8obyFfIWAkcSFgIWEzdiFhOydTJHE7J1M7PWApYzwlbE8kcW00UlhkU1ZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFvNHshUGBTXlFWUHxXIU9gT3IkcXJzJWdzdiRxd3gnXnh9JHF9IU80biFPIVA0biFQIVEkcSFRIVs0biFbIV00biFdIV4kcSFeIV8obyFfIWMkcSFjIX00biF9I1IkcSNSI1M0biNTI1QkcSNUI280biNvJH0kcSR9JU80biVPJVckcSVXJW80biVvJXAkcSVwJmE0biZhJmIkcSZiMXA0bjFwNFU0bjRVNGQ0bjRkNGUkcTRlJElTNG4kSVMkSWAkcSRJYCRJYjRuJEliJEplJHEkSmUkSmc0biRKZyRLaCRxJEtoJSN0NG4lI3QmL3gkcSYveCZFdDRuJkV0JkZWJHEmRlY7J1M0bjsnUzs6ajhPOzpqOz1gKWM8JWw/JnIkcT8mcj9BaDRuP0FoP0JZJHE/Qlk/TW40bj9Nbk8kcW84UlA7PWA8JWw0bmk4XVl8VyFPYE9xKG9xcjh7cnMmb3N2KG93eCd9eCFhKG8hYSFiISNVIWI7J1MobzsnUzs9YCldPCVsTyhvaTlTX3xXIU9gT3Iob3JzJm9zdihvd3gnfXh9KG99IU86UiFPIWYobyFmIWc7ZSFnIX0obyF9I09EaCNPI1cobyNXI1hMcCNYOydTKG87J1M7PWApXTwlbE8ob2k6WVh8VyFPYE9yKG9ycyZvc3Yob3d4J314fShvfSFPOnUhTzsnUyhvOydTOz1gKV08JWxPKG9pO09WIVFQfFchT2BPcihvcnMmb3N2KG93eCd9eDsnUyhvOydTOz1gKV08JWxPKG9pO2xYfFchT2BPcihvcnMmb3N2KG93eCd9eCFxKG8hcSFyPFghcjsnUyhvOydTOz1gKV08JWxPKG9pPGBYfFchT2BPcihvcnMmb3N2KG93eCd9eCFlKG8hZSFmPHshZjsnUyhvOydTOz1gKV08JWxPKG9pPVNYfFchT2BPcihvcnMmb3N2KG93eCd9eCF2KG8hdiF3PW8hdzsnUyhvOydTOz1gKV08JWxPKG9pPXZYfFchT2BPcihvcnMmb3N2KG93eCd9eCF7KG8heyF8PmMhfDsnUyhvOydTOz1gKV08JWxPKG9pPmpYfFchT2BPcihvcnMmb3N2KG93eCd9eCFyKG8hciFzP1YhczsnUyhvOydTOz1gKV08JWxPKG9pP15YfFchT2BPcihvcnMmb3N2KG93eCd9eCFnKG8hZyFoP3khaDsnUyhvOydTOz1gKV08JWxPKG9pQFFZfFchT2BPcj95cnNAcHN2P3l2d0Fbd3hCZHghYD95IWAhYUNyIWE7J1M/eTsnUzs9YERiPCVsTz95YUB1ViFPYE92QHB2eEFbeCFgQHAhYCFhQXkhYTsnU0BwOydTOz1gQl48JWxPQHBQQV9UTyFgQVshYCFhQW4hYTsnU0FbOydTOz1gQXM8JWxPQVtQQXNPaVBQQXZQOz1gPCVsQVthQlFTaVAhT2BPdiZveDsnUyZvOydTOz1gJ1E8JWxPJm9hQmFQOz1gPCVsQHBYQmlYfFdPckJkcnNBW3N2QmR2d0FbdyFgQmQhYCFhQ1UhYTsnU0JkOydTOz1gQ2w8JWxPQmRYQ11UaVB8V09yJ31zdid9dzsnUyd9OydTOz1gKGM8JWxPJ31YQ29QOz1gPCVsQmRpQ3tWaVB8VyFPYE9yKG9ycyZvc3Yob3d4J314OydTKG87J1M7PWApXTwlbE8ob2lEZVA7PWA8JWw/eWlEb1p8VyFPYE9yKG9ycyZvc3Yob3d4J314IWUobyFlIWZFYiFmI1YobyNWI1dJciNXOydTKG87J1M7PWApXTwlbE8ob2lFaVh8VyFPYE9yKG9ycyZvc3Yob3d4J314IWYobyFmIWdGVSFnOydTKG87J1M7PWApXTwlbE8ob2lGXVh8VyFPYE9yKG9ycyZvc3Yob3d4J314IWMobyFjIWRGeCFkOydTKG87J1M7PWApXTwlbE8ob2lHUFh8VyFPYE9yKG9ycyZvc3Yob3d4J314IXYobyF2IXdHbCF3OydTKG87J1M7PWApXTwlbE8ob2lHc1h8VyFPYE9yKG9ycyZvc3Yob3d4J314IWMobyFjIWRIYCFkOydTKG87J1M7PWApXTwlbE8ob2lIZ1h8VyFPYE9yKG9ycyZvc3Yob3d4J314IX0obyF9I09JUyNPOydTKG87J1M7PWApXTwlbE8ob2lJXVZ8VyFPYHlQT3Iob3JzJm9zdihvd3gnfXg7J1MobzsnUzs9YCldPCVsTyhvaUl5WHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjVyhvI1cjWEpmI1g7J1MobzsnUzs9YCldPCVsTyhvaUptWHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjVChvI1QjVUtZI1U7J1MobzsnUzs9YCldPCVsTyhvaUthWHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjaChvI2gjaUt8I2k7J1MobzsnUzs9YCldPCVsTyhvaUxUWHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjVChvI1QjVUhgI1U7J1MobzsnUzs9YCldPCVsTyhvaUx3WHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjYyhvI2MjZE1kI2Q7J1MobzsnUzs9YCldPCVsTyhvaU1rWHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjVihvI1YjV05XI1c7J1MobzsnUzs9YCldPCVsTyhvaU5fWHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjaChvI2gjaU56I2k7J1MobzsnUzs9YCldPCVsTyhvaSEgUlh8VyFPYE9yKG9ycyZvc3Yob3d4J314I20obyNtI24hIG4jbjsnUyhvOydTOz1gKV08JWxPKG9pISB1WHxXIU9gT3Iob3JzJm9zdihvd3gnfXgjZChvI2QjZSEhYiNlOydTKG87J1M7PWApXTwlbE8ob2khIWlYfFchT2BPcihvcnMmb3N2KG93eCd9eCNYKG8jWCNZP3kjWTsnUyhvOydTOz1gKV08JWxPKG9pISNfViFTUHxXIU9gT3Iob3JzJm9zdihvd3gnfXg7J1MobzsnUzs9YCldPCVsTyhvayEkUFhhUVZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFvISR3WFtVVlB8VyFPYE9yJHFycyVnc3YkcXd4J154IV4kcSFeIV8obyFfOydTJHE7J1M7PWApYzwlbE8kcWshJW1aVlB8VyFPYE9yJHFycyVnc3YkcXd4J154IV4kcSFeIV8obyFfIWAkcSFgIWEhJmAhYTsnUyRxOydTOz1gKWM8JWxPJHFrISZrWCFSUVZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXzsnUyRxOydTOz1gKWM8JWxPJHFrISdhWlZQfFchT2BPciRxcnMlZ3N2JHF3eCdeeCFeJHEhXiFfKG8hXyNQJHEjUCNRIShTI1E7J1MkcTsnUzs9YCljPCVsTyRxayEoXVpWUHxXIU9gT3IkcXJzJWdzdiRxd3gnXnghXiRxIV4hXyhvIV8hYCRxIWAhYSEpTyFhOydTJHE7J1M7PWApYzwlbE8kcWshKVpYeFFWUHxXIU9gT3IkcXJzJWdzdiRxd3gnXnghXiRxIV4hXyhvIV87J1MkcTsnUzs9YCljPCVsTyRxXCIsXG4gIHRva2VuaXplcnM6IFtzdGFydFRhZywgY29tbWVudENvbnRlbnQsIHBpQ29udGVudCwgY2RhdGFDb250ZW50LCAwLCAxLCAyLCAzLCA0XSxcbiAgdG9wUnVsZXM6IHtcbiAgICBcIkRvY3VtZW50XCI6IFswLCA2XVxuICB9LFxuICB0b2tlblByZWM6IDBcbn0pO1xuZXhwb3J0IHsgcGFyc2VyIH07IiwiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL3htbCc7XG5pbXBvcnQgeyBzeW50YXhUcmVlLCBMUkxhbmd1YWdlLCBpbmRlbnROb2RlUHJvcCwgZm9sZE5vZGVQcm9wLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIExhbmd1YWdlU3VwcG9ydCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IEVkaXRvclNlbGVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmZ1bmN0aW9uIHRhZ05hbWUoZG9jLCB0YWcpIHtcbiAgbGV0IG5hbWUgPSB0YWcgJiYgdGFnLmdldENoaWxkKFwiVGFnTmFtZVwiKTtcbiAgcmV0dXJuIG5hbWUgPyBkb2Muc2xpY2VTdHJpbmcobmFtZS5mcm9tLCBuYW1lLnRvKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBlbGVtZW50TmFtZSQxKGRvYywgdHJlZSkge1xuICBsZXQgdGFnID0gdHJlZSAmJiB0cmVlLmZpcnN0Q2hpbGQ7XG4gIHJldHVybiAhdGFnIHx8IHRhZy5uYW1lICE9IFwiT3BlblRhZ1wiID8gXCJcIiA6IHRhZ05hbWUoZG9jLCB0YWcpO1xufVxuZnVuY3Rpb24gYXR0ck5hbWUoZG9jLCB0YWcsIHBvcykge1xuICBsZXQgYXR0ciA9IHRhZyAmJiB0YWcuZ2V0Q2hpbGRyZW4oXCJBdHRyaWJ1dGVcIikuZmluZChhID0+IGEuZnJvbSA8PSBwb3MgJiYgYS50byA+PSBwb3MpO1xuICBsZXQgbmFtZSA9IGF0dHIgJiYgYXR0ci5nZXRDaGlsZChcIkF0dHJpYnV0ZU5hbWVcIik7XG4gIHJldHVybiBuYW1lID8gZG9jLnNsaWNlU3RyaW5nKG5hbWUuZnJvbSwgbmFtZS50bykgOiBcIlwiO1xufVxuZnVuY3Rpb24gZmluZFBhcmVudEVsZW1lbnQodHJlZSkge1xuICBmb3IgKGxldCBjdXIgPSB0cmVlICYmIHRyZWUucGFyZW50OyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIGlmIChjdXIubmFtZSA9PSBcIkVsZW1lbnRcIikgcmV0dXJuIGN1cjtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTG9jYXRpb24oc3RhdGUsIHBvcykge1xuICB2YXIgX2E7XG4gIGxldCBhdCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MsIC0xKSxcbiAgICBpblRhZyA9IG51bGw7XG4gIGZvciAobGV0IGN1ciA9IGF0OyAhaW5UYWcgJiYgY3VyLnBhcmVudDsgY3VyID0gY3VyLnBhcmVudCkgaWYgKGN1ci5uYW1lID09IFwiT3BlblRhZ1wiIHx8IGN1ci5uYW1lID09IFwiQ2xvc2VUYWdcIiB8fCBjdXIubmFtZSA9PSBcIlNlbGZDbG9zaW5nVGFnXCIgfHwgY3VyLm5hbWUgPT0gXCJNaXNtYXRjaGVkQ2xvc2VUYWdcIikgaW5UYWcgPSBjdXI7XG4gIGlmIChpblRhZyAmJiAoaW5UYWcudG8gPiBwb3MgfHwgaW5UYWcubGFzdENoaWxkLnR5cGUuaXNFcnJvcikpIHtcbiAgICBsZXQgZWx0ID0gaW5UYWcucGFyZW50O1xuICAgIGlmIChhdC5uYW1lID09IFwiVGFnTmFtZVwiKSByZXR1cm4gaW5UYWcubmFtZSA9PSBcIkNsb3NlVGFnXCIgfHwgaW5UYWcubmFtZSA9PSBcIk1pc21hdGNoZWRDbG9zZVRhZ1wiID8ge1xuICAgICAgdHlwZTogXCJjbG9zZVRhZ1wiLFxuICAgICAgZnJvbTogYXQuZnJvbSxcbiAgICAgIGNvbnRleHQ6IGVsdFxuICAgIH0gOiB7XG4gICAgICB0eXBlOiBcIm9wZW5UYWdcIixcbiAgICAgIGZyb206IGF0LmZyb20sXG4gICAgICBjb250ZXh0OiBmaW5kUGFyZW50RWxlbWVudChlbHQpXG4gICAgfTtcbiAgICBpZiAoYXQubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXR0ck5hbWVcIixcbiAgICAgIGZyb206IGF0LmZyb20sXG4gICAgICBjb250ZXh0OiBpblRhZ1xuICAgIH07XG4gICAgaWYgKGF0Lm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiKSByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhdHRyVmFsdWVcIixcbiAgICAgIGZyb206IGF0LmZyb20sXG4gICAgICBjb250ZXh0OiBpblRhZ1xuICAgIH07XG4gICAgbGV0IGJlZm9yZSA9IGF0ID09IGluVGFnIHx8IGF0Lm5hbWUgPT0gXCJBdHRyaWJ1dGVcIiA/IGF0LmNoaWxkQmVmb3JlKHBvcykgOiBhdDtcbiAgICBpZiAoKGJlZm9yZSA9PT0gbnVsbCB8fCBiZWZvcmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJlZm9yZS5uYW1lKSA9PSBcIlN0YXJ0VGFnXCIpIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wZW5UYWdcIixcbiAgICAgIGZyb206IHBvcyxcbiAgICAgIGNvbnRleHQ6IGZpbmRQYXJlbnRFbGVtZW50KGVsdClcbiAgICB9O1xuICAgIGlmICgoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlLm5hbWUpID09IFwiU3RhcnRDbG9zZVRhZ1wiICYmIGJlZm9yZS50byA8PSBwb3MpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNsb3NlVGFnXCIsXG4gICAgICBmcm9tOiBwb3MsXG4gICAgICBjb250ZXh0OiBlbHRcbiAgICB9O1xuICAgIGlmICgoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmVmb3JlLm5hbWUpID09IFwiSXNcIikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXR0clZhbHVlXCIsXG4gICAgICBmcm9tOiBwb3MsXG4gICAgICBjb250ZXh0OiBpblRhZ1xuICAgIH07XG4gICAgaWYgKGJlZm9yZSkgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXR0ck5hbWVcIixcbiAgICAgIGZyb206IHBvcyxcbiAgICAgIGNvbnRleHQ6IGluVGFnXG4gICAgfTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChhdC5uYW1lID09IFwiU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2xvc2VUYWdcIixcbiAgICAgIGZyb206IHBvcyxcbiAgICAgIGNvbnRleHQ6IGF0LnBhcmVudFxuICAgIH07XG4gIH1cbiAgd2hpbGUgKGF0LnBhcmVudCAmJiBhdC50byA9PSBwb3MgJiYgISgoX2EgPSBhdC5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLmlzRXJyb3IpKSBhdCA9IGF0LnBhcmVudDtcbiAgaWYgKGF0Lm5hbWUgPT0gXCJFbGVtZW50XCIgfHwgYXQubmFtZSA9PSBcIlRleHRcIiB8fCBhdC5uYW1lID09IFwiRG9jdW1lbnRcIikgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRhZ1wiLFxuICAgIGZyb206IHBvcyxcbiAgICBjb250ZXh0OiBhdC5uYW1lID09IFwiRWxlbWVudFwiID8gYXQgOiBmaW5kUGFyZW50RWxlbWVudChhdClcbiAgfTtcbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioc3BlYywgYXR0cnMsIGF0dHJWYWx1ZXMpIHtcbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgdGhpcy5hdHRyVmFsdWVzID0gYXR0clZhbHVlcztcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5uYW1lID0gc3BlYy5uYW1lO1xuICAgIHRoaXMuY29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgICB0eXBlOiBcInR5cGVcIlxuICAgIH0sIHNwZWMuY29tcGxldGlvbiB8fCB7fSksIHtcbiAgICAgIGxhYmVsOiB0aGlzLm5hbWVcbiAgICB9KTtcbiAgICB0aGlzLm9wZW5Db21wbGV0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbXBsZXRpb24pLCB7XG4gICAgICBsYWJlbDogXCI8XCIgKyB0aGlzLm5hbWVcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlQ29tcGxldGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb21wbGV0aW9uKSwge1xuICAgICAgbGFiZWw6IFwiPC9cIiArIHRoaXMubmFtZSArIFwiPlwiLFxuICAgICAgYm9vc3Q6IDJcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlTmFtZUNvbXBsZXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29tcGxldGlvbiksIHtcbiAgICAgIGxhYmVsOiB0aGlzLm5hbWUgKyBcIj5cIlxuICAgIH0pO1xuICAgIHRoaXMudGV4dCA9IHNwZWMudGV4dENvbnRlbnQgPyBzcGVjLnRleHRDb250ZW50Lm1hcChzID0+ICh7XG4gICAgICBsYWJlbDogcyxcbiAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgfSkpIDogW107XG4gIH1cbn1cbmNvbnN0IElkZW50aWZpZXIgPSAvXls6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokLztcbmZ1bmN0aW9uIGF0dHJDb21wbGV0aW9uKHNwZWMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7XG4gICAgdHlwZTogXCJwcm9wZXJ0eVwiXG4gIH0sIHNwZWMuY29tcGxldGlvbiB8fCB7fSksIHtcbiAgICBsYWJlbDogc3BlYy5uYW1lXG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsdWVDb21wbGV0aW9uKHNwZWMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgPyB7XG4gICAgbGFiZWw6IGBcIiR7c3BlY31cImAsXG4gICAgdHlwZTogXCJjb25zdGFudFwiXG4gIH0gOiAvXlwiLy50ZXN0KHNwZWMubGFiZWwpID8gc3BlYyA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3BlYyksIHtcbiAgICBsYWJlbDogYFwiJHtzcGVjLmxhYmVsfVwiYFxuICB9KTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tcGxldGlvbiBzb3VyY2UgZm9yIHRoZSBnaXZlbiBzY2hlbWEuXG4qL1xuZnVuY3Rpb24gY29tcGxldGVGcm9tU2NoZW1hKGVsdFNwZWNzLCBhdHRyU3BlY3MpIHtcbiAgbGV0IGFsbEF0dHJzID0gW10sXG4gICAgZ2xvYmFsQXR0cnMgPSBbXTtcbiAgbGV0IGF0dHJWYWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBzIG9mIGF0dHJTcGVjcykge1xuICAgIGxldCBjb21wbGV0aW9uID0gYXR0ckNvbXBsZXRpb24ocyk7XG4gICAgYWxsQXR0cnMucHVzaChjb21wbGV0aW9uKTtcbiAgICBpZiAocy5nbG9iYWwpIGdsb2JhbEF0dHJzLnB1c2goY29tcGxldGlvbik7XG4gICAgaWYgKHMudmFsdWVzKSBhdHRyVmFsdWVzW3MubmFtZV0gPSBzLnZhbHVlcy5tYXAodmFsdWVDb21wbGV0aW9uKTtcbiAgfVxuICBsZXQgYWxsRWxlbWVudHMgPSBbXSxcbiAgICB0b3BFbGVtZW50cyA9IFtdO1xuICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChsZXQgcyBvZiBlbHRTcGVjcykge1xuICAgIGxldCBhdHRycyA9IGdsb2JhbEF0dHJzLFxuICAgICAgYXR0clZhbHMgPSBhdHRyVmFsdWVzO1xuICAgIGlmIChzLmF0dHJpYnV0ZXMpIGF0dHJzID0gYXR0cnMuY29uY2F0KHMuYXR0cmlidXRlcy5tYXAocyA9PiB7XG4gICAgICBpZiAodHlwZW9mIHMgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGFsbEF0dHJzLmZpbmQoYSA9PiBhLmxhYmVsID09IHMpIHx8IHtcbiAgICAgICAgbGFiZWw6IHMsXG4gICAgICAgIHR5cGU6IFwicHJvcGVydHlcIlxuICAgICAgfTtcbiAgICAgIGlmIChzLnZhbHVlcykge1xuICAgICAgICBpZiAoYXR0clZhbHMgPT0gYXR0clZhbHVlcykgYXR0clZhbHMgPSBPYmplY3QuY3JlYXRlKGF0dHJWYWxzKTtcbiAgICAgICAgYXR0clZhbHNbcy5uYW1lXSA9IHMudmFsdWVzLm1hcCh2YWx1ZUNvbXBsZXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJDb21wbGV0aW9uKHMpO1xuICAgIH0pKTtcbiAgICBsZXQgZWx0ID0gbmV3IEVsZW1lbnQocywgYXR0cnMsIGF0dHJWYWxzKTtcbiAgICBieU5hbWVbZWx0Lm5hbWVdID0gZWx0O1xuICAgIGFsbEVsZW1lbnRzLnB1c2goZWx0KTtcbiAgICBpZiAocy50b3ApIHRvcEVsZW1lbnRzLnB1c2goZWx0KTtcbiAgfVxuICBpZiAoIXRvcEVsZW1lbnRzLmxlbmd0aCkgdG9wRWxlbWVudHMgPSBhbGxFbGVtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBzID0gZWx0U3BlY3NbaV0sXG4gICAgICBlbHQgPSBhbGxFbGVtZW50c1tpXTtcbiAgICBpZiAocy5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgY2ggb2Ygcy5jaGlsZHJlbikgaWYgKGJ5TmFtZVtjaF0pIGVsdC5jaGlsZHJlbi5wdXNoKGJ5TmFtZVtjaF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbHQuY2hpbGRyZW4gPSBhbGxFbGVtZW50cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN4ID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHtcbiAgICAgICAgZG9jXG4gICAgICB9ID0gY3guc3RhdGUsXG4gICAgICBsb2MgPSBmaW5kTG9jYXRpb24oY3guc3RhdGUsIGN4LnBvcyk7XG4gICAgaWYgKCFsb2MgfHwgbG9jLnR5cGUgPT0gXCJ0YWdcIiAmJiAhY3guZXhwbGljaXQpIHJldHVybiBudWxsO1xuICAgIGxldCB7XG4gICAgICB0eXBlLFxuICAgICAgZnJvbSxcbiAgICAgIGNvbnRleHRcbiAgICB9ID0gbG9jO1xuICAgIGlmICh0eXBlID09IFwib3BlblRhZ1wiKSB7XG4gICAgICBsZXQgY2hpbGRyZW4gPSB0b3BFbGVtZW50cztcbiAgICAgIGxldCBwYXJlbnROYW1lID0gZWxlbWVudE5hbWUkMShkb2MsIGNvbnRleHQpO1xuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGJ5TmFtZVtwYXJlbnROYW1lXTtcbiAgICAgICAgY2hpbGRyZW4gPSAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuKSB8fCBhbGxFbGVtZW50cztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIG9wdGlvbnM6IGNoaWxkcmVuLm1hcChjaCA9PiBjaC5jb21wbGV0aW9uKSxcbiAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VUYWdcIikge1xuICAgICAgbGV0IHBhcmVudE5hbWUgPSBlbGVtZW50TmFtZSQxKGRvYywgY29udGV4dCk7XG4gICAgICByZXR1cm4gcGFyZW50TmFtZSA/IHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG86IGN4LnBvcyArIChkb2Muc2xpY2VTdHJpbmcoY3gucG9zLCBjeC5wb3MgKyAxKSA9PSBcIj5cIiA/IDEgOiAwKSxcbiAgICAgICAgb3B0aW9uczogWygoX2EgPSBieU5hbWVbcGFyZW50TmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZU5hbWVDb21wbGV0aW9uKSB8fCB7XG4gICAgICAgICAgbGFiZWw6IHBhcmVudE5hbWUgKyBcIj5cIixcbiAgICAgICAgICB0eXBlOiBcInR5cGVcIlxuICAgICAgICB9XSxcbiAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICAgIH0gOiBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImF0dHJOYW1lXCIpIHtcbiAgICAgIGxldCBwYXJlbnQgPSBieU5hbWVbdGFnTmFtZShkb2MsIGNvbnRleHQpXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIG9wdGlvbnM6IChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYXR0cnMpIHx8IGdsb2JhbEF0dHJzLFxuICAgICAgICB2YWxpZEZvcjogSWRlbnRpZmllclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJhdHRyVmFsdWVcIikge1xuICAgICAgbGV0IGF0dHIgPSBhdHRyTmFtZShkb2MsIGNvbnRleHQsIGZyb20pO1xuICAgICAgaWYgKCFhdHRyKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBwYXJlbnQgPSBieU5hbWVbdGFnTmFtZShkb2MsIGNvbnRleHQpXTtcbiAgICAgIGxldCB2YWx1ZXMgPSAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hdHRyVmFsdWVzKSB8fCBhdHRyVmFsdWVzKVthdHRyXTtcbiAgICAgIGlmICghdmFsdWVzIHx8ICF2YWx1ZXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvOiBjeC5wb3MgKyAoZG9jLnNsaWNlU3RyaW5nKGN4LnBvcywgY3gucG9zICsgMSkgPT0gJ1wiJyA/IDEgOiAwKSxcbiAgICAgICAgb3B0aW9uczogdmFsdWVzLFxuICAgICAgICB2YWxpZEZvcjogL15cIlteXCJdKlwiPyQvXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInRhZ1wiKSB7XG4gICAgICBsZXQgcGFyZW50TmFtZSA9IGVsZW1lbnROYW1lJDEoZG9jLCBjb250ZXh0KSxcbiAgICAgICAgcGFyZW50ID0gYnlOYW1lW3BhcmVudE5hbWVdO1xuICAgICAgbGV0IGNsb3NpbmcgPSBbXSxcbiAgICAgICAgbGFzdCA9IGNvbnRleHQgJiYgY29udGV4dC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAocGFyZW50TmFtZSAmJiAoIWxhc3QgfHwgbGFzdC5uYW1lICE9IFwiQ2xvc2VUYWdcIiB8fCB0YWdOYW1lKGRvYywgbGFzdCkgIT0gcGFyZW50TmFtZSkpIGNsb3NpbmcucHVzaChwYXJlbnQgPyBwYXJlbnQuY2xvc2VDb21wbGV0aW9uIDoge1xuICAgICAgICBsYWJlbDogXCI8L1wiICsgcGFyZW50TmFtZSArIFwiPlwiLFxuICAgICAgICB0eXBlOiBcInR5cGVcIixcbiAgICAgICAgYm9vc3Q6IDJcbiAgICAgIH0pO1xuICAgICAgbGV0IG9wdGlvbnMgPSBjbG9zaW5nLmNvbmNhdCgoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbikgfHwgKGNvbnRleHQgPyBhbGxFbGVtZW50cyA6IHRvcEVsZW1lbnRzKSkubWFwKGUgPT4gZS5vcGVuQ29tcGxldGlvbikpO1xuICAgICAgaWYgKGNvbnRleHQgJiYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50ZXh0Lmxlbmd0aCkpIHtcbiAgICAgICAgbGV0IG9wZW5UYWcgPSBjb250ZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChvcGVuVGFnLnRvID4gY3gucG9zIC0gMjAgJiYgIS9cXFMvLnRlc3QoY3guc3RhdGUuc2xpY2VEb2Mob3BlblRhZy50bywgY3gucG9zKSkpIG9wdGlvbnMgPSBvcHRpb25zLmNvbmNhdChwYXJlbnQudGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICB2YWxpZEZvcjogL148XFwvP1s6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokL1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBYTUxcbnBhcnNlcl0oaHR0cHM6Ly9naXRodWIuY29tL2xlemVyLXBhcnNlci94bWwpLCBleHRlbmRlZCB3aXRoXG5oaWdobGlnaHRpbmcgYW5kIGluZGVudGF0aW9uIGluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IHhtbExhbmd1YWdlID0gLypAX19QVVJFX18qL0xSTGFuZ3VhZ2UuZGVmaW5lKHtcbiAgbmFtZTogXCJ4bWxcIixcbiAgcGFyc2VyOiAvKkBfX1BVUkVfXyovcGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgcHJvcHM6IFsvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgIEVsZW1lbnQoY29udGV4dCkge1xuICAgICAgICBsZXQgY2xvc2VkID0gL15cXHMqPFxcLy8udGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmxpbmVJbmRlbnQoY29udGV4dC5ub2RlLmZyb20pICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQpO1xuICAgICAgfSxcbiAgICAgIFwiT3BlblRhZyBDbG9zZVRhZyBTZWxmQ2xvc2luZ1RhZ1wiKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29sdW1uKGNvbnRleHQubm9kZS5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgIH1cbiAgICB9KSwgLypAX19QVVJFX18qL2ZvbGROb2RlUHJvcC5hZGQoe1xuICAgICAgRWxlbWVudChzdWJ0cmVlKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IHN1YnRyZWUuZmlyc3RDaGlsZCxcbiAgICAgICAgICBsYXN0ID0gc3VidHJlZS5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghZmlyc3QgfHwgZmlyc3QubmFtZSAhPSBcIk9wZW5UYWdcIikgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogZmlyc3QudG8sXG4gICAgICAgICAgdG86IGxhc3QubmFtZSA9PSBcIkNsb3NlVGFnXCIgPyBsYXN0LmZyb20gOiBzdWJ0cmVlLnRvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSksIC8qQF9fUFVSRV9fKi9icmFja2V0TWF0Y2hpbmdIYW5kbGUuYWRkKHtcbiAgICAgIFwiT3BlblRhZyBDbG9zZVRhZ1wiOiBub2RlID0+IG5vZGUuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpXG4gICAgfSldXG4gIH0pLFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7XG4gICAgICBibG9jazoge1xuICAgICAgICBvcGVuOiBcIjwhLS1cIixcbiAgICAgICAgY2xvc2U6IFwiLS0+XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGluZGVudE9uSW5wdXQ6IC9eXFxzKjxcXC8kL1xuICB9XG59KTtcbi8qKlxuWE1MIGxhbmd1YWdlIHN1cHBvcnQuIEluY2x1ZGVzIHNjaGVtYS1iYXNlZCBhdXRvY29tcGxldGlvbiB3aGVuXG5jb25maWd1cmVkLlxuKi9cbmZ1bmN0aW9uIHhtbChjb25mID0ge30pIHtcbiAgbGV0IHN1cHBvcnQgPSBbeG1sTGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgYXV0b2NvbXBsZXRlOiBjb21wbGV0ZUZyb21TY2hlbWEoY29uZi5lbGVtZW50cyB8fCBbXSwgY29uZi5hdHRyaWJ1dGVzIHx8IFtdKVxuICB9KV07XG4gIGlmIChjb25mLmF1dG9DbG9zZVRhZ3MgIT09IGZhbHNlKSBzdXBwb3J0LnB1c2goYXV0b0Nsb3NlVGFncyk7XG4gIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KHhtbExhbmd1YWdlLCBzdXBwb3J0KTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnROYW1lKGRvYywgdHJlZSwgbWF4ID0gZG9jLmxlbmd0aCkge1xuICBpZiAoIXRyZWUpIHJldHVybiBcIlwiO1xuICBsZXQgdGFnID0gdHJlZS5maXJzdENoaWxkO1xuICBsZXQgbmFtZSA9IHRhZyAmJiB0YWcuZ2V0Q2hpbGQoXCJUYWdOYW1lXCIpO1xuICByZXR1cm4gbmFtZSA/IGRvYy5zbGljZVN0cmluZyhuYW1lLmZyb20sIE1hdGgubWluKG5hbWUudG8sIG1heCkpIDogXCJcIjtcbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IGluc2VydCBjbG9zZSB0YWdzIHdoZW4gYSBgPmAgb3JcbmAvYCBpcyB0eXBlZC5cbiovXG5jb25zdCBhdXRvQ2xvc2VUYWdzID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgdGV4dCwgaW5zZXJ0VHJhbnNhY3Rpb24pID0+IHtcbiAgaWYgKHZpZXcuY29tcG9zaW5nIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHwgZnJvbSAhPSB0byB8fCB0ZXh0ICE9IFwiPlwiICYmIHRleHQgIT0gXCIvXCIgfHwgIXhtbExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKSByZXR1cm4gZmFsc2U7XG4gIGxldCBiYXNlID0gaW5zZXJ0VHJhbnNhY3Rpb24oKSxcbiAgICB7XG4gICAgICBzdGF0ZVxuICAgIH0gPSBiYXNlO1xuICBsZXQgY2xvc2VUYWdzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgbGV0IHtcbiAgICAgIGhlYWRcbiAgICB9ID0gcmFuZ2U7XG4gICAgbGV0IGRpZFR5cGUgPSBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCAtIDEsIGhlYWQpID09IHRleHQ7XG4gICAgbGV0IGFmdGVyID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGhlYWQsIC0xKSxcbiAgICAgIG5hbWU7XG4gICAgaWYgKGRpZFR5cGUgJiYgdGV4dCA9PSBcIj5cIiAmJiBhZnRlci5uYW1lID09IFwiRW5kVGFnXCIpIHtcbiAgICAgIGxldCB0YWcgPSBhZnRlci5wYXJlbnQ7XG4gICAgICBpZiAoKChfYiA9IChfYSA9IHRhZy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiYgKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZS5kb2MsIHRhZy5wYXJlbnQsIGhlYWQpKSkge1xuICAgICAgICBsZXQgdG8gPSBoZWFkICsgKHN0YXRlLmRvYy5zbGljZVN0cmluZyhoZWFkLCBoZWFkICsgMSkgPT09IFwiPlwiID8gMSA6IDApO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gYDwvJHtuYW1lfT5gO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIGZyb206IGhlYWQsXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIGluc2VydFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpZFR5cGUgJiYgdGV4dCA9PSBcIi9cIiAmJiBhZnRlci5uYW1lID09IFwiU3RhcnRDbG9zZVRhZ1wiKSB7XG4gICAgICBsZXQgYmFzZSA9IGFmdGVyLnBhcmVudDtcbiAgICAgIGlmIChhZnRlci5mcm9tID09IGhlYWQgLSAyICYmICgoX2MgPSBiYXNlLmxhc3RDaGlsZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm5hbWUpICE9IFwiQ2xvc2VUYWdcIiAmJiAobmFtZSA9IGVsZW1lbnROYW1lKHN0YXRlLmRvYywgYmFzZSwgaGVhZCkpKSB7XG4gICAgICAgIGxldCB0byA9IGhlYWQgKyAoc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGhlYWQsIGhlYWQgKyAxKSA9PT0gXCI+XCIgPyAxIDogMCk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBgJHtuYW1lfT5gO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQgKyBpbnNlcnQubGVuZ3RoLCAtMSksXG4gICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgZnJvbTogaGVhZCxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgaW5zZXJ0XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2VcbiAgICB9O1xuICB9KTtcbiAgaWYgKGNsb3NlVGFncy5jaGFuZ2VzLmVtcHR5KSByZXR1cm4gZmFsc2U7XG4gIHZpZXcuZGlzcGF0Y2goW2Jhc2UsIHN0YXRlLnVwZGF0ZShjbG9zZVRhZ3MsIHtcbiAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIixcbiAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICB9KV0pO1xuICByZXR1cm4gdHJ1ZTtcbn0pO1xuZXhwb3J0IHsgYXV0b0Nsb3NlVGFncywgY29tcGxldGVGcm9tU2NoZW1hLCB4bWwsIHhtbExhbmd1YWdlIH07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==