"use strict";
(self["webpackChunk_datalayer_jupyter_viewer"] = self["webpackChunk_datalayer_jupyter_viewer"] || []).push([[1382],{

/***/ 31382
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clojure: () => (/* binding */ clojure)
/* harmony export */ });
var atoms = ["false", "nil", "true"];
var specialForms = [".", "catch", "def", "do", "if", "monitor-enter", "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*", "*allow-unresolved-vars*", "*assert*", "*clojure-version*", "*command-line-args*", "*compile-files*", "*compile-path*", "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e", "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*", "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*", "*print-level*", "*print-meta*", "*print-namespace-maps*", "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*", "*suppress-read*", "*unchecked-math*", "*use-context-classloader*", "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'", "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode", "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=", "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec", "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch", "agent", "agent-error", "agent-errors", "aget", "alength", "alias", "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors", "and", "any?", "apply", "areduce", "array-map", "as->", "aset", "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float", "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!", "assoc-in", "associative?", "atom", "await", "await-for", "await1", "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and", "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set", "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean", "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*", "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes", "bytes?", "case", "cast", "cat", "char", "char-array", "char-escape-string", "char-name-string", "char?", "chars", "chunk", "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next", "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors", "clojure-version", "coll?", "comment", "commute", "comp", "comparator", "compare", "compare-and-set!", "compile", "complement", "completing", "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons", "constantly", "construct-proxy", "contains?", "count", "counted?", "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?", "declare", "dedupe", "default-data-readers", "definline", "definterface", "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce", "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?", "deliver", "denominator", "deref", "derive", "descendants", "destructure", "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall", "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array", "double?", "doubles", "drop", "drop-last", "drop-while", "eduction", "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq", "error-handler", "error-mode", "eval", "even?", "every-pred", "every?", "ex-data", "ex-info", "extend", "extend-protocol", "extend-type", "extenders", "extends?", "false?", "ffirst", "file-seq", "filter", "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl", "find-protocol-method", "find-var", "first", "flatten", "float", "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil", "for", "force", "format", "frequencies", "future", "future-call", "future-cancel", "future-cancelled?", "future-done?", "future?", "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method", "get-proxy-class", "get-thread-bindings", "get-validator", "group-by", "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll", "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity", "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'", "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?", "int", "int-array", "int?", "integer?", "interleave", "intern", "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate", "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword", "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq", "list", "list*", "list?", "load", "load-file", "load-reader", "load-string", "loaded-libs", "locking", "long", "long-array", "longs", "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy", "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max", "max-key", "memfn", "memoize", "merge", "merge-with", "meta", "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod", "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?", "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?", "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports", "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers", "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest", "num", "number?", "numerator", "object-array", "odd?", "or", "parents", "partial", "partition", "partition-all", "partition-by", "pcalls", "peek", "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?", "pos?", "pr", "pr-str", "prefer-method", "prefers", "primitives-classnames", "print", "print-ctor", "print-dup", "print-method", "print-simple", "print-str", "printf", "println", "println-str", "prn", "prn-str", "promise", "proxy", "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super", "push-thread-bindings", "pvalues", "qualified-ident?", "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int", "rand-nth", "random-sample", "range", "ratio?", "rational?", "rationalize", "re-find", "re-groups", "re-matcher", "re-matches", "re-pattern", "re-seq", "read", "read-line", "read-string", "reader-conditional", "reader-conditional?", "realized?", "record?", "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref", "ref-history-count", "ref-max-history", "ref-min-history", "ref-set", "refer", "refer-clojure", "reify", "release-pending-sends", "rem", "remove", "remove-all-methods", "remove-method", "remove-ns", "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require", "reset!", "reset-meta!", "reset-vals!", "resolve", "rest", "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq", "rsubseq", "run!", "satisfies?", "second", "select-keys", "send", "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence", "sequential?", "set", "set-agent-send-executor!", "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!", "set-validator!", "set?", "short", "short-array", "shorts", "shuffle", "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?", "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort", "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by", "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str", "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers", "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal", "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test", "the-ns", "thread-bound?", "time", "to-array", "to-array-2d", "trampoline", "transduce", "transient", "tree-seq", "true?", "type", "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char", "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int", "unchecked-double", "unchecked-float", "unchecked-inc", "unchecked-inc-int", "unchecked-int", "unchecked-long", "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate", "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short", "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote", "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update", "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals", "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of", "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when", "when-first", "when-let", "when-not", "when-some", "while", "with-bindings", "with-bindings*", "with-in-str", "with-loading-context", "with-local-vars", "with-meta", "with-open", "with-out-str", "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?", "zipmap"];
var haveBodyParameter = ["->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment", "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod", "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype", "do", "doseq", "dotimes", "doto", "extend", "extend-protocol", "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some", "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map", "some->", "some->>", "try", "when", "when-first", "when-let", "when-not", "when-some", "while", "with-bindings", "with-bindings*", "with-in-str", "with-loading-context", "with-local-vars", "with-meta", "with-open", "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];
var atom = createLookupMap(atoms);
var specialForm = createLookupMap(specialForms);
var coreSymbol = createLookupMap(coreSymbols);
var hasBodyParameter = createLookupMap(haveBodyParameter);
var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

// simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*/
// simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
// qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;
function base(stream, state) {
  if (stream.eatSpace() || stream.eat(",")) return ["space", null];
  if (stream.match(numberLiteral)) return [null, "number"];
  if (stream.match(characterLiteral)) return [null, "string.special"];
  if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
  if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
  if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
  if (stream.eat(/^;/)) {
    stream.skipToEnd();
    return ["space", "comment"];
  }
  if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];
  var matches = stream.match(qualifiedSymbol);
  var symbol = matches && matches[0];
  if (!symbol) {
    // advance stream by at least one character so we don't get stuck.
    stream.next();
    stream.eatWhile(function (c) {
      return !is(c, delimiter);
    });
    return [null, "error"];
  }
  if (symbol === "comment" && state.lastToken === "(") return (state.tokenize = inComment)(stream, state);
  if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
  if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
  if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

  return ["symbol", "variable"];
}
function inString(stream, state) {
  var escaped = false,
    next;
  while (next = stream.next()) {
    if (next === "\"" && !escaped) {
      state.tokenize = base;
      break;
    }
    escaped = !escaped && next === "\\";
  }
  return [null, "string"];
}
function inComment(stream, state) {
  var parenthesisCount = 1;
  var next;
  while (next = stream.next()) {
    if (next === ")") parenthesisCount--;
    if (next === "(") parenthesisCount++;
    if (parenthesisCount === 0) {
      stream.backUp(1);
      state.tokenize = base;
      break;
    }
  }
  return ["space", "comment"];
}
function createLookupMap(words) {
  var obj = {};
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
function is(value, test) {
  if (test instanceof RegExp) return test.test(value);
  if (test instanceof Object) return test.propertyIsEnumerable(value);
}
const clojure = {
  name: "clojure",
  startState: function () {
    return {
      ctx: {
        prev: null,
        start: 0,
        indentTo: 0
      },
      lastToken: null,
      tokenize: base
    };
  },
  token: function (stream, state) {
    if (stream.sol() && typeof state.ctx.indentTo !== "number") state.ctx.indentTo = state.ctx.start + 1;
    var typeStylePair = state.tokenize(stream, state);
    var type = typeStylePair[0];
    var style = typeStylePair[1];
    var current = stream.current();
    if (type !== "space") {
      if (state.lastToken === "(" && state.ctx.indentTo === null) {
        if (type === "symbol" && is(current, hasBodyParameter)) state.ctx.indentTo = state.ctx.start + stream.indentUnit;else state.ctx.indentTo = "next";
      } else if (state.ctx.indentTo === "next") {
        state.ctx.indentTo = stream.column();
      }
      state.lastToken = current;
    }
    if (type === "open") state.ctx = {
      prev: state.ctx,
      start: stream.column(),
      indentTo: null
    };else if (type === "close") state.ctx = state.ctx.prev || state.ctx;
    return style;
  },
  indent: function (state) {
    var i = state.ctx.indentTo;
    return typeof i === "number" ? i : state.ctx.start + 1;
  },
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", '"']
    },
    commentTokens: {
      line: ";;"
    },
    autocomplete: [].concat(atoms, specialForms, coreSymbols)
  }
};

/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4Mi5qdXB5dGVyLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRhdGFsYXllci9qdXB5dGVyLXZpZXdlci8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9jbG9qdXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhdG9tcyA9IFtcImZhbHNlXCIsIFwibmlsXCIsIFwidHJ1ZVwiXTtcbnZhciBzcGVjaWFsRm9ybXMgPSBbXCIuXCIsIFwiY2F0Y2hcIiwgXCJkZWZcIiwgXCJkb1wiLCBcImlmXCIsIFwibW9uaXRvci1lbnRlclwiLCBcIm1vbml0b3ItZXhpdFwiLCBcIm5ld1wiLCBcInF1b3RlXCIsIFwicmVjdXJcIiwgXCJzZXQhXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIl07XG52YXIgY29yZVN5bWJvbHMgPSBbXCIqXCIsIFwiKidcIiwgXCIqMVwiLCBcIioyXCIsIFwiKjNcIiwgXCIqYWdlbnQqXCIsIFwiKmFsbG93LXVucmVzb2x2ZWQtdmFycypcIiwgXCIqYXNzZXJ0KlwiLCBcIipjbG9qdXJlLXZlcnNpb24qXCIsIFwiKmNvbW1hbmQtbGluZS1hcmdzKlwiLCBcIipjb21waWxlLWZpbGVzKlwiLCBcIipjb21waWxlLXBhdGgqXCIsIFwiKmNvbXBpbGVyLW9wdGlvbnMqXCIsIFwiKmRhdGEtcmVhZGVycypcIiwgXCIqZGVmYXVsdC1kYXRhLXJlYWRlci1mbipcIiwgXCIqZVwiLCBcIiplcnIqXCIsIFwiKmZpbGUqXCIsIFwiKmZsdXNoLW9uLW5ld2xpbmUqXCIsIFwiKmZuLWxvYWRlcipcIiwgXCIqaW4qXCIsIFwiKm1hdGgtY29udGV4dCpcIiwgXCIqbnMqXCIsIFwiKm91dCpcIiwgXCIqcHJpbnQtZHVwKlwiLCBcIipwcmludC1sZW5ndGgqXCIsIFwiKnByaW50LWxldmVsKlwiLCBcIipwcmludC1tZXRhKlwiLCBcIipwcmludC1uYW1lc3BhY2UtbWFwcypcIiwgXCIqcHJpbnQtcmVhZGFibHkqXCIsIFwiKnJlYWQtZXZhbCpcIiwgXCIqcmVhZGVyLXJlc29sdmVyKlwiLCBcIipzb3VyY2UtcGF0aCpcIiwgXCIqc3VwcHJlc3MtcmVhZCpcIiwgXCIqdW5jaGVja2VkLW1hdGgqXCIsIFwiKnVzZS1jb250ZXh0LWNsYXNzbG9hZGVyKlwiLCBcIip2ZXJib3NlLWRlZnJlY29yZHMqXCIsIFwiKndhcm4tb24tcmVmbGVjdGlvbipcIiwgXCIrXCIsIFwiKydcIiwgXCItXCIsIFwiLSdcIiwgXCItPlwiLCBcIi0+PlwiLCBcIi0+QXJyYXlDaHVua1wiLCBcIi0+RWR1Y3Rpb25cIiwgXCItPlZlY1wiLCBcIi0+VmVjTm9kZVwiLCBcIi0+VmVjU2VxXCIsIFwiLWNhY2hlLXByb3RvY29sLWZuXCIsIFwiLXJlc2V0LW1ldGhvZHNcIiwgXCIuLlwiLCBcIi9cIiwgXCI8XCIsIFwiPD1cIiwgXCI9XCIsIFwiPT1cIiwgXCI+XCIsIFwiPj1cIiwgXCJFTVBUWS1OT0RFXCIsIFwiSW5zdFwiLCBcIlN0YWNrVHJhY2VFbGVtZW50LT52ZWNcIiwgXCJUaHJvd2FibGUtPm1hcFwiLCBcImFjY2Vzc29yXCIsIFwiYWNsb25lXCIsIFwiYWRkLWNsYXNzcGF0aFwiLCBcImFkZC13YXRjaFwiLCBcImFnZW50XCIsIFwiYWdlbnQtZXJyb3JcIiwgXCJhZ2VudC1lcnJvcnNcIiwgXCJhZ2V0XCIsIFwiYWxlbmd0aFwiLCBcImFsaWFzXCIsIFwiYWxsLW5zXCIsIFwiYWx0ZXJcIiwgXCJhbHRlci1tZXRhIVwiLCBcImFsdGVyLXZhci1yb290XCIsIFwiYW1hcFwiLCBcImFuY2VzdG9yc1wiLCBcImFuZFwiLCBcImFueT9cIiwgXCJhcHBseVwiLCBcImFyZWR1Y2VcIiwgXCJhcnJheS1tYXBcIiwgXCJhcy0+XCIsIFwiYXNldFwiLCBcImFzZXQtYm9vbGVhblwiLCBcImFzZXQtYnl0ZVwiLCBcImFzZXQtY2hhclwiLCBcImFzZXQtZG91YmxlXCIsIFwiYXNldC1mbG9hdFwiLCBcImFzZXQtaW50XCIsIFwiYXNldC1sb25nXCIsIFwiYXNldC1zaG9ydFwiLCBcImFzc2VydFwiLCBcImFzc29jXCIsIFwiYXNzb2MhXCIsIFwiYXNzb2MtaW5cIiwgXCJhc3NvY2lhdGl2ZT9cIiwgXCJhdG9tXCIsIFwiYXdhaXRcIiwgXCJhd2FpdC1mb3JcIiwgXCJhd2FpdDFcIiwgXCJiYXNlc1wiLCBcImJlYW5cIiwgXCJiaWdkZWNcIiwgXCJiaWdpbnRcIiwgXCJiaWdpbnRlZ2VyXCIsIFwiYmluZGluZ1wiLCBcImJpdC1hbmRcIiwgXCJiaXQtYW5kLW5vdFwiLCBcImJpdC1jbGVhclwiLCBcImJpdC1mbGlwXCIsIFwiYml0LW5vdFwiLCBcImJpdC1vclwiLCBcImJpdC1zZXRcIiwgXCJiaXQtc2hpZnQtbGVmdFwiLCBcImJpdC1zaGlmdC1yaWdodFwiLCBcImJpdC10ZXN0XCIsIFwiYml0LXhvclwiLCBcImJvb2xlYW5cIiwgXCJib29sZWFuLWFycmF5XCIsIFwiYm9vbGVhbj9cIiwgXCJib29sZWFuc1wiLCBcImJvdW5kLWZuXCIsIFwiYm91bmQtZm4qXCIsIFwiYm91bmQ/XCIsIFwiYm91bmRlZC1jb3VudFwiLCBcImJ1dGxhc3RcIiwgXCJieXRlXCIsIFwiYnl0ZS1hcnJheVwiLCBcImJ5dGVzXCIsIFwiYnl0ZXM/XCIsIFwiY2FzZVwiLCBcImNhc3RcIiwgXCJjYXRcIiwgXCJjaGFyXCIsIFwiY2hhci1hcnJheVwiLCBcImNoYXItZXNjYXBlLXN0cmluZ1wiLCBcImNoYXItbmFtZS1zdHJpbmdcIiwgXCJjaGFyP1wiLCBcImNoYXJzXCIsIFwiY2h1bmtcIiwgXCJjaHVuay1hcHBlbmRcIiwgXCJjaHVuay1idWZmZXJcIiwgXCJjaHVuay1jb25zXCIsIFwiY2h1bmstZmlyc3RcIiwgXCJjaHVuay1uZXh0XCIsIFwiY2h1bmstcmVzdFwiLCBcImNodW5rZWQtc2VxP1wiLCBcImNsYXNzXCIsIFwiY2xhc3M/XCIsIFwiY2xlYXItYWdlbnQtZXJyb3JzXCIsIFwiY2xvanVyZS12ZXJzaW9uXCIsIFwiY29sbD9cIiwgXCJjb21tZW50XCIsIFwiY29tbXV0ZVwiLCBcImNvbXBcIiwgXCJjb21wYXJhdG9yXCIsIFwiY29tcGFyZVwiLCBcImNvbXBhcmUtYW5kLXNldCFcIiwgXCJjb21waWxlXCIsIFwiY29tcGxlbWVudFwiLCBcImNvbXBsZXRpbmdcIiwgXCJjb25jYXRcIiwgXCJjb25kXCIsIFwiY29uZC0+XCIsIFwiY29uZC0+PlwiLCBcImNvbmRwXCIsIFwiY29ualwiLCBcImNvbmohXCIsIFwiY29uc1wiLCBcImNvbnN0YW50bHlcIiwgXCJjb25zdHJ1Y3QtcHJveHlcIiwgXCJjb250YWlucz9cIiwgXCJjb3VudFwiLCBcImNvdW50ZWQ/XCIsIFwiY3JlYXRlLW5zXCIsIFwiY3JlYXRlLXN0cnVjdFwiLCBcImN5Y2xlXCIsIFwiZGVjXCIsIFwiZGVjJ1wiLCBcImRlY2ltYWw/XCIsIFwiZGVjbGFyZVwiLCBcImRlZHVwZVwiLCBcImRlZmF1bHQtZGF0YS1yZWFkZXJzXCIsIFwiZGVmaW5saW5lXCIsIFwiZGVmaW50ZXJmYWNlXCIsIFwiZGVmbWFjcm9cIiwgXCJkZWZtZXRob2RcIiwgXCJkZWZtdWx0aVwiLCBcImRlZm5cIiwgXCJkZWZuLVwiLCBcImRlZm9uY2VcIiwgXCJkZWZwcm90b2NvbFwiLCBcImRlZnJlY29yZFwiLCBcImRlZnN0cnVjdFwiLCBcImRlZnR5cGVcIiwgXCJkZWxheVwiLCBcImRlbGF5P1wiLCBcImRlbGl2ZXJcIiwgXCJkZW5vbWluYXRvclwiLCBcImRlcmVmXCIsIFwiZGVyaXZlXCIsIFwiZGVzY2VuZGFudHNcIiwgXCJkZXN0cnVjdHVyZVwiLCBcImRpc2pcIiwgXCJkaXNqIVwiLCBcImRpc3NvY1wiLCBcImRpc3NvYyFcIiwgXCJkaXN0aW5jdFwiLCBcImRpc3RpbmN0P1wiLCBcImRvYWxsXCIsIFwiZG9ydW5cIiwgXCJkb3NlcVwiLCBcImRvc3luY1wiLCBcImRvdGltZXNcIiwgXCJkb3RvXCIsIFwiZG91YmxlXCIsIFwiZG91YmxlLWFycmF5XCIsIFwiZG91YmxlP1wiLCBcImRvdWJsZXNcIiwgXCJkcm9wXCIsIFwiZHJvcC1sYXN0XCIsIFwiZHJvcC13aGlsZVwiLCBcImVkdWN0aW9uXCIsIFwiZW1wdHlcIiwgXCJlbXB0eT9cIiwgXCJlbnN1cmVcIiwgXCJlbnN1cmUtcmVkdWNlZFwiLCBcImVudW1lcmF0aW9uLXNlcVwiLCBcImVycm9yLWhhbmRsZXJcIiwgXCJlcnJvci1tb2RlXCIsIFwiZXZhbFwiLCBcImV2ZW4/XCIsIFwiZXZlcnktcHJlZFwiLCBcImV2ZXJ5P1wiLCBcImV4LWRhdGFcIiwgXCJleC1pbmZvXCIsIFwiZXh0ZW5kXCIsIFwiZXh0ZW5kLXByb3RvY29sXCIsIFwiZXh0ZW5kLXR5cGVcIiwgXCJleHRlbmRlcnNcIiwgXCJleHRlbmRzP1wiLCBcImZhbHNlP1wiLCBcImZmaXJzdFwiLCBcImZpbGUtc2VxXCIsIFwiZmlsdGVyXCIsIFwiZmlsdGVydlwiLCBcImZpbmRcIiwgXCJmaW5kLWtleXdvcmRcIiwgXCJmaW5kLW5zXCIsIFwiZmluZC1wcm90b2NvbC1pbXBsXCIsIFwiZmluZC1wcm90b2NvbC1tZXRob2RcIiwgXCJmaW5kLXZhclwiLCBcImZpcnN0XCIsIFwiZmxhdHRlblwiLCBcImZsb2F0XCIsIFwiZmxvYXQtYXJyYXlcIiwgXCJmbG9hdD9cIiwgXCJmbG9hdHNcIiwgXCJmbHVzaFwiLCBcImZuXCIsIFwiZm4/XCIsIFwiZm5leHRcIiwgXCJmbmlsXCIsIFwiZm9yXCIsIFwiZm9yY2VcIiwgXCJmb3JtYXRcIiwgXCJmcmVxdWVuY2llc1wiLCBcImZ1dHVyZVwiLCBcImZ1dHVyZS1jYWxsXCIsIFwiZnV0dXJlLWNhbmNlbFwiLCBcImZ1dHVyZS1jYW5jZWxsZWQ/XCIsIFwiZnV0dXJlLWRvbmU/XCIsIFwiZnV0dXJlP1wiLCBcImdlbi1jbGFzc1wiLCBcImdlbi1pbnRlcmZhY2VcIiwgXCJnZW5zeW1cIiwgXCJnZXRcIiwgXCJnZXQtaW5cIiwgXCJnZXQtbWV0aG9kXCIsIFwiZ2V0LXByb3h5LWNsYXNzXCIsIFwiZ2V0LXRocmVhZC1iaW5kaW5nc1wiLCBcImdldC12YWxpZGF0b3JcIiwgXCJncm91cC1ieVwiLCBcImhhbHQtd2hlblwiLCBcImhhc2hcIiwgXCJoYXNoLWNvbWJpbmVcIiwgXCJoYXNoLW1hcFwiLCBcImhhc2gtb3JkZXJlZC1jb2xsXCIsIFwiaGFzaC1zZXRcIiwgXCJoYXNoLXVub3JkZXJlZC1jb2xsXCIsIFwiaWRlbnQ/XCIsIFwiaWRlbnRpY2FsP1wiLCBcImlkZW50aXR5XCIsIFwiaWYtbGV0XCIsIFwiaWYtbm90XCIsIFwiaWYtc29tZVwiLCBcImlmbj9cIiwgXCJpbXBvcnRcIiwgXCJpbi1uc1wiLCBcImluY1wiLCBcImluYydcIiwgXCJpbmRleGVkP1wiLCBcImluaXQtcHJveHlcIiwgXCJpbnN0LW1zXCIsIFwiaW5zdC1tcypcIiwgXCJpbnN0P1wiLCBcImluc3RhbmNlP1wiLCBcImludFwiLCBcImludC1hcnJheVwiLCBcImludD9cIiwgXCJpbnRlZ2VyP1wiLCBcImludGVybGVhdmVcIiwgXCJpbnRlcm5cIiwgXCJpbnRlcnBvc2VcIiwgXCJpbnRvXCIsIFwiaW50by1hcnJheVwiLCBcImludHNcIiwgXCJpbyFcIiwgXCJpc2E/XCIsIFwiaXRlcmF0ZVwiLCBcIml0ZXJhdG9yLXNlcVwiLCBcImp1eHRcIiwgXCJrZWVwXCIsIFwia2VlcC1pbmRleGVkXCIsIFwia2V5XCIsIFwia2V5c1wiLCBcImtleXdvcmRcIiwgXCJrZXl3b3JkP1wiLCBcImxhc3RcIiwgXCJsYXp5LWNhdFwiLCBcImxhenktc2VxXCIsIFwibGV0XCIsIFwibGV0Zm5cIiwgXCJsaW5lLXNlcVwiLCBcImxpc3RcIiwgXCJsaXN0KlwiLCBcImxpc3Q/XCIsIFwibG9hZFwiLCBcImxvYWQtZmlsZVwiLCBcImxvYWQtcmVhZGVyXCIsIFwibG9hZC1zdHJpbmdcIiwgXCJsb2FkZWQtbGlic1wiLCBcImxvY2tpbmdcIiwgXCJsb25nXCIsIFwibG9uZy1hcnJheVwiLCBcImxvbmdzXCIsIFwibG9vcFwiLCBcIm1hY3JvZXhwYW5kXCIsIFwibWFjcm9leHBhbmQtMVwiLCBcIm1ha2UtYXJyYXlcIiwgXCJtYWtlLWhpZXJhcmNoeVwiLCBcIm1hcFwiLCBcIm1hcC1lbnRyeT9cIiwgXCJtYXAtaW5kZXhlZFwiLCBcIm1hcD9cIiwgXCJtYXBjYXRcIiwgXCJtYXB2XCIsIFwibWF4XCIsIFwibWF4LWtleVwiLCBcIm1lbWZuXCIsIFwibWVtb2l6ZVwiLCBcIm1lcmdlXCIsIFwibWVyZ2Utd2l0aFwiLCBcIm1ldGFcIiwgXCJtZXRob2Qtc2lnXCIsIFwibWV0aG9kc1wiLCBcIm1pblwiLCBcIm1pbi1rZXlcIiwgXCJtaXgtY29sbGVjdGlvbi1oYXNoXCIsIFwibW9kXCIsIFwibXVuZ2VcIiwgXCJuYW1lXCIsIFwibmFtZXNwYWNlXCIsIFwibmFtZXNwYWNlLW11bmdlXCIsIFwibmF0LWludD9cIiwgXCJuZWctaW50P1wiLCBcIm5lZz9cIiwgXCJuZXdsaW5lXCIsIFwibmV4dFwiLCBcIm5maXJzdFwiLCBcIm5pbD9cIiwgXCJubmV4dFwiLCBcIm5vdFwiLCBcIm5vdC1hbnk/XCIsIFwibm90LWVtcHR5XCIsIFwibm90LWV2ZXJ5P1wiLCBcIm5vdD1cIiwgXCJuc1wiLCBcIm5zLWFsaWFzZXNcIiwgXCJucy1pbXBvcnRzXCIsIFwibnMtaW50ZXJuc1wiLCBcIm5zLW1hcFwiLCBcIm5zLW5hbWVcIiwgXCJucy1wdWJsaWNzXCIsIFwibnMtcmVmZXJzXCIsIFwibnMtcmVzb2x2ZVwiLCBcIm5zLXVuYWxpYXNcIiwgXCJucy11bm1hcFwiLCBcIm50aFwiLCBcIm50aG5leHRcIiwgXCJudGhyZXN0XCIsIFwibnVtXCIsIFwibnVtYmVyP1wiLCBcIm51bWVyYXRvclwiLCBcIm9iamVjdC1hcnJheVwiLCBcIm9kZD9cIiwgXCJvclwiLCBcInBhcmVudHNcIiwgXCJwYXJ0aWFsXCIsIFwicGFydGl0aW9uXCIsIFwicGFydGl0aW9uLWFsbFwiLCBcInBhcnRpdGlvbi1ieVwiLCBcInBjYWxsc1wiLCBcInBlZWtcIiwgXCJwZXJzaXN0ZW50IVwiLCBcInBtYXBcIiwgXCJwb3BcIiwgXCJwb3AhXCIsIFwicG9wLXRocmVhZC1iaW5kaW5nc1wiLCBcInBvcy1pbnQ/XCIsIFwicG9zP1wiLCBcInByXCIsIFwicHItc3RyXCIsIFwicHJlZmVyLW1ldGhvZFwiLCBcInByZWZlcnNcIiwgXCJwcmltaXRpdmVzLWNsYXNzbmFtZXNcIiwgXCJwcmludFwiLCBcInByaW50LWN0b3JcIiwgXCJwcmludC1kdXBcIiwgXCJwcmludC1tZXRob2RcIiwgXCJwcmludC1zaW1wbGVcIiwgXCJwcmludC1zdHJcIiwgXCJwcmludGZcIiwgXCJwcmludGxuXCIsIFwicHJpbnRsbi1zdHJcIiwgXCJwcm5cIiwgXCJwcm4tc3RyXCIsIFwicHJvbWlzZVwiLCBcInByb3h5XCIsIFwicHJveHktY2FsbC13aXRoLXN1cGVyXCIsIFwicHJveHktbWFwcGluZ3NcIiwgXCJwcm94eS1uYW1lXCIsIFwicHJveHktc3VwZXJcIiwgXCJwdXNoLXRocmVhZC1iaW5kaW5nc1wiLCBcInB2YWx1ZXNcIiwgXCJxdWFsaWZpZWQtaWRlbnQ/XCIsIFwicXVhbGlmaWVkLWtleXdvcmQ/XCIsIFwicXVhbGlmaWVkLXN5bWJvbD9cIiwgXCJxdW90XCIsIFwicmFuZFwiLCBcInJhbmQtaW50XCIsIFwicmFuZC1udGhcIiwgXCJyYW5kb20tc2FtcGxlXCIsIFwicmFuZ2VcIiwgXCJyYXRpbz9cIiwgXCJyYXRpb25hbD9cIiwgXCJyYXRpb25hbGl6ZVwiLCBcInJlLWZpbmRcIiwgXCJyZS1ncm91cHNcIiwgXCJyZS1tYXRjaGVyXCIsIFwicmUtbWF0Y2hlc1wiLCBcInJlLXBhdHRlcm5cIiwgXCJyZS1zZXFcIiwgXCJyZWFkXCIsIFwicmVhZC1saW5lXCIsIFwicmVhZC1zdHJpbmdcIiwgXCJyZWFkZXItY29uZGl0aW9uYWxcIiwgXCJyZWFkZXItY29uZGl0aW9uYWw/XCIsIFwicmVhbGl6ZWQ/XCIsIFwicmVjb3JkP1wiLCBcInJlZHVjZVwiLCBcInJlZHVjZS1rdlwiLCBcInJlZHVjZWRcIiwgXCJyZWR1Y2VkP1wiLCBcInJlZHVjdGlvbnNcIiwgXCJyZWZcIiwgXCJyZWYtaGlzdG9yeS1jb3VudFwiLCBcInJlZi1tYXgtaGlzdG9yeVwiLCBcInJlZi1taW4taGlzdG9yeVwiLCBcInJlZi1zZXRcIiwgXCJyZWZlclwiLCBcInJlZmVyLWNsb2p1cmVcIiwgXCJyZWlmeVwiLCBcInJlbGVhc2UtcGVuZGluZy1zZW5kc1wiLCBcInJlbVwiLCBcInJlbW92ZVwiLCBcInJlbW92ZS1hbGwtbWV0aG9kc1wiLCBcInJlbW92ZS1tZXRob2RcIiwgXCJyZW1vdmUtbnNcIiwgXCJyZW1vdmUtd2F0Y2hcIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRlZGx5XCIsIFwicmVwbGFjZVwiLCBcInJlcGxpY2F0ZVwiLCBcInJlcXVpcmVcIiwgXCJyZXNldCFcIiwgXCJyZXNldC1tZXRhIVwiLCBcInJlc2V0LXZhbHMhXCIsIFwicmVzb2x2ZVwiLCBcInJlc3RcIiwgXCJyZXN0YXJ0LWFnZW50XCIsIFwicmVzdWx0c2V0LXNlcVwiLCBcInJldmVyc2VcIiwgXCJyZXZlcnNpYmxlP1wiLCBcInJzZXFcIiwgXCJyc3Vic2VxXCIsIFwicnVuIVwiLCBcInNhdGlzZmllcz9cIiwgXCJzZWNvbmRcIiwgXCJzZWxlY3Qta2V5c1wiLCBcInNlbmRcIiwgXCJzZW5kLW9mZlwiLCBcInNlbmQtdmlhXCIsIFwic2VxXCIsIFwic2VxP1wiLCBcInNlcWFibGU/XCIsIFwic2VxdWVcIiwgXCJzZXF1ZW5jZVwiLCBcInNlcXVlbnRpYWw/XCIsIFwic2V0XCIsIFwic2V0LWFnZW50LXNlbmQtZXhlY3V0b3IhXCIsIFwic2V0LWFnZW50LXNlbmQtb2ZmLWV4ZWN1dG9yIVwiLCBcInNldC1lcnJvci1oYW5kbGVyIVwiLCBcInNldC1lcnJvci1tb2RlIVwiLCBcInNldC12YWxpZGF0b3IhXCIsIFwic2V0P1wiLCBcInNob3J0XCIsIFwic2hvcnQtYXJyYXlcIiwgXCJzaG9ydHNcIiwgXCJzaHVmZmxlXCIsIFwic2h1dGRvd24tYWdlbnRzXCIsIFwic2ltcGxlLWlkZW50P1wiLCBcInNpbXBsZS1rZXl3b3JkP1wiLCBcInNpbXBsZS1zeW1ib2w/XCIsIFwic2x1cnBcIiwgXCJzb21lXCIsIFwic29tZS0+XCIsIFwic29tZS0+PlwiLCBcInNvbWUtZm5cIiwgXCJzb21lP1wiLCBcInNvcnRcIiwgXCJzb3J0LWJ5XCIsIFwic29ydGVkLW1hcFwiLCBcInNvcnRlZC1tYXAtYnlcIiwgXCJzb3J0ZWQtc2V0XCIsIFwic29ydGVkLXNldC1ieVwiLCBcInNvcnRlZD9cIiwgXCJzcGVjaWFsLXN5bWJvbD9cIiwgXCJzcGl0XCIsIFwic3BsaXQtYXRcIiwgXCJzcGxpdC13aXRoXCIsIFwic3RyXCIsIFwic3RyaW5nP1wiLCBcInN0cnVjdFwiLCBcInN0cnVjdC1tYXBcIiwgXCJzdWJzXCIsIFwic3Vic2VxXCIsIFwic3VidmVjXCIsIFwic3VwZXJzXCIsIFwic3dhcCFcIiwgXCJzd2FwLXZhbHMhXCIsIFwic3ltYm9sXCIsIFwic3ltYm9sP1wiLCBcInN5bmNcIiwgXCJ0YWdnZWQtbGl0ZXJhbFwiLCBcInRhZ2dlZC1saXRlcmFsP1wiLCBcInRha2VcIiwgXCJ0YWtlLWxhc3RcIiwgXCJ0YWtlLW50aFwiLCBcInRha2Utd2hpbGVcIiwgXCJ0ZXN0XCIsIFwidGhlLW5zXCIsIFwidGhyZWFkLWJvdW5kP1wiLCBcInRpbWVcIiwgXCJ0by1hcnJheVwiLCBcInRvLWFycmF5LTJkXCIsIFwidHJhbXBvbGluZVwiLCBcInRyYW5zZHVjZVwiLCBcInRyYW5zaWVudFwiLCBcInRyZWUtc2VxXCIsIFwidHJ1ZT9cIiwgXCJ0eXBlXCIsIFwidW5jaGVja2VkLWFkZFwiLCBcInVuY2hlY2tlZC1hZGQtaW50XCIsIFwidW5jaGVja2VkLWJ5dGVcIiwgXCJ1bmNoZWNrZWQtY2hhclwiLCBcInVuY2hlY2tlZC1kZWNcIiwgXCJ1bmNoZWNrZWQtZGVjLWludFwiLCBcInVuY2hlY2tlZC1kaXZpZGUtaW50XCIsIFwidW5jaGVja2VkLWRvdWJsZVwiLCBcInVuY2hlY2tlZC1mbG9hdFwiLCBcInVuY2hlY2tlZC1pbmNcIiwgXCJ1bmNoZWNrZWQtaW5jLWludFwiLCBcInVuY2hlY2tlZC1pbnRcIiwgXCJ1bmNoZWNrZWQtbG9uZ1wiLCBcInVuY2hlY2tlZC1tdWx0aXBseVwiLCBcInVuY2hlY2tlZC1tdWx0aXBseS1pbnRcIiwgXCJ1bmNoZWNrZWQtbmVnYXRlXCIsIFwidW5jaGVja2VkLW5lZ2F0ZS1pbnRcIiwgXCJ1bmNoZWNrZWQtcmVtYWluZGVyLWludFwiLCBcInVuY2hlY2tlZC1zaG9ydFwiLCBcInVuY2hlY2tlZC1zdWJ0cmFjdFwiLCBcInVuY2hlY2tlZC1zdWJ0cmFjdC1pbnRcIiwgXCJ1bmRlcml2ZVwiLCBcInVucXVvdGVcIiwgXCJ1bnF1b3RlLXNwbGljaW5nXCIsIFwidW5yZWR1Y2VkXCIsIFwidW5zaWduZWQtYml0LXNoaWZ0LXJpZ2h0XCIsIFwidXBkYXRlXCIsIFwidXBkYXRlLWluXCIsIFwidXBkYXRlLXByb3h5XCIsIFwidXJpP1wiLCBcInVzZVwiLCBcInV1aWQ/XCIsIFwidmFsXCIsIFwidmFsc1wiLCBcInZhci1nZXRcIiwgXCJ2YXItc2V0XCIsIFwidmFyP1wiLCBcInZhcnktbWV0YVwiLCBcInZlY1wiLCBcInZlY3RvclwiLCBcInZlY3Rvci1vZlwiLCBcInZlY3Rvcj9cIiwgXCJ2b2xhdGlsZSFcIiwgXCJ2b2xhdGlsZT9cIiwgXCJ2cmVzZXQhXCIsIFwidnN3YXAhXCIsIFwid2hlblwiLCBcIndoZW4tZmlyc3RcIiwgXCJ3aGVuLWxldFwiLCBcIndoZW4tbm90XCIsIFwid2hlbi1zb21lXCIsIFwid2hpbGVcIiwgXCJ3aXRoLWJpbmRpbmdzXCIsIFwid2l0aC1iaW5kaW5ncypcIiwgXCJ3aXRoLWluLXN0clwiLCBcIndpdGgtbG9hZGluZy1jb250ZXh0XCIsIFwid2l0aC1sb2NhbC12YXJzXCIsIFwid2l0aC1tZXRhXCIsIFwid2l0aC1vcGVuXCIsIFwid2l0aC1vdXQtc3RyXCIsIFwid2l0aC1wcmVjaXNpb25cIiwgXCJ3aXRoLXJlZGVmc1wiLCBcIndpdGgtcmVkZWZzLWZuXCIsIFwieG1sLXNlcVwiLCBcInplcm8/XCIsIFwiemlwbWFwXCJdO1xudmFyIGhhdmVCb2R5UGFyYW1ldGVyID0gW1wiLT5cIiwgXCItPj5cIiwgXCJhcy0+XCIsIFwiYmluZGluZ1wiLCBcImJvdW5kLWZuXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29tbWVudFwiLCBcImNvbmRcIiwgXCJjb25kLT5cIiwgXCJjb25kLT4+XCIsIFwiY29uZHBcIiwgXCJkZWZcIiwgXCJkZWZpbnRlcmZhY2VcIiwgXCJkZWZtZXRob2RcIiwgXCJkZWZuXCIsIFwiZGVmbWFjcm9cIiwgXCJkZWZwcm90b2NvbFwiLCBcImRlZnJlY29yZFwiLCBcImRlZnN0cnVjdFwiLCBcImRlZnR5cGVcIiwgXCJkb1wiLCBcImRvc2VxXCIsIFwiZG90aW1lc1wiLCBcImRvdG9cIiwgXCJleHRlbmRcIiwgXCJleHRlbmQtcHJvdG9jb2xcIiwgXCJleHRlbmQtdHlwZVwiLCBcImZuXCIsIFwiZm9yXCIsIFwiZnV0dXJlXCIsIFwiaWZcIiwgXCJpZi1sZXRcIiwgXCJpZi1ub3RcIiwgXCJpZi1zb21lXCIsIFwibGV0XCIsIFwibGV0Zm5cIiwgXCJsb2NraW5nXCIsIFwibG9vcFwiLCBcIm5zXCIsIFwicHJveHlcIiwgXCJyZWlmeVwiLCBcInN0cnVjdC1tYXBcIiwgXCJzb21lLT5cIiwgXCJzb21lLT4+XCIsIFwidHJ5XCIsIFwid2hlblwiLCBcIndoZW4tZmlyc3RcIiwgXCJ3aGVuLWxldFwiLCBcIndoZW4tbm90XCIsIFwid2hlbi1zb21lXCIsIFwid2hpbGVcIiwgXCJ3aXRoLWJpbmRpbmdzXCIsIFwid2l0aC1iaW5kaW5ncypcIiwgXCJ3aXRoLWluLXN0clwiLCBcIndpdGgtbG9hZGluZy1jb250ZXh0XCIsIFwid2l0aC1sb2NhbC12YXJzXCIsIFwid2l0aC1tZXRhXCIsIFwid2l0aC1vcGVuXCIsIFwid2l0aC1vdXQtc3RyXCIsIFwid2l0aC1wcmVjaXNpb25cIiwgXCJ3aXRoLXJlZGVmc1wiLCBcIndpdGgtcmVkZWZzLWZuXCJdO1xudmFyIGF0b20gPSBjcmVhdGVMb29rdXBNYXAoYXRvbXMpO1xudmFyIHNwZWNpYWxGb3JtID0gY3JlYXRlTG9va3VwTWFwKHNwZWNpYWxGb3Jtcyk7XG52YXIgY29yZVN5bWJvbCA9IGNyZWF0ZUxvb2t1cE1hcChjb3JlU3ltYm9scyk7XG52YXIgaGFzQm9keVBhcmFtZXRlciA9IGNyZWF0ZUxvb2t1cE1hcChoYXZlQm9keVBhcmFtZXRlcik7XG52YXIgZGVsaW1pdGVyID0gL14oPzpbXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl18JCkvO1xudmFyIG51bWJlckxpdGVyYWwgPSAvXig/OlsrXFwtXT9cXGQrKD86KD86TnwoPzpbZUVdWytcXC1dP1xcZCspKXwoPzpcXC4/XFxkKig/Ok18KD86W2VFXVsrXFwtXT9cXGQrKSk/KXxcXC9cXGQrfFt4WF1bMC05YS1mQS1GXSt8clswLTlhLXpBLVpdKyk/KD89W1xcXFxcXFtcXF1cXHNcIiMnKCksO0BeYHt9fl18JCkpLztcbnZhciBjaGFyYWN0ZXJMaXRlcmFsID0gL14oPzpcXFxcKD86YmFja3NwYWNlfGZvcm1mZWVkfG5ld2xpbmV8cmV0dXJufHNwYWNlfHRhYnxvWzAtN117M318dVswLTlBLUZhLWZdezR9fHhbMC05QS1GYS1mXXs0fXwuKT8oPz1bXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl18JCkpLztcblxuLy8gc2ltcGxlLW5hbWVzcGFjZSA6PSAvXlteXFxcXFxcL1xcW1xcXVxcZFxcc1wiIycoKSw7QF5ge31+Ll1bXlxcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX4uXFwvXSovXG4vLyBzaW1wbGUtc3ltYm9sICAgIDo9IC9eKD86XFwvfFteXFxcXFxcL1xcW1xcXVxcZFxcc1wiIycoKSw7QF5ge31+XVteXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl0qKS9cbi8vIHF1YWxpZmllZC1zeW1ib2wgOj0gKDxzaW1wbGUtbmFtZXNwYWNlPig8Lj48c2ltcGxlLW5hbWVzcGFjZT4pKjwvPik/PHNpbXBsZS1zeW1ib2w+XG52YXIgcXVhbGlmaWVkU3ltYm9sID0gL14oPzooPzpbXlxcXFxcXC9cXFtcXF1cXGRcXHNcIiMnKCksO0BeYHt9fi5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+LlxcL10qKD86XFwuW15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX4uXVteXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fi5cXC9dKikqXFwvKT8oPzpcXC98W15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+XSopKig/PVtcXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+XXwkKSkvO1xuZnVuY3Rpb24gYmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSB8fCBzdHJlYW0uZWF0KFwiLFwiKSkgcmV0dXJuIFtcInNwYWNlXCIsIG51bGxdO1xuICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlckxpdGVyYWwpKSByZXR1cm4gW251bGwsIFwibnVtYmVyXCJdO1xuICBpZiAoc3RyZWFtLm1hdGNoKGNoYXJhY3RlckxpdGVyYWwpKSByZXR1cm4gW251bGwsIFwic3RyaW5nLnNwZWNpYWxcIl07XG4gIGlmIChzdHJlYW0uZWF0KC9eXCIvKSkgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKHN0cmVhbS5lYXQoL15bKFxcW3tdLykpIHJldHVybiBbXCJvcGVuXCIsIFwiYnJhY2tldFwiXTtcbiAgaWYgKHN0cmVhbS5lYXQoL15bKVxcXX1dLykpIHJldHVybiBbXCJjbG9zZVwiLCBcImJyYWNrZXRcIl07XG4gIGlmIChzdHJlYW0uZWF0KC9eOy8pKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBbXCJzcGFjZVwiLCBcImNvbW1lbnRcIl07XG4gIH1cbiAgaWYgKHN0cmVhbS5lYXQoL15bIydAXmB+XS8pKSByZXR1cm4gW251bGwsIFwibWV0YVwiXTtcbiAgdmFyIG1hdGNoZXMgPSBzdHJlYW0ubWF0Y2gocXVhbGlmaWVkU3ltYm9sKTtcbiAgdmFyIHN5bWJvbCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgaWYgKCFzeW1ib2wpIHtcbiAgICAvLyBhZHZhbmNlIHN0cmVhbSBieSBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIHNvIHdlIGRvbid0IGdldCBzdHVjay5cbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHN0cmVhbS5lYXRXaGlsZShmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuICFpcyhjLCBkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbbnVsbCwgXCJlcnJvclwiXTtcbiAgfVxuICBpZiAoc3ltYm9sID09PSBcImNvbW1lbnRcIiAmJiBzdGF0ZS5sYXN0VG9rZW4gPT09IFwiKFwiKSByZXR1cm4gKHN0YXRlLnRva2VuaXplID0gaW5Db21tZW50KShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGlzKHN5bWJvbCwgYXRvbSkgfHwgc3ltYm9sLmNoYXJBdCgwKSA9PT0gXCI6XCIpIHJldHVybiBbXCJzeW1ib2xcIiwgXCJhdG9tXCJdO1xuICBpZiAoaXMoc3ltYm9sLCBzcGVjaWFsRm9ybSkgfHwgaXMoc3ltYm9sLCBjb3JlU3ltYm9sKSkgcmV0dXJuIFtcInN5bWJvbFwiLCBcImtleXdvcmRcIl07XG4gIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT09IFwiKFwiKSByZXR1cm4gW1wic3ltYm9sXCIsIFwiYnVpbHRpblwiXTsgLy8gb3RoZXIgb3BlcmF0b3JcblxuICByZXR1cm4gW1wic3ltYm9sXCIsIFwidmFyaWFibGVcIl07XG59XG5mdW5jdGlvbiBpblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgbmV4dDtcbiAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKG5leHQgPT09IFwiXFxcIlwiICYmICFlc2NhcGVkKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT09IFwiXFxcXFwiO1xuICB9XG4gIHJldHVybiBbbnVsbCwgXCJzdHJpbmdcIl07XG59XG5mdW5jdGlvbiBpbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgcGFyZW50aGVzaXNDb3VudCA9IDE7XG4gIHZhciBuZXh0O1xuICB3aGlsZSAobmV4dCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAobmV4dCA9PT0gXCIpXCIpIHBhcmVudGhlc2lzQ291bnQtLTtcbiAgICBpZiAobmV4dCA9PT0gXCIoXCIpIHBhcmVudGhlc2lzQ291bnQrKztcbiAgICBpZiAocGFyZW50aGVzaXNDb3VudCA9PT0gMCkge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gYmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1wic3BhY2VcIiwgXCJjb21tZW50XCJdO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9va3VwTWFwKHdvcmRzKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBpcyh2YWx1ZSwgdGVzdCkge1xuICBpZiAodGVzdCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHRlc3QudGVzdCh2YWx1ZSk7XG4gIGlmICh0ZXN0IGluc3RhbmNlb2YgT2JqZWN0KSByZXR1cm4gdGVzdC5wcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgY2xvanVyZSA9IHtcbiAgbmFtZTogXCJjbG9qdXJlXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3R4OiB7XG4gICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBpbmRlbnRUbzogMFxuICAgICAgfSxcbiAgICAgIGxhc3RUb2tlbjogbnVsbCxcbiAgICAgIHRva2VuaXplOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiB0eXBlb2Ygc3RhdGUuY3R4LmluZGVudFRvICE9PSBcIm51bWJlclwiKSBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdGF0ZS5jdHguc3RhcnQgKyAxO1xuICAgIHZhciB0eXBlU3R5bGVQYWlyID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgdmFyIHR5cGUgPSB0eXBlU3R5bGVQYWlyWzBdO1xuICAgIHZhciBzdHlsZSA9IHR5cGVTdHlsZVBhaXJbMV07XG4gICAgdmFyIGN1cnJlbnQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmICh0eXBlICE9PSBcInNwYWNlXCIpIHtcbiAgICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gPT09IFwiKFwiICYmIHN0YXRlLmN0eC5pbmRlbnRUbyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzeW1ib2xcIiAmJiBpcyhjdXJyZW50LCBoYXNCb2R5UGFyYW1ldGVyKSkgc3RhdGUuY3R4LmluZGVudFRvID0gc3RhdGUuY3R4LnN0YXJ0ICsgc3RyZWFtLmluZGVudFVuaXQ7ZWxzZSBzdGF0ZS5jdHguaW5kZW50VG8gPSBcIm5leHRcIjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY3R4LmluZGVudFRvID09PSBcIm5leHRcIikge1xuICAgICAgICBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXJyZW50O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJvcGVuXCIpIHN0YXRlLmN0eCA9IHtcbiAgICAgIHByZXY6IHN0YXRlLmN0eCxcbiAgICAgIHN0YXJ0OiBzdHJlYW0uY29sdW1uKCksXG4gICAgICBpbmRlbnRUbzogbnVsbFxuICAgIH07ZWxzZSBpZiAodHlwZSA9PT0gXCJjbG9zZVwiKSBzdGF0ZS5jdHggPSBzdGF0ZS5jdHgucHJldiB8fCBzdGF0ZS5jdHg7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBpID0gc3RhdGUuY3R4LmluZGVudFRvO1xuICAgIHJldHVybiB0eXBlb2YgaSA9PT0gXCJudW1iZXJcIiA/IGkgOiBzdGF0ZS5jdHguc3RhcnQgKyAxO1xuICB9LFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjbG9zZUJyYWNrZXRzOiB7XG4gICAgICBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsICdcIiddXG4gICAgfSxcbiAgICBjb21tZW50VG9rZW5zOiB7XG4gICAgICBsaW5lOiBcIjs7XCJcbiAgICB9LFxuICAgIGF1dG9jb21wbGV0ZTogW10uY29uY2F0KGF0b21zLCBzcGVjaWFsRm9ybXMsIGNvcmVTeW1ib2xzKVxuICB9XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=