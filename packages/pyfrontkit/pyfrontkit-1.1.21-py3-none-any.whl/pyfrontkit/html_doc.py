# Copyright (c) 2025 Eduardo Antonio Ferrera Rodr√≠guez
# SPDX-License-Identifier: MIT

from .dom import DOM
from .css_register import CSSRegistry
from .block import Block


class HtmlDoc:
    def __init__(self, title="Untitled Document", path=".", **head_attrs):
        self.title = title
        self.path = path.strip()
        if not self.path.endswith("/"):
            self.path += "/"

        self.html_file = self.path + "index.html"
        self.css_file = self.path + "style.css"

        # Optional head attributes
        self.head_attrs = head_attrs

        # ‚úÖ Body scripts (for doc.script())
        self._body_scripts = []

        # Optional links (only if passed)
        self.links = head_attrs.get("links", [])
        
        # üåü CORRECCI√ìN CR√çTICA: Inicializar atributos faltantes para evitar AttributeError
        self.inline_style = head_attrs.get("inline_style")
        self.head_scripts = head_attrs.get("head_scripts", [])

        # Base HTML and CSS templates
        self._html_base = self._generate_base_html()
        self._css_base = self._generate_base_css()

    def _generate_head(self):
        lines = ["<meta charset='UTF-8'>"]
        lines.append(f"<title>{self.title}</title>")
        lines.append("<link rel='stylesheet' href='style.css'>")

        # Optional <link> tags
        for link in self.links:
            lines.append(f"<link rel='stylesheet' href='{link}'>")

        # Add optional inline style
        if self.inline_style:
            lines.append("<style>")
            lines.append(self.inline_style)
            lines.append("</style>")

        # Add external scripts
        for src in self.head_scripts:
            lines.append(f"<script src='{src}'></script>")

        return lines

    def _generate_base_html(self):
        head_content = "\n\t".join(self._generate_head()) # Uso join para un mejor formato
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    {head_content}
</head>
<body>
{{body_content}}
{{body_scripts}}
</body>
</html>
"""

    def _generate_base_css(self):
        return """/* Stylesheet generated by PyFrontKit */
body {
    margin: 0;
    padding: 0;
}
h1, h2, h3, h4, h5, h6, p, ul, ol, li {
    margin: 0;
    padding: 0;
    line-height: 1; 
}
"""

    # ------------------------------
    # Body rendering
    # ------------------------------
    def render_body(self):
        """
        Renders blocks that have no parent, preserving creation order.
        """
        html = ""
        for block in Block._registry:
            if block._parent is None:
                html += block.render(indent=2)
        return html

    # ------------------------------
    # ‚úÖ New simple method
    # ------------------------------
    def script(self, js_code):
        """
        Adds raw JavaScript that will be printed
        at the end of the <body>.
        """
        if js_code:
            self._body_scripts.append(js_code)
        return self

    # ------------------------------
    # Document creation
    # ------------------------------
    def create_document(self):

        # Register CSS from blocks
        for block in Block._registry:
            CSSRegistry.register_block(block)

        # Render body
        body_content = self.render_body()

        # Render body scripts
        body_scripts = "\n".join(
            f"<script>\n{code}\n</script>" for code in self._body_scripts
        )

        # Build final HTML
        html_final = (
            self._html_base
            .replace("{body_content}", body_content)
            .replace("{body_scripts}", body_scripts)
        )

        # Build final CSS
        css_final = self._css_base + "\n" + CSSRegistry.generate_css()

        try:
            with open(self.html_file, "w", encoding="utf-8") as f_html:
                f_html.write(html_final)

            with open(self.css_file, "w", encoding="utf-8") as f_css:
                f_css.write(css_final)

            from .style_manager import StyleManager
            # Note: StyleManager import might require careful handling of circular dependencies 
            # if this class is used heavily within the module.
            sm = StyleManager(css_file=self.css_file)
            sm.apply_styles()

            print(f"‚úÖ Documents created: {self.html_file} and {self.css_file}")
        except Exception as e:
            print(f"‚ùå Error creating files: {e}")

    # ------------------------------
    # Body align system
    # ------------------------------
    def align(self, orientation=None, gap=None, padding=None, grid_column=None):
        """
        Apply styles to the document's body, similar to Block.align,
        but always targets the 'body' selector.
        """
        if orientation is None:
            print("The method align() requires the 'orientation' parameter")
            return self

        if orientation not in ("column", "row", "grid"):
            print("align(): invalid orientation. Use 'column', 'row', or 'grid'")
            return self

        if orientation == "grid" and not grid_column:
            print("align(): 'grid_column' is required when orientation='grid'")
            return self

        selector = "body"

        templates = {
            "column": '''
    display: flex;
    flex-direction: column;
    width: 100%;
    {gap}
    {padding}
    ''',
            "row": '''
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    {padding}
    {gap}
    ''',
            "grid": '''
    display: grid;
    grid-template-columns: repeat({grid_column}, 1fr);
    {gap}
    {padding}
    '''
        }

        gap_text = f"gap: {gap};" if gap else ""
        padding_text = f"padding: {padding};" if padding else ""

        template = templates[orientation]
        css_text = template.format(
            gap=gap_text,
            padding=padding_text,
            grid_column=grid_column if grid_column else "1"
        )

        from .style_manager import CSS_RULES_STYLE
        CSS_RULES_STYLE.append({selector: {"css": css_text}})

        return self
    

    def create_template(self, css=True, inline=True):
        """
        Genera el documento en memoria replicando la l√≥gica de archivos f√≠sicos.
        """
        # 1. Registrar CSS de bloques (Igual que create_document)
        for block in Block._registry:
            CSSRegistry.register_block(block)

        # 2. Renderizar contenido y scripts
        body_content = self.render_body()
        body_scripts = "\n".join(
            f"<script>\n{code}\n</script>" for code in self._body_scripts
        )

        # 3. Generar CSS Base + Bloques
        dynamic_css = CSSRegistry.generate_css() if css else ""
        css_acumulado = self._css_base + "\n" + dynamic_css

        # 4. SIMULAR StyleManager.apply_styles en memoria
        # Esto procesa las reglas de align() y otros m√©todos de estilo
        from .style_manager import CSS_RULES_STYLE
        
        for rule in CSS_RULES_STYLE:
            for selector, data in rule.items():
                new_css = data.get("css", "").strip()
                if not new_css:
                    continue
                
                # Normalizar l√≠neas (asegurar punto y coma)
                new_lines = [line if line.endswith(";") else line + ";" 
                            for line in new_css.splitlines() if line.strip()]
                
                # L√≥gica de inserci√≥n/reemplazo similar a StyleManager
                import re
                pattern = re.compile(rf"({re.escape(selector)}\s*\{{)([^}}]*)(\}})", re.MULTILINE)
                match = pattern.search(css_acumulado)

                if match:
                    existing_css = match.group(2).strip()
                    existing_lines = [line.strip() for line in existing_css.splitlines() if line.strip()]
                    combined_lines = existing_lines + new_lines
                    css_acumulado = (css_acumulado[:match.start(2)] + 
                                   "\n    " + "\n    ".join(combined_lines) + 
                                   "\n" + css_acumulado[match.end(2):])
                else:
                    css_acumulado += f"\n{selector} {{\n    " + "\n    ".join(new_lines) + "\n}}\n"

        css_final = css_acumulado.replace("}}", "}")

        # 5. Ensamblar HTML final
        html_base_local = self._html_base
        style_tag = ""
        
        if css and inline:
            # Si es inline, inyectamos el CSS y quitamos el <link> externo
            style_tag = f"\n<style>\n{css_final}\n</style>"
            html_base_local = html_base_local.replace("<link rel='stylesheet' href='style.css'>", "")
        
        html_final = (
            html_base_local
            .replace("</head>", f"{style_tag}\n</head>" if style_tag else "</head>")
            .replace("{body_content}", body_content)
            .replace("{body_scripts}", body_scripts)
        )

        # 6. LIMPIEZA FINAL (Garantiza statelessness para la pr√≥xima generaci√≥n)
        CSSRegistry.clear_registry()
        Block._registry.clear()
        CSS_RULES_STYLE.clear()

        if css and not inline:
            return html_final, css_final

        return html_final