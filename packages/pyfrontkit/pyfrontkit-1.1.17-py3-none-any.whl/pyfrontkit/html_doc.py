# Copyright (c) 2025 Eduardo Antonio Ferrera Rodr√≠guez
# SPDX-License-Identifier: MIT

from .dom import DOM
from .css_register import CSSRegistry
from .block import Block


class HtmlDoc:
    def __init__(self, title="Untitled Document", path=".", **head_attrs):
        self.title = title
        self.path = path.strip()
        if not self.path.endswith("/"):
            self.path += "/"

        self.html_file = self.path + "index.html"
        self.css_file = self.path + "style.css"

        # Optional head attributes
        self.head_attrs = head_attrs

        # ‚úÖ Body scripts (for doc.script())
        self._body_scripts = []

        # Optional links (only if passed)
        self.links = head_attrs.get("links", [])
        
        # üåü CORRECCI√ìN CR√çTICA: Inicializar atributos faltantes para evitar AttributeError
        self.inline_style = head_attrs.get("inline_style")
        self.head_scripts = head_attrs.get("head_scripts", [])

        # Base HTML and CSS templates
        self._html_base = self._generate_base_html()
        self._css_base = self._generate_base_css()

    def _generate_head(self):
        lines = ["<meta charset='UTF-8'>"]
        lines.append(f"<title>{self.title}</title>")
        lines.append("<link rel='stylesheet' href='style.css'>")

        # Optional <link> tags
        for link in self.links:
            lines.append(f"<link rel='stylesheet' href='{link}'>")

        # Add optional inline style
        if self.inline_style:
            lines.append("<style>")
            lines.append(self.inline_style)
            lines.append("</style>")

        # Add external scripts
        for src in self.head_scripts:
            lines.append(f"<script src='{src}'></script>")

        return lines

    def _generate_base_html(self):
        head_content = "\n\t".join(self._generate_head()) # Uso join para un mejor formato
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    {head_content}
</head>
<body>
{{body_content}}
{{body_scripts}}
</body>
</html>
"""

    def _generate_base_css(self):
        return """/* Stylesheet generated by PyFrontKit */
body {
    margin: 0;
    padding: 0;
}
h1, h2, h3, h4, h5, h6, p, ul, ol, li {
    margin: 0;
    padding: 0;
    line-height: 1; 
}
"""

    # ------------------------------
    # Body rendering
    # ------------------------------
    def render_body(self):
        """
        Renders blocks that have no parent, preserving creation order.
        """
        html = ""
        for block in Block._registry:
            if block._parent is None:
                html += block.render(indent=2)
        return html

    # ------------------------------
    # ‚úÖ New simple method
    # ------------------------------
    def script(self, js_code):
        """
        Adds raw JavaScript that will be printed
        at the end of the <body>.
        """
        if js_code:
            self._body_scripts.append(js_code)
        return self

    # ------------------------------
    # Document creation
    # ------------------------------
    def create_document(self):

        # Register CSS from blocks
        for block in Block._registry:
            CSSRegistry.register_block(block)

        # Render body
        body_content = self.render_body()

        # Render body scripts
        body_scripts = "\n".join(
            f"<script>\n{code}\n</script>" for code in self._body_scripts
        )

        # Build final HTML
        html_final = (
            self._html_base
            .replace("{body_content}", body_content)
            .replace("{body_scripts}", body_scripts)
        )

        # Build final CSS
        css_final = self._css_base + "\n" + CSSRegistry.generate_css()

        try:
            with open(self.html_file, "w", encoding="utf-8") as f_html:
                f_html.write(html_final)

            with open(self.css_file, "w", encoding="utf-8") as f_css:
                f_css.write(css_final)

            from .style_manager import StyleManager
            # Note: StyleManager import might require careful handling of circular dependencies 
            # if this class is used heavily within the module.
            sm = StyleManager(css_file=self.css_file)
            sm.apply_styles()

            print(f"‚úÖ Documents created: {self.html_file} and {self.css_file}")
        except Exception as e:
            print(f"‚ùå Error creating files: {e}")

    # ------------------------------
    # Body align system
    # ------------------------------
    def align(self, orientation=None, gap=None, padding=None, grid_column=None):
        """
        Apply styles to the document's body, similar to Block.align,
        but always targets the 'body' selector.
        """
        if orientation is None:
            print("The method align() requires the 'orientation' parameter")
            return self

        if orientation not in ("column", "row", "grid"):
            print("align(): invalid orientation. Use 'column', 'row', or 'grid'")
            return self

        if orientation == "grid" and not grid_column:
            print("align(): 'grid_column' is required when orientation='grid'")
            return self

        selector = "body"

        templates = {
            "column": '''
    display: flex;
    flex-direction: column;
    width: 100%;
    {gap}
    {padding}
    ''',
            "row": '''
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    {padding}
    {gap}
    ''',
            "grid": '''
    display: grid;
    grid-template-columns: repeat({grid_column}, 1fr);
    {gap}
    {padding}
    '''
        }

        gap_text = f"gap: {gap};" if gap else ""
        padding_text = f"padding: {padding};" if padding else ""

        template = templates[orientation]
        css_text = template.format(
            gap=gap_text,
            padding=padding_text,
            grid_column=grid_column if grid_column else "1"
        )

        from .style_manager import CSS_RULES_STYLE
        CSS_RULES_STYLE.append({selector: {"css": css_text}})

        return self
    

    def create_template(self, css=True, inline=True):
        """
        Generates the document in memory for production.
        
        Args:
            css (bool): If False, no dynamic CSS is generated or included.
            inline (bool): If True, CSS is embedded in a <style> tag within the <head>.
                          If False, returns a tuple (html, css) for separate serving.
        
        Returns:
            str | tuple: The full HTML string, or a (html, css) tuple.
        """
        # 1. Register structure from all blocks
        for block in Block._registry:
            CSSRegistry.register_block(block)

        # 2. Generate and Clean CSS (only if requested)
        dynamic_css = ""
        if css:
            dynamic_css = CSSRegistry.generate_css() # This method already filters empty/comments

        # 3. Handle CSS Inlining logic
        style_tag = ""
        full_css_content = f"{self._css_base}\n{dynamic_css}"
        
        if css and inline:
            # We wrap the content in the <style> tag manually as requested
            style_tag = f"\n<style>\n{full_css_content}\n</style>"

        # 4. Render Body and Scripts
        body_content = self.render_body()
        body_scripts = "\n".join(f"<script>\n{c}\n</script>" for c in self._body_scripts)

        # 5. Assemble HTML
        # Note: If inline is False, {style_tag} will be empty
        html_output = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{self.title}</title>{style_tag}
</head>
<body>
{body_content}
{body_scripts}
</body>
</html>"""

        # 6. CRITICAL: Global Cleanup for Production Statelessness
        CSSRegistry.clear_registry()
        Block._registry.clear()
        try:
            from .style_manager import CSS_RULES_STYLE
            CSS_RULES_STYLE.clear()
        except ImportError:
            pass

        # 7. Final Output logic
        if css and not inline:
            return html_output, full_css_content
        
        return html_output