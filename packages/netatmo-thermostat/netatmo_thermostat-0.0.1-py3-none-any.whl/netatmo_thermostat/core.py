# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['Thermostat']

# %% ../nbs/00_core.ipynb 2
import os
from time import time
from fastcore.utils import patch
from fastcore.xtras import dict2obj
from httpx import get as xget, post as xpost

# %% ../nbs/00_core.ipynb 15
class Thermostat:
    base = 'https://api.netatmo.com'
    
    def __init__(self, client_id=None, client_secret=None, access_token=None, refresh_token=None):
        self.client_id = client_id or os.getenv('CLIENT_ID')
        self.client_secret = client_secret or os.getenv('CLIENT_SECRET')
        self.access_token = access_token or os.getenv('ACCESS_TOKEN')
        self.refresh_token = refresh_token or os.getenv('REFRESH_TOKEN')

# %% ../nbs/00_core.ipynb 17
@patch
def _refresh(self:Thermostat):
    r = xpost(f'{self.base}/oauth2/token', data={
        'grant_type': 'refresh_token',
        'refresh_token': self.refresh_token,
        'client_id': self.client_id,
        'client_secret': self.client_secret
    })
    d = r.json()
    self.access_token, self.refresh_token = d['access_token'], d['refresh_token']
    return d

# %% ../nbs/00_core.ipynb 19
@patch
def _request(self:Thermostat,
    endpoint:str, # the endpoint to query
    method='post', # the http method,
    **kwargs
): # extra kwargs
    "Request a Netatmo API endpoint with auto-refresh on expired token."

    url = f'{self.base}/api/{endpoint}'
    headers = kwargs.pop('headers', {})
    headers['Authorization'] = f'Bearer {self.access_token}'
    
    r = xpost(url, headers=headers, **kwargs) if method == 'post' else xget(url, headers=headers, **kwargs)
    if r.status_code in (401, 403): 
        self._refresh()
        return self._request(endpoint, method, **kwargs)
    rj = r.json()
    return dict2obj(rj.get('body', rj))


# %% ../nbs/00_core.ipynb 23
@patch
def homesdata(self:Thermostat):
    return self._request('homesdata')

# %% ../nbs/00_core.ipynb 28
@patch
def homestatus(self:Thermostat, home_id): return self._request('homestatus', data={'home_id': home_id})

# %% ../nbs/00_core.ipynb 33
@patch
def getroommeasure(self:Thermostat,
    home_id:str,   # Home ID
    room_id:str,   # Room ID
    scale:str='1hour',  # Time scale: 30min, 1hour, 3hours, 1day, 1week, 1month
    type:str='temperature',  # Data type: temperature or sp_temperature
    begin:int=None,  # Start timestamp
    end:int=None,    # End timestamp
):
    "Retrieve room temperature history"
    d = {'home_id': home_id, 'room_id': room_id, 'scale': scale, 'type': type}
    if begin: d['date_begin'] = begin
    if end: d['date_end'] = end
    return self._request('getroommeasure', data=d)

# %% ../nbs/00_core.ipynb 40
@patch
def setroomthermpoint(self:Thermostat,
    home_id:str,   # Home ID
    room_id:str,   # Room ID
    mode:str,      # Mode: manual, home, or schedule
    temp:float=None,      # Target temperature (for manual mode)
    endtime:int=None,     # End timestamp (for manual mode)
):
    "Set room temperature setpoint"
    d = {'home_id': home_id, 'room_id': room_id, 'mode': mode}
    if temp: d['temp'] = temp
    if endtime: d['endtime'] = endtime
    return self._request('setroomthermpoint', data=d)

@patch
def room_temperatures(self:Thermostat, home_id: str):
    "Nicer way to get a list of the temperatures of all room in the home"
    st = self.homestatus(home_id)
    return [dict(room_id=r.id, temperature=r.therm_measured_temperature, setpoint=r.therm_setpoint_temperature, setpoint_mode=r.therm_setpoint_mode) for r in st.home.rooms]

# %% ../nbs/00_core.ipynb 49
@patch
def setthermmode(self:Thermostat,
    home_id:str,   # Home ID
    mode:str,      # Mode: schedule (weekly program), away (reduced temp), hg (frost guard ~7Â°C)
    endtime:int=None,  # End timestamp (for away/hg modes)
):
    "Set home thermostat mode"
    d = {'home_id': home_id, 'mode': mode}
    if endtime: d['endtime'] = endtime
    return self._request('setthermmode', data=d)

# %% ../nbs/00_core.ipynb 58
@patch
def getmeasure(self:Thermostat,
    device_id:str,     # Device MAC address
    module_id:str=None,  # Module MAC (if reading from a module)
    scale:str='1hour', # Time scale: 30min, 1hour, 3hours, 1day, 1week, 1month
    type:str='boileron',  # Data type: boileron, boileroff, sum_boiler_on, sum_boiler_off
    begin:int=None,    # Start timestamp
    end:int=None,      # End timestamp
):
    "Retrieve boiler historical data"
    d = {'device_id': device_id, 'scale': scale, 'type': type}
    if module_id: d['module_id'] = module_id
    if begin: d['date_begin'] = begin
    if end: d['date_end'] = end
    return self._request('getmeasure', data=d)

# %% ../nbs/00_core.ipynb 65
@patch
def createnewhomeschedule(self:Thermostat,
    home_id:str,       # Home ID
    name:str,          # New schedule name
    zones:list,        # List of zone dicts with id, name, type, rooms_temp
    timetable:list,    # List of timetable entries with zone_id, m_offset
    hg_temp:float=7,   # Frost guard temp
    away_temp:float=17, # Away mode temp
):
    "Create a new weekly schedule"
    return self._request('createnewhomeschedule', data={
        'home_id': home_id, 'name': name, 'zones': zones, 
        'timetable': timetable, 'hg_temp': hg_temp, 'away_temp': away_temp})

# %% ../nbs/00_core.ipynb 67
@patch
def switchhomeschedule(self:Thermostat,
    home_id:str,       # Home ID
    schedule_id:str,   # Schedule ID to activate
):
    "Switch to a specific weekly schedule"
    return self._request('switchhomeschedule', data={'home_id': home_id, 'schedule_id': schedule_id})

# %% ../nbs/00_core.ipynb 69
@patch
def synchomeschedule(self:Thermostat,
    home_id:str,       # Home ID
    schedule_id:str,   # Schedule ID to modify
    zones:list,        # List of zone dicts with id, name, type, rooms_temp
    timetable:list,    # List of timetable entries with zone_id, m_offset
    name:str=None,     # Schedule name
    hg_temp:float=None,   # Frost guard temp
    away_temp:float=None, # Away mode temp
):
    "Modify an existing weekly schedule"
    d = {'home_id': home_id, 'schedule_id': schedule_id, 'zones': zones, 'timetable': timetable}
    if name: d['name'] = name
    if hg_temp: d['hg_temp'] = hg_temp
    if away_temp: d['away_temp'] = away_temp
    return self._request('synchomeschedule', data=d)
