from PYMEcs.pyme_warnings import warn
import pickle
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_NPC_set(fname, ts=None, foreshortening=None, version=None):
    with open(fname,'rb') as fi:
        npcs=pickle.load(fi)
    fpath = Path(fname)
    if ts is not None and ts not in fpath.stem:
        warn("MINFLUX time stamp not in NPC dataset filename; check correct filename chosen: %s vs %s" %
             (ts,fpath.stem))

    if foreshortening is not None:
        try:
            npc_foreshortening = npcs.foreshortening
        except AttributeError:
            npc_foreshortening = 1.0

        if abs(npc_foreshortening-foreshortening) >= 0.01:
            warn("NPC foreshortening is %.2f while dataset foreshortening is %.2f, check this is compatible" %
                 (npc_foreshortening,foreshortening))
        

    if version is not None:
        pass # here add version checking logic

    return npcs

def save_NPC_set(npcs,fname):
    with open(fname, "wb") as file:
            pickle.dump(npcs,file)

def findNPCset(pipeline,return_mod=False,warnings=True):
    from PYMEcs.recipes.localisations import NPCAnalysisInput
    # note a "manually" created or loaded NPCset in pipeline.npcs attribute takes precedence over loaded via NPCAnalysisInput module
    if pipeline is not None and 'npcs' in dir(pipeline) and pipeline.npcs is not None and not return_mod:
        return pipeline.npcs
    if pipeline is None:
        return None
    dsname = None
    hideNPC = False
    # search/check for instance
    for mod in pipeline.recipe.modules:
        if isinstance(mod,NPCAnalysisInput):
            dsname = mod.output
            hideNPC = mod.NPC_hide
            module = mod
            break
    if hideNPC: # the module is deliberately hiding the NPCset associated with it
        if warnings:
            warn("NPCset has been marked as hidden in NPCAnalysisInput output, assuming this is deliberate")
        return None
    if dsname is None:
        if warnings:
            warn("we rely on npc analysis being present in a datasource generated by the NPCAnalysisInput module. Can't find such a datasource, aborting...")
        return None
    logger.debug("found NPCAnalysisInput module")
    if return_mod:
        return module
    npc_set_container = pipeline.dataSources[dsname].mdh.get('Processing.NPCAnalysisInput.npcs_filtered')
    if not mod.filter_npcs or npc_set_container is None: # if not filtering or no filtered set available try the unfiltered npc set
        npc_set_container = pipeline.dataSources[dsname].mdh.get('Processing.NPCAnalysisInput.npcs')
        logger.debug("trying to retrieve unfiltered NPCSet")
    else:
        logger.debug("found filtered NPCSet")
    if npc_set_container is None: # we get here if there is still no npc set available
        # this warning cannot be masked as this case should not happen unless something is broken (either bug or not used as intended)
        warn(("found no NPCset container in metadata of datasource '%s' generated by NPCAnalysisInput module.\n\n" % dsname)
             + "Did you already load a pickled NPC analysis file with the module?\n\naborting..." )
        return None
    
    return npc_set_container.get_npcset()

from packaging.version import Version # this allows us to do simpler comparisons
def check_npcset_version(npcset,target_version,mode='minimum version'):
    version = None
    try:
        version =  npcset.version()
    except AttributeError:
        pass
    if version is None: # older version, use some heuristics
        if 'n_bysegments' not in dir (npcset):
            version = Version('0.1')
        elif npcset.n_bysegments() is None: # this can also happen with newer version when not yet fitted, but then we should not have loaded this as a saved object
            version = Version('0.1')
        else:
            version = Version('0.9')

    if mode == 'return_version':
        return version
    
    if not isinstance(version,Version):
        try:
            version = Version(version)
        except:
            warn("cannot convert version expression '%s' to Version object, giving up and returning True, perhaps tell CS" % version)
            return True

    if not isinstance(target_version,Version):
        try:
            target_version = Version(target_version)
        except:
            warn("cannot convert version expression '%s' to Version object, giving up and returning True, perhaps tell CS" % target_version)
            return True

    if mode == 'minimum version':
        return version >= target_version
    elif mode == 'exact version':
        return version == target_version
    else: # we have checked for mode return_version above, so should be ok by not testing here
        raise RuntimeError("unknown mode %s requested" % (mode))

    
    
