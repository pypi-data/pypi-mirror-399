"""
World Runner Service

Calls agent CLI to resolve world state changes.
Stateless - no --continue, each call is independent.
"""

# DOCS: docs/agents/world-runner/PATTERNS_World_Runner.md

import json
import subprocess
import logging
from typing import Dict, Any, List
from pathlib import Path

from .agent_cli import parse_claude_json_output, run_agent

from runtime.physics.graph.graph_ops import GraphOps

from runtime.physics.graph.graph_queries import GraphQueries



logger = logging.getLogger(__name__)





class WorldRunnerService:

    """

    Service for calling the World Runner agent via agent CLI.

    """



    def __init__(

        self,

        graph_ops: GraphOps,

        graph_queries: GraphQueries, # Added GraphQueries instance

        working_dir: str = None,

        timeout: int = 600  # 10 minutes

    ):

        self.graph_ops = graph_ops

        self.graph_queries = graph_queries # Store GraphQueries instance

        self.working_dir = working_dir or str(Path.cwd())

        self.timeout = timeout



        logger.info("[WorldRunnerService] Initialized")



    def process_flips(

        self,

        flips: List[Dict[str, Any]],

        graph_context: Dict[str, Any],

        player_context: Dict[str, Any],

        time_span: str = "unknown"

    ) -> Dict[str, Any]:

        """

        Process events and determine what happened.



        Args:

            flips: List of events to process

            graph_context: Relevant narratives and character info (now used in _build_prompt)

            player_context: Player location and state (now used in _build_prompt)

            time_span: Time span being processed



        Returns:

            WorldRunnerOutput dict with graph_mutations and world_injection

        """

        # Build prompt (now includes dynamic graph context)

        prompt = self._build_prompt(flips, graph_context, player_context, time_span)



        # Call agent CLI (stateless, no --continue)

        result = self._call_claude(prompt)



        # Apply graph mutations generated by the agent

        if "graph_mutations" in result and result["graph_mutations"]:

            try:

                self.graph_ops.apply(data=result["graph_mutations"])

                logger.info(f"[WorldRunnerService] Applied {len(result['graph_mutations'].get('new_narratives', []))} new narratives and other mutations.")

            except Exception as e:

                logger.error(f"[WorldRunnerService] Failed to apply graph mutations: {e}")

                # Fallback to a minimal response if mutations fail

                return self._fallback_response("Failed to apply mutations")



        return result



    def _build_prompt(

        self,

        flips: List[Dict[str, Any]],

        initial_graph_context: Dict[str, Any], # Renamed to avoid confusion with queried context

        initial_player_context: Dict[str, Any], # Renamed

        time_span: str

    ) -> str:

        """

        Build the world runner prompt with comprehensive graph context.

        """

        import yaml

        # Placeholder for world state triggers
        event_details = []



        # 2. Get current locations and statuses of all relevant characters (from initial context for now)

        # For a full implementation, this might involve more complex graph queries

        # For now, we'll use the initial player_context if it has location data

        all_characters_at_locations = self.graph_queries.query("""

            MATCH (c:Actor)-[r:AT]->(p:Space)

            RETURN c.id, c.name, p.id AS place_id, p.name AS place_name, r.present, r.visible

            """,

            params={}

        )



        # 3. Get character relationships (e.g., from BELIEVES links that might be strained)

        character_relationships = self.graph_queries.query("""

            MATCH (c1:Actor)-[b:BELIEVES]->(n:Narrative)-[rel:RELATES_TO]->(n2:Narrative)<-[b2:BELIEVES]-(c2:Actor)

            WHERE rel.contradicts > 0.5

            RETURN c1.id, c2.id, n.id, n2.id, rel.contradicts, b.believes, b2.believes

            """,

            params={}

        )



        # Combine all context for the AI agent

        full_graph_context = {

            "initial_context": initial_graph_context,

            "event_details": event_details,

            "character_locations": all_characters_at_locations,

            "character_relationships": character_relationships,

        }



        parts = [

            "WORLD RUNNER INSTRUCTION",

            "=" * 24,

            "",

            f"TIME_SPAN: {time_span}",

            "",

            "FLIPS:",

            yaml.dump(flips, default_flow_style=False),

            "",

            "GRAPH_CONTEXT:",

            yaml.dump(full_graph_context, default_flow_style=False),

            "",

            "PLAYER_CONTEXT:",

            yaml.dump(initial_player_context, default_flow_style=False),

            "",

            "Determine what happened during this time span.",

            "For each flip, determine:",

            "1. What specifically occurred",

            "2. Who witnessed it",

            "3. What new narratives emerge",

            "4. How beliefs change",

            "5. Any cascading effects",

            "",

            "Output JSON matching WorldRunnerOutput schema.",

        ]



        return "\n".join(parts)

    def _call_claude(self, prompt: str) -> Dict[str, Any]:
        """Call agent CLI and parse response."""
        # Stateless - no --continue
        try:
            result = run_agent(
                prompt,
                working_dir=self.working_dir,
                timeout=self.timeout,
                output_format="json",
            )

            if result.returncode != 0:
                logger.error(f"[WorldRunnerService] Agent CLI failed: {result.stderr}")
                return self._fallback_response(f"Agent CLI failed: {result.stderr}")

            return parse_claude_json_output(result.stdout)

        except subprocess.TimeoutExpired:
            logger.error("[WorldRunnerService] Agent CLI timed out")
            return self._fallback_response("Agent CLI timed out")
        except json.JSONDecodeError as e:
            logger.error(f"[WorldRunnerService] Failed to parse response: {e}")
            return self._fallback_response(f"Failed to parse response: {e}")
        except FileNotFoundError:
            logger.error("[WorldRunnerService] Agent CLI not found")
            return self._fallback_response("Agent CLI not found")

    def _fallback_response(self, message: str = "World Runner unavailable") -> Dict[str, Any]:
        """Return a minimal fallback response."""
        return {
            "thinking": f"Fallback response - {message}",
            "graph_mutations": {
                "new_narratives": [],
                "new_beliefs": [],
                "character_movements": [],
                "modifier_changes": []
            },
            "world_injection": {
                "time_since_last": "unknown",
                "breaks": [],
                "news_arrived": [],
                "interruption": None,
                "atmosphere_shift": None,
                "narrator_notes": "World Runner unavailable - minimal response"
            }
        }

    # =========================================================================
    # v1.2 TICK-BASED RUNNING
    # =========================================================================

    def run_until_visible(
        self,
        max_ticks: int = 100,
        location_id: str = None,
        player_id: str = "char_player"
    ) -> Dict[str, Any]:
        """
        Run ticks until a moment completes (becomes visible to player).

        This runs the physics simulation forward until something "happens"
        that the player would perceive â€” a moment completing.

        Args:
            max_ticks: Maximum ticks to run before giving up
            location_id: Current player location (for filtering visible moments)
            player_id: Player actor ID

        Returns:
            Dict with:
                - ticks_run: Number of ticks executed
                - completed_moments: List of moments that completed
                - final_tick_result: The tick result that had a completion
                - stopped_reason: Why the loop stopped
        """
        from runtime.physics import GraphTick

        # Create tick runner
        tick_runner = GraphTick(
            read=self.graph_queries,
            write=self.graph_ops
        )

        ticks_run = 0
        completed_moments = []
        final_result = None
        stopped_reason = "max_ticks_reached"

        for tick_num in range(max_ticks):
            # Run one tick
            result = tick_runner.run()
            ticks_run += 1
            final_result = result

            # Check for completions
            if result.completions:
                # Filter by location if specified
                if location_id:
                    # Check if any completion is at the player's location
                    visible_completions = []
                    for completion in result.completions:
                        moment_id = completion.get("moment_id")
                        if moment_id:
                            # Check if moment is at player location
                            location_query = """
                            MATCH (m:Moment {id: $moment_id})-[:AT]->(s:Space {id: $location_id})
                            RETURN m.id
                            """
                            at_location = self.graph_queries.query(
                                location_query,
                                params={"moment_id": moment_id, "location_id": location_id}
                            )
                            if at_location:
                                visible_completions.append(completion)

                    if visible_completions:
                        completed_moments.extend(visible_completions)
                        stopped_reason = "moment_completed_at_location"
                        break
                else:
                    # No location filter, any completion counts
                    completed_moments.extend(result.completions)
                    stopped_reason = "moment_completed"
                    break

            # Early exit if no energy in system (nothing will happen)
            total_energy = (
                result.energy_generated +
                result.energy_drawn +
                result.energy_flowed +
                result.energy_backflowed
            )
            if total_energy == 0 and ticks_run > 5:
                stopped_reason = "no_energy_in_system"
                break

        logger.info(f"[WorldRunner] run_until_visible: {ticks_run} ticks, {len(completed_moments)} completions, reason={stopped_reason}")

        return {
            "ticks_run": ticks_run,
            "completed_moments": completed_moments,
            "final_tick_result": final_result,
            "stopped_reason": stopped_reason
        }

    def run_until_disrupted(
        self,
        max_ticks: int = 100,
        narrative_ids: List[str] = None,
        disruption_threshold: float = 0.3
    ) -> Dict[str, Any]:
        """
        Run ticks until narratives shift significantly.

        A "disruption" is detected when:
        - A narrative's energy changes by more than disruption_threshold
        - A new narrative emerges with high energy
        - A moment contradicts or overrides existing narratives

        Args:
            max_ticks: Maximum ticks to run before giving up
            narrative_ids: Specific narratives to watch (None = all high-energy)
            disruption_threshold: Energy change threshold for disruption

        Returns:
            Dict with:
                - ticks_run: Number of ticks executed
                - disruptions: List of disruption events detected
                - final_tick_result: Last tick result
                - stopped_reason: Why the loop stopped
        """
        from runtime.physics import GraphTick

        # Get initial narrative state
        if narrative_ids:
            initial_narratives = {}
            for nid in narrative_ids:
                narrative = self.graph_queries.get_narrative(nid)
                if narrative:
                    initial_narratives[nid] = narrative.get("energy", 0.0)
        else:
            # Watch high-energy narratives
            high_energy_query = """
            MATCH (n:Narrative)
            WHERE n.energy > 0.1
            RETURN n.id as id, n.energy as energy
            ORDER BY n.energy DESC
            LIMIT 20
            """
            results = self.graph_queries.query(high_energy_query, params={})
            initial_narratives = {r["id"]: r["energy"] for r in results if r.get("id")}

        # Create tick runner
        tick_runner = GraphTick(
            read=self.graph_queries,
            write=self.graph_ops
        )

        ticks_run = 0
        disruptions = []
        final_result = None
        stopped_reason = "max_ticks_reached"

        for tick_num in range(max_ticks):
            # Run one tick
            result = tick_runner.run()
            ticks_run += 1
            final_result = result

            # Check for moment-based disruptions
            if result.completions:
                for completion in result.completions:
                    disruptions.append({
                        "type": "moment_completed",
                        "tick": ticks_run,
                        "moment_id": completion.get("moment_id"),
                        "energy_released": completion.get("energy_released", 0.0)
                    })

            if result.rejections:
                for rejection in result.rejections:
                    disruptions.append({
                        "type": "moment_rejected",
                        "tick": ticks_run,
                        "moment_id": rejection.get("moment_id"),
                        "reason": rejection.get("reason", "unknown")
                    })

            # Check narrative energy shifts every 5 ticks
            if ticks_run % 5 == 0:
                for nid, initial_energy in initial_narratives.items():
                    narrative = self.graph_queries.get_narrative(nid)
                    if narrative:
                        current_energy = narrative.get("energy", 0.0)
                        change = abs(current_energy - initial_energy)
                        if change > disruption_threshold:
                            disruptions.append({
                                "type": "narrative_shift",
                                "tick": ticks_run,
                                "narrative_id": nid,
                                "initial_energy": initial_energy,
                                "current_energy": current_energy,
                                "change": change
                            })

            # Stop if we have disruptions
            if disruptions:
                stopped_reason = "disruption_detected"
                break

            # Early exit if no activity
            if result.hot_links == 0 and ticks_run > 10:
                stopped_reason = "no_hot_links"
                break

        logger.info(f"[WorldRunner] run_until_disrupted: {ticks_run} ticks, {len(disruptions)} disruptions, reason={stopped_reason}")

        return {
            "ticks_run": ticks_run,
            "disruptions": disruptions,
            "final_tick_result": final_result,
            "stopped_reason": stopped_reason,
            "watched_narratives": list(initial_narratives.keys())
        }
