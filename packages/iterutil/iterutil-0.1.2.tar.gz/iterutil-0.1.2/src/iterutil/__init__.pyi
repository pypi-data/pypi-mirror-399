from __future__ import annotations

from collections.abc import Callable, Iterable
from typing import Any

__all__: list[str]

def iterator[T](iterable: Iterable[T], /) -> Iterator[T]: ...
def iterate[T](iterable: Iterable[T], /) -> Iterator[T]: ...
def it[T](iterable: Iterable[T], /) -> Iterator[T]: ...

class Iterator[T]:
    inner: Iterable[T]

    def __init__(self, inner: Iterable[T]) -> None: ...
    def __iter__(self) -> Any: ...
    def filter(self, fn: Callable[[T], bool]) -> Iterator[T]: ...
    def filterfalse(self, fn: Callable[[T], bool]) -> Iterator[T]: ...
    def map[U](self, fn: Callable[[T], U]) -> Iterator[U]: ...
    def filter_map[U](self, fn: Callable[[T], U | None]) -> Iterator[U]: ...
    def for_each(self, fn: Callable[[T], Any]) -> None: ...
    def try_for_each(self, fn: Callable[[T], Any]) -> None: ...
    def chain(self, *others: Iterable[T]) -> Iterator[T]: ...
    def enumerate(self) -> Iterator[tuple[int, T]]: ...
    def zip[U](self, other: Iterable[U]) -> Iterator[tuple[T, U]]: ...
    def flatten[U](self: Iterator[Iterable[U]]) -> Iterator[U]: ...
    def collect[U](self, cls: type[U]) -> U: ...
    def sum(self) -> T: ...
    def min(self) -> T: ...
    def max(self) -> T: ...
    def fold[U](self, fn: Callable[[U, T], U], initial: U) -> U: ...
    def reduce[U](self, fn: Callable[[U, T], T], initial: U | None = None) -> Any: ...
    def __getitem__(self, i: slice) -> Iterator[T]: ...
    @classmethod
    def _wrap(cls, inner: Iterable[T]) -> Iterator[T]: ...
