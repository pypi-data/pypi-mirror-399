{"version":3,"file":"2401.c500225927e3e619.js","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-label.ts","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/store.js","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { LitElement, css, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ensureArray } from \"../../common/array/ensure-array\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LabelSelector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-labels-picker\";\n\n@customElement(\"ha-selector-label\")\nexport class HaLabelSelector extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public value?: string | string[];\n\n  @property() public name?: string;\n\n  @property() public label?: string;\n\n  @property() public placeholder?: string;\n\n  @property() public helper?: string;\n\n  @property({ attribute: false }) public selector!: LabelSelector;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  protected render() {\n    if (this.selector.label.multiple) {\n      return html`\n        <ha-labels-picker\n          no-add\n          .hass=${this.hass}\n          .value=${ensureArray(this.value ?? [])}\n          .required=${this.required}\n          .disabled=${this.disabled}\n          .label=${this.label}\n          @value-changed=${this._handleChange}\n        >\n        </ha-labels-picker>\n      `;\n    }\n    return html`\n      <ha-label-picker\n        no-add\n        .hass=${this.hass}\n        .value=${this.value}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        .label=${this.label}\n        @value-changed=${this._handleChange}\n      >\n      </ha-label-picker>\n    `;\n  }\n\n  private _handleChange(ev) {\n    let value = ev.detail.value;\n    if (this.value === value) {\n      return;\n    }\n    if (\n      (value === \"\" || (Array.isArray(value) && value.length === 0)) &&\n      !this.required\n    ) {\n      value = undefined;\n    }\n\n    fireEvent(this, \"value-changed\", { value });\n  }\n\n  static styles = css`\n    ha-labels-picker {\n      display: block;\n      width: 100%;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-label\": HaLabelSelector;\n  }\n}\n","export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n","import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"names":["HaLabelSelector","LitElement","render","this","selector","label","multiple","html","hass","ensureArray","value","required","disabled","_handleChange","ev","detail","Array","isArray","length","undefined","fireEvent","args","styles","css","attribute","type","Boolean","createStore","state","listeners","setState","update","overwrite","Object","assign","currentListeners","i","action","apply","result","arguments","push","ret","Promise","then","clearState","subscribe","listener","out","unsubscribe","getCollection","conn","key","fetchCollection","subscribeUpdates","options","unsubGrace","unsubProm","unsubTimer","active","store","refresh","Error","refreshSwallow","catch","err","connected","teardownUpdateSubscription","unsub","removeEventListener","handleDisconnect","clearTimeout","subscriber","setupUpdateSubscription","addEventListener","setTimeout","createCollection","onChange"],"mappings":"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"}