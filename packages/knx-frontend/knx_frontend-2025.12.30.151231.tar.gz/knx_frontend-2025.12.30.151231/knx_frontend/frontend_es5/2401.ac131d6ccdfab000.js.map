{"version":3,"file":"2401.ac131d6ccdfab000.js","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-label.ts","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/store.js","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { LitElement, css, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ensureArray } from \"../../common/array/ensure-array\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LabelSelector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-labels-picker\";\n\n@customElement(\"ha-selector-label\")\nexport class HaLabelSelector extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public value?: string | string[];\n\n  @property() public name?: string;\n\n  @property() public label?: string;\n\n  @property() public placeholder?: string;\n\n  @property() public helper?: string;\n\n  @property({ attribute: false }) public selector!: LabelSelector;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  protected render() {\n    if (this.selector.label.multiple) {\n      return html`\n        <ha-labels-picker\n          no-add\n          .hass=${this.hass}\n          .value=${ensureArray(this.value ?? [])}\n          .required=${this.required}\n          .disabled=${this.disabled}\n          .label=${this.label}\n          @value-changed=${this._handleChange}\n        >\n        </ha-labels-picker>\n      `;\n    }\n    return html`\n      <ha-label-picker\n        no-add\n        .hass=${this.hass}\n        .value=${this.value}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        .label=${this.label}\n        @value-changed=${this._handleChange}\n      >\n      </ha-label-picker>\n    `;\n  }\n\n  private _handleChange(ev) {\n    let value = ev.detail.value;\n    if (this.value === value) {\n      return;\n    }\n    if (\n      (value === \"\" || (Array.isArray(value) && value.length === 0)) &&\n      !this.required\n    ) {\n      value = undefined;\n    }\n\n    fireEvent(this, \"value-changed\", { value });\n  }\n\n  static styles = css`\n    ha-labels-picker {\n      display: block;\n      width: 100%;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-label\": HaLabelSelector;\n  }\n}\n","export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n","import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"names":["HaLabelSelector","_LitElement","_this","_callSuper","concat","args","disabled","required","_this$value","this","selector","label","multiple","html","_t","_","hass","ensureArray","value","_handleChange","_t2","key","ev","detail","Array","isArray","length","undefined","fireEvent","LitElement","styles","css","_t3","attribute","type","Boolean","createStore","state","listeners","setState","update","overwrite","Object","assign","currentListeners","i","action","apply","result","arguments","push","ret","Promise","then","clearState","subscribe","listener","out","unsubscribe","getCollection","conn","fetchCollection","subscribeUpdates","options","unsubGrace","unsubProm","unsubTimer","active","store","refresh","Error","refreshSwallow","catch","err","connected","teardownUpdateSubscription","unsub","removeEventListener","handleDisconnect","clearTimeout","subscriber","setupUpdateSubscription","addEventListener","setTimeout","createCollection","onChange"],"mappings":"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"}