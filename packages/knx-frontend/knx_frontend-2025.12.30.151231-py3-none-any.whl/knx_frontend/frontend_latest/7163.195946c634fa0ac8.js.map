{"version":3,"file":"7163.195946c634fa0ac8.js","sources":["webpack://knx-frontend/./homeassistant-frontend/src/common/util/debounce.ts","webpack://knx-frontend/./homeassistant-frontend/src/common/util/promise-timeout.ts","webpack://knx-frontend/./homeassistant-frontend/src/resources/icon-metadata.ts","webpack://knx-frontend/./homeassistant-frontend/src/data/iconsets.ts","webpack://knx-frontend/./homeassistant-frontend/src/components/ha-icon.ts","webpack://knx-frontend/./homeassistant-frontend/src/data/custom_iconsets.ts","webpack://knx-frontend/./homeassistant-frontend/src/data/custom_icons.ts","webpack://knx-frontend/./node_modules/idb-keyval/dist/index.js"],"sourcesContent":["// From: https://davidwalsh.name/javascript-debounce-function\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge and on the trailing.\n\nexport const debounce = <T extends any[]>(\n  func: (...args: T) => void,\n  wait: number,\n  immediate = false\n) => {\n  let timeout: number | undefined;\n  const debouncedFunc = (...args: T): void => {\n    const later = () => {\n      timeout = undefined;\n      func(...args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = window.setTimeout(later, wait);\n    if (callNow) {\n      func(...args);\n    }\n  };\n  debouncedFunc.cancel = () => {\n    clearTimeout(timeout);\n  };\n  return debouncedFunc;\n};\n","class TimeoutError extends Error {\n  public timeout: number;\n\n  constructor(timeout: number, ...params) {\n    super(...params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, TimeoutError);\n    }\n\n    this.name = \"TimeoutError\";\n    // Custom debugging information\n    this.timeout = timeout;\n    this.message = `Timed out in ${timeout} ms.`;\n  }\n}\n\nexport const promiseTimeout = (ms: number, promise: Promise<any> | any) => {\n  const timeout = new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(new TimeoutError(ms));\n    }, ms);\n  });\n\n  // Returns a race between our timeout and the passed in promise\n  return Promise.race([promise, timeout]);\n};\n","import * as iconMetadata_ from \"../../build/mdi/iconMetadata.json\";\nimport type { IconMetaFile } from \"../types.js\";\n\nexport const iconMetadata = (iconMetadata_ as any).default as IconMetaFile;\n","import { clear, get, set, createStore, promisifyRequest } from \"idb-keyval\";\nimport memoizeOne from \"memoize-one\";\nimport { promiseTimeout } from \"../common/util/promise-timeout\";\nimport { iconMetadata } from \"../resources/icon-metadata\";\nimport type { IconMeta } from \"../types\";\n\nexport type Icons = Record<string, string>;\n\nexport type Chunks = Record<string, Promise<Icons>>;\n\nconst getStore = memoizeOne(async () => {\n  const iconStore = createStore(\"hass-icon-db\", \"mdi-icon-store\");\n\n  // Supervisor doesn't use icons, and should not update/downgrade the icon DB.\n  if (!__SUPERVISOR__) {\n    const version = await get(\"_version\", iconStore);\n\n    if (!version) {\n      set(\"_version\", iconMetadata.version, iconStore);\n    } else if (version !== iconMetadata.version) {\n      await clear(iconStore);\n      set(\"_version\", iconMetadata.version, iconStore);\n    }\n  }\n\n  return iconStore;\n});\n\nexport const MDI_PREFIXES = [\"mdi\", \"hass\", \"hassio\", \"hademo\"];\n\nlet toRead: [\n  string,\n  (iconPath: string | undefined) => void,\n  (e: any) => void,\n][] = [];\n\n// Queue up as many icon fetches in 1 transaction\nexport const getIcon = (iconName: string) =>\n  new Promise<string | undefined>((resolve, reject) => {\n    toRead.push([iconName, resolve, reject]);\n\n    if (toRead.length > 1) {\n      return;\n    }\n\n    // Start initializing the store, so it's ready when we need it\n    const iconStoreProm = getStore();\n    const readIcons = async () => {\n      const iconStore = await iconStoreProm;\n      iconStore(\"readonly\", (store) => {\n        for (const [iconName_, resolve_, reject_] of toRead) {\n          promisifyRequest<string | undefined>(store.get(iconName_))\n            .then((icon) => resolve_(icon))\n            .catch((e) => reject_(e));\n        }\n        toRead = [];\n      });\n    };\n\n    promiseTimeout(1000, readIcons()).catch((e) => {\n      // Firefox in private mode doesn't support IDB\n      // Safari sometime doesn't open the DB so we time out\n      for (const [, , reject_] of toRead) {\n        reject_(e);\n      }\n      toRead = [];\n    });\n  });\n\nexport const findIconChunk = (icon: string): string => {\n  let lastChunk: IconMeta;\n  for (const chunk of iconMetadata.parts) {\n    if (chunk.start !== undefined && icon < chunk.start) {\n      break;\n    }\n    lastChunk = chunk;\n  }\n  return lastChunk!.file;\n};\n\nexport const writeCache = async (chunks: Chunks) => {\n  const keys = Object.keys(chunks);\n  const iconsSets: Icons[] = await Promise.all(Object.values(chunks));\n  const iconStore = await getStore();\n  // We do a batch opening the store just once, for (considerable) performance\n  iconStore(\"readwrite\", (store) => {\n    iconsSets.forEach((icons, idx) => {\n      Object.entries(icons).forEach(([name, path]) => {\n        store.put(path, name);\n      });\n      delete chunks[keys[idx]];\n    });\n  });\n};\n","import type { PropertyValues } from \"lit\";\nimport { LitElement, css, html, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { debounce } from \"../common/util/debounce\";\nimport type { CustomIcon } from \"../data/custom_icons\";\nimport { customIcons } from \"../data/custom_icons\";\nimport type { Chunks, Icons } from \"../data/iconsets\";\nimport {\n  MDI_PREFIXES,\n  findIconChunk,\n  getIcon,\n  writeCache,\n} from \"../data/iconsets\";\nimport \"./ha-svg-icon\";\n\ntype DeprecatedIcon = Record<\n  string,\n  {\n    removeIn: string;\n    newName?: string;\n  }\n>;\n\nconst mdiDeprecatedIcons: DeprecatedIcon = {};\n\nconst chunks: Chunks = {};\n\nconst debouncedWriteCache = debounce(() => writeCache(chunks), 2000);\n\nconst cachedIcons: Record<string, string> = {};\n\n@customElement(\"ha-icon\")\nexport class HaIcon extends LitElement {\n  @property() public icon?: string;\n\n  @state() private _path?: string;\n\n  @state() private _secondaryPath?: string;\n\n  @state() private _viewBox?: string;\n\n  @state() private _legacy = false;\n\n  public willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"icon\")) {\n      this._path = undefined;\n      this._secondaryPath = undefined;\n      this._viewBox = undefined;\n      this._loadIcon();\n    }\n  }\n\n  protected render() {\n    if (!this.icon) {\n      return nothing;\n    }\n    if (this._legacy) {\n      return html`<!-- @ts-ignore we don't provide the iron-icon element -->\n        <iron-icon .icon=${this.icon}></iron-icon>`;\n    }\n    return html`<ha-svg-icon\n      .path=${this._path}\n      .secondaryPath=${this._secondaryPath}\n      .viewBox=${this._viewBox}\n    ></ha-svg-icon>`;\n  }\n\n  private async _loadIcon() {\n    if (!this.icon) {\n      return;\n    }\n    const requestedIcon = this.icon;\n    const [iconPrefix, origIconName] = this.icon.split(\":\", 2);\n\n    let iconName = origIconName;\n\n    if (!iconPrefix || !iconName) {\n      return;\n    }\n\n    if (!MDI_PREFIXES.includes(iconPrefix)) {\n      const customIcon = customIcons[iconPrefix];\n      if (customIcon) {\n        if (customIcon && typeof customIcon.getIcon === \"function\") {\n          this._setCustomPath(customIcon.getIcon(iconName), requestedIcon);\n        }\n        return;\n      }\n      this._legacy = true;\n      return;\n    }\n\n    this._legacy = false;\n\n    if (iconName in mdiDeprecatedIcons) {\n      const deprecatedIcon = mdiDeprecatedIcons[iconName];\n      let message: string;\n\n      if (deprecatedIcon.newName) {\n        message = `Icon ${iconPrefix}:${iconName} was renamed to ${iconPrefix}:${deprecatedIcon.newName}, please change your config, it will be removed in version ${deprecatedIcon.removeIn}.`;\n        iconName = deprecatedIcon.newName!;\n      } else {\n        message = `Icon ${iconPrefix}:${iconName} was removed from MDI, please replace this icon with an other icon in your config, it will be removed in version ${deprecatedIcon.removeIn}.`;\n      }\n      // eslint-disable-next-line no-console\n      console.warn(message);\n      fireEvent(this, \"write_log\", {\n        level: \"warning\",\n        message,\n      });\n    }\n\n    if (iconName in cachedIcons) {\n      this._path = cachedIcons[iconName];\n      return;\n    }\n\n    if (iconName === \"home-assistant\") {\n      const icon = (await import(\"../resources/home-assistant-logo-svg\"))\n        .mdiHomeAssistant;\n\n      if (this.icon === requestedIcon) {\n        this._path = icon;\n      }\n      cachedIcons[iconName] = icon;\n      return;\n    }\n\n    let databaseIcon: string | undefined;\n    try {\n      databaseIcon = await getIcon(iconName);\n    } catch (_err) {\n      // Firefox in private mode doesn't support IDB\n      // iOS Safari sometimes doesn't open the DB\n      databaseIcon = undefined;\n    }\n\n    if (databaseIcon) {\n      if (this.icon === requestedIcon) {\n        this._path = databaseIcon;\n      }\n      cachedIcons[iconName] = databaseIcon;\n      return;\n    }\n    const chunk = findIconChunk(iconName);\n\n    if (chunk in chunks) {\n      this._setPath(chunks[chunk], iconName, requestedIcon);\n      return;\n    }\n\n    const iconPromise = fetch(`/static/mdi/${chunk}.json`).then((response) =>\n      response.json()\n    );\n    chunks[chunk] = iconPromise;\n    this._setPath(iconPromise, iconName, requestedIcon);\n    debouncedWriteCache();\n  }\n\n  private async _setCustomPath(\n    promise: Promise<CustomIcon>,\n    requestedIcon: string\n  ) {\n    const icon = await promise;\n    if (this.icon !== requestedIcon) {\n      return;\n    }\n    this._path = icon.path;\n    this._secondaryPath = icon.secondaryPath;\n    this._viewBox = icon.viewBox;\n  }\n\n  private async _setPath(\n    promise: Promise<Icons>,\n    iconName: string,\n    requestedIcon: string\n  ) {\n    const iconPack = await promise;\n    if (this.icon === requestedIcon) {\n      this._path = iconPack[iconName];\n    }\n    cachedIcons[iconName] = iconPack[iconName];\n  }\n\n  static styles = css`\n    :host {\n      fill: currentcolor;\n    }\n  `;\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-icon\": HaIcon;\n  }\n}\n","import type { CustomIcon } from \"./custom_icons\";\n\ninterface CustomIconsetsWindow {\n  customIconsets?: Record<string, (name: string) => Promise<CustomIcon>>;\n}\n\nconst customIconsetsWindow = window as CustomIconsetsWindow;\n\nif (!(\"customIconsets\" in customIconsetsWindow)) {\n  customIconsetsWindow.customIconsets = {};\n}\n\nexport const customIconsets = customIconsetsWindow.customIconsets!;\n","import { customIconsets } from \"./custom_iconsets\";\n\nexport interface CustomIcon {\n  path: string;\n  secondaryPath?: string;\n  viewBox?: string;\n}\n\nexport interface CustomIconListItem {\n  name: string;\n  keywords?: string[];\n}\n\nexport interface CustomIconHelpers {\n  getIcon: (name: string) => Promise<CustomIcon>;\n  getIconList?: () => Promise<CustomIconListItem[]>;\n}\n\nexport interface CustomIconsWindow {\n  customIcons?: Record<string, CustomIconHelpers>;\n}\n\nconst customIconsWindow = window as CustomIconsWindow;\n\nif (!(\"customIcons\" in customIconsWindow)) {\n  customIconsWindow.customIcons = {};\n}\n\n// Proxy for backward compatibility with icon sets\nexport const customIcons = new Proxy(customIconsWindow.customIcons!, {\n  get: (obj, prop: string) =>\n    obj[prop] ??\n    (customIconsets[prop]\n      ? {\n          getIcon: customIconsets[prop],\n        }\n      : undefined),\n});\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n"],"names":["debounce","func","wait","immediate","timeout","debouncedFunc","args","callNow","clearTimeout","window","setTimeout","later","undefined","cancel","TimeoutError","Error","constructor","params","super","captureStackTrace","this","name","message","iconMetadata","getStore","memoizeOne","iconStore","createStore","version","get","clear","set","MDI_PREFIXES","toRead","getIcon","iconName","Promise","resolve","reject","push","length","iconStoreProm","promiseTimeout","ms","promise","_resolve","race","store","iconName_","resolve_","reject_","promisifyRequest","then","icon","catch","e","readIcons","mdiDeprecatedIcons","chunks","debouncedWriteCache","keys","Object","iconsSets","all","values","forEach","icons","idx","entries","path","put","writeCache","cachedIcons","HaIcon","LitElement","willUpdate","changedProps","has","_path","_secondaryPath","_viewBox","_loadIcon","render","_legacy","html","nothing","requestedIcon","iconPrefix","origIconName","split","databaseIcon","customIcon","customIcons","_setCustomPath","deprecatedIcon","newName","removeIn","console","warn","fireEvent","level","mdiHomeAssistant","_err","chunk","lastChunk","start","file","findIconChunk","_setPath","iconPromise","fetch","response","json","secondaryPath","viewBox","iconPack","styles","css","customIconsetsWindow","customIconsets","customIconsWindow","Proxy","obj","prop","request","oncomplete","onsuccess","result","onabort","onerror","error","dbName","storeName","dbp","txMode","callback","getDB","indexedDB","open","onupgradeneeded","createObjectStore","db","onclose","transaction","objectStore","defaultGetStoreFunc","defaultGetStore","key","customStore","value"],"mappings":"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"}