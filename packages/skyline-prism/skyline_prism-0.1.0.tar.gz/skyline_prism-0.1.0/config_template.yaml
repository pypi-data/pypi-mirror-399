# PRISM Configuration Template
# Skyline-PRISM: Proteomics Reference-Integrated Signal Modeling
#
# Copy this file and modify for your experiment.
# See SPECIFICATION.md for detailed documentation of all options.

# =============================================================================
# Data Column Mapping
# =============================================================================
# Map your Skyline report column names to PRISM internal names.
# These are the defaults for standard Skyline exports.

data:
  # Abundance measurement column (usually from transitions)
  abundance_column: "TotalAreaFragment"  # or "TotalAreaMs1" for MS1 quant
  
  # Retention time column
  rt_column: "BestRetentionTime"
  
  # Peptide identification
  peptide_column: "PeptideModifiedSequence"  # Modified forms are separate peptides
  
  # For transition-level data (optional)
  precursor_column: "PrecursorCharge"
  fragment_column: "FragmentIon"
  
  # Protein identification
  protein_column: "ProteinAccession"  # UniProt accessions preferred
  protein_name_column: "ProteinName"
  
  # Sample identification
  sample_column: "ReplicateName"
  batch_column: "Batch"
  run_order_column: "RunOrder"
  sample_type_column: "SampleType"

# =============================================================================
# Sample Type Detection
# =============================================================================
# Patterns to automatically identify sample types from replicate names.
# These are substring matches (not regex) checked in order.
# Can be a single pattern string or a list of patterns.

sample_annotations:
  # Inter-experiment reference (commercial pool for RT model learning)
  # Samples matching these patterns are used to learn technical variation
  reference_pattern:
    - "-Pool_"
    - "-Pool"
    - "_Pool_"
    - "GoldenWest"
    - "CommercialPool"
    - "InterExpRef"
  
  # Intra-experiment QC (pooled experimental samples for validation)
  # Samples matching these patterns are used to validate corrections
  qc_pattern:
    - "-Carl_"
    - "-QC_"
    - "_QC_"
    - "StudyPool"
    - "IntraPool"
  
  # Experimental samples: everything not matching above patterns
  experimental_pattern: "^(?!.*(Pool|Ref)).*"

# =============================================================================
# Batch Estimation
# =============================================================================
# When batch information is not provided in metadata, PRISM estimates batches
# using: 1) source_document, 2) acquisition time gaps, or 3) equal division.
#
# Include "Result File > Acquired Time" in your Skyline report for best results.

batch_estimation:
  # Expected samples per batch (for validation and fallback estimation)
  min_samples_per_batch: 12   # Typical 96-well plate minimum
  max_samples_per_batch: 100  # Typical 96-well plate maximum
  
  # IQR multiplier for outlier gap detection
  # A gap is considered a batch break if: gap > Q3 + (multiplier * IQR)
  # 
  # Example: If runs are typically 65 min apart (±2 min), the IQR would be ~4 min.
  # With multiplier=1.5, threshold ≈ 67 + 1.5*4 = 73 min.
  # An overnight break (e.g., 90 min gap) would be detected as a batch boundary.
  gap_iqr_multiplier: 1.5
  
  # Force a specific number of batches (null = automatic estimation)
  # Only used if other estimation methods fail
  n_batches: null

# =============================================================================
# Sample Outlier Detection
# =============================================================================
# Automatically detect and optionally exclude samples with abnormally low signal.
# This identifies samples with potential failed injections, degradation, or other
# technical issues that would compromise downstream analysis.
#
# Detection is performed on LINEAR scale (not log) to avoid scale compression.
# Only LOW outliers are flagged (one-sided) - high signal samples are not excluded.

sample_outlier_detection:
  enabled: true  # Enable outlier detection
  
  # Action to take when outliers are detected:
  # - "report": Log outliers but include them in analysis (default)
  # - "exclude": Exclude outliers from analysis
  action: "report"
  
  # Detection method: "iqr" or "fold_median"
  # - iqr: Samples below Q1 - (multiplier * IQR) on linear scale
  # - fold_median: Samples with median intensity < threshold * overall median
  method: "iqr"
  
  # IQR multiplier for outlier threshold (used if method: iqr)
  # Lower values = more aggressive outlier detection
  iqr_multiplier: 1.5
  
  # Fold-change threshold (used if method: fold_median)
  # Sample is outlier if: sample_median < (fold_threshold * overall_median)
  # E.g., 0.1 means samples with <10% of overall median are flagged
  fold_threshold: 0.1

# =============================================================================
# Processing Performance
# =============================================================================
# Settings for parallel processing and memory management.
# Adjust based on your machine's CPU and RAM availability.

processing:
  # Number of parallel workers for peptide rollup
  # - 1: Single-threaded (default, lowest memory usage)
  # - 0: Use all available CPUs
  # - N: Use N worker processes
  #
  # Parallel processing can significantly speed up large datasets.
  # Memory usage scales approximately with n_workers * peptide_batch_size.
  n_workers: 1
  
  # Number of peptides to process in each batch
  # Larger batches are more efficient but use more memory.
  # Recommended: 500-2000 depending on available RAM.
  peptide_batch_size: 1000

# =============================================================================
# Stage 0: Transition to Peptide Rollup
# =============================================================================
# Only used if input is transition-level data from Skyline.

transition_rollup:
  enabled: true  # Set true if input has individual transitions
  
  # Rollup method: sum, median_polish, adaptive, topn
  # - sum: Simple sum of all fragment intensities (default, robust)
  # - median_polish: Tukey median polish (robust to interference)
  # - adaptive: Learned weight function based on intensity, m/z, and shape correlation
  # - topn: Select top N transitions by correlation consistency, weight by sqrt(intensity)
  #
  # Note: Sum is recommended for most datasets. Adaptive and topn
  # may improve CV for high-quality data with good shape correlation.
  method: "sum"
  
  # Whether to include MS1 precursor signal in quantification
  # - false: Use only MS2 fragment ions (recommended, more specific)
  # - true: Include MS1 precursor isotopes
  use_ms1: false
  
  # Minimum transitions required per peptide
  min_transitions: 3
  
  # -------------------------------------------------------------------------
  # Top-N Method Parameters (only used if method: topn)
  # -------------------------------------------------------------------------
  # Number of transitions to select per peptide (same transitions for all samples)
  topn_count: 3
  
  # Selection method: how to choose which transitions to use
  # - correlation: select transitions with highest median shape correlation
  # - intensity: select transitions with highest mean intensity
  topn_selection: "correlation"
  
  # Weighting method: how to combine selected transitions
  # - sum: simple sum of selected transitions (equal weights)
  # - sqrt: weight by sqrt(intensity) before summing
  topn_weighting: "sqrt"
  
  # -------------------------------------------------------------------------
  # Adaptive Rollup Parameters (only used if method: adaptive)
  # -------------------------------------------------------------------------
  # Learn parameters from reference samples (recommended for adaptive method)
  # When true, optimizes beta parameters by minimizing median CV across peptides
  # in reference samples. Validated on QC samples to ensure generalization.
  # Requires at least 2 reference samples.
  learn_weights: false  # Learn parameters from reference samples
  
  # Adaptive rollup uses a learned weight function with 4 features:
  #
  #   log(w) = beta_relative_intensity * relative_intensity
  #          + beta_mz * normalized_mz
  #          + beta_shape_corr * median_shape_corr
  #          + beta_shape_corr_outlier * low_fraction
  #
  # Features:
  # - relative_intensity: Transition intensity / max intensity in the peptide [0,1]
  #                       Computed per-peptide so the most intense transition = 1.0
  # - normalized_mz: Fragment ion m/z normalized to [0,1] range
  # - median_shape_corr: Median shape correlation across all replicates
  # - low_fraction: Fraction of replicates with low shape correlation
  #                 (below shape_corr_low_threshold, default 0.7)
  #
  # Not optimized (reserved for future use):
  # - beta_shape_corr_max: Max shape correlation - kept at 0.0
  #
  # Key insight: When all betas = 0, weights = 1 for all transitions,
  # equivalent to simple sum. This is the baseline for comparison.
  #
  # Constraints:
  # - beta_relative_intensity >= 0 (higher intensity should not decrease weight)
  # - Other betas are unconstrained (can be positive or negative)
  #
  # When learn_weights: true, 4 betas are optimized simultaneously.
  # Normalization parameters (centers, scales, thresholds) are computed 
  # from reference samples and saved in metadata.json for reproducibility.
  #
  adaptive_rollup:
    beta_relative_intensity: 0.0  # Weight by relative intensity [0,1] (>= 0)
    beta_mz: 0.0                  # Weight by m/z (any value)
    beta_shape_corr: 0.0          # Weight by median shape correlation (any value)
    beta_shape_corr_outlier: 0.0  # Weight by low-fraction (any value)
    shape_corr_low_threshold: 0.7 # Threshold for "low" shape correlation (0-1)
    mz_normalize: true            # Normalize m/z to [0,1] range
    min_improvement_pct: 5.0      # Min improvement over sum to use adaptive weights

# =============================================================================
# Stage 1: RT-Aware Normalization (DISABLED BY DEFAULT)
# =============================================================================
# Reference-anchored correction for RT-dependent technical variation.
#
# NOTE: RT correction is DISABLED by default. DIA-NN and other search engines
# apply per-file RT calibration that may not generalize between reference and
# experimental samples, making spline-based RT correction unreliable.
#
# The implementation is preserved for future experimentation.

rt_correction:
  enabled: false  # Disabled by default - see note above
  
  # Method: spline, loess, ruv, combat_rt
  method: "spline"
  
  # Degrees of freedom for spline (higher = more flexible)
  spline_df: 5
  
  # Fit separate models per batch (recommended if enabled)
  per_batch: true
  
  # Minimum peptides per RT bin for robust estimation
  min_peptides_per_bin: 10

# =============================================================================
# Stage 2: Global Normalization
# =============================================================================
# Address overall sample loading differences.

global_normalization:
  # Method: median, vsn, quantile, none
  #
  # median   - Subtract sample median; shifts all samples to common baseline
  #            Simple, robust, and preserves original log2 scale
  #            RECOMMENDED for most proteomics experiments
  #
  # vsn      - Variance Stabilizing Normalization using arcsinh transformation
  #            Stabilizes variance across intensity range (heteroscedasticity)
  #            Output is on arcsinh-transformed scale, NOT log2
  #            Use when low-abundance proteins show high variance
  #
  # quantile - Forces identical sample distributions
  #            Strong normalization that may over-correct
  #
  # none     - Skip global normalization
  #
  method: "median"

  # VSN parameters (only used when method: vsn)
  vsn_params:
    # Whether to optimize transformation parameters per sample
    # - false (default): Use fast median-based scaling (a = 1/median)
    # - true: Optimize parameters to minimize variance heterogeneity
    #         using Nelder-Mead optimization. Slower but may give
    #         better variance stabilization for some datasets.
    optimize_params: false

# =============================================================================
# Stage 3: Batch Correction
# =============================================================================
# Remove systematic batch effects using ComBat (empirical Bayes).

batch_correction:
  enabled: true
  
  # Method: combat, none
  # ComBat uses empirical Bayes shrinkage for robust batch effect estimation
  method: "combat"

# =============================================================================
# Protein Parsimony
# =============================================================================
# How to handle shared peptides that map to multiple proteins.
#
# IMPORTANT: Parsimony requires the search FASTA database to correctly
# determine peptide-to-protein mappings. Peptides are matched to proteins
# using direct sequence lookup.

parsimony:
  # Path to the FASTA database used for the original search
  # REQUIRED for correct peptide-to-protein mapping
  fasta_path: example-files/uniprot_mouse_may2025_contam_yeastENO1.fasta  # e.g., "/path/to/uniprot_human_reviewed.fasta"
  
  # Strategy: all_groups, unique_only, razor
  # 
  # all_groups (recommended): Apply shared peptides to ALL protein groups
  #   - Acknowledges proteoform complexity
  #   - Avoids assumptions based on FASTA annotations
  #
  # unique_only: Only use peptides unique to a single protein group
  #   - Most conservative
  #   - May lose proteins with few unique peptides
  #
  # razor: Assign shared peptides to group with most peptides
  #   - MaxQuant-style
  #   - Makes strong assumptions about protein presence
  
  shared_peptide_handling: "all_groups"

# =============================================================================
# Protein Rollup
# =============================================================================
# Combine peptides into protein-level quantities.

protein_rollup:
  # Method for combining peptides into protein abundances:
  #
  # sum (default): Simple sum of all peptide intensities
  #   - Fast and straightforward
  #   - Good baseline for most analyses
  #
  # median_polish: Tukey median polish - robust two-way decomposition
  #   - Separates peptide ionization effects from sample abundances
  #   - Automatically downweights outliers through median operation
  #   - Handles missing values naturally
  #
  # topn: Average of top N most intense peptides (SAME peptides across all samples)
  #   - Selects N peptides with highest median abundance across samples
  #   - Uses those SAME peptides for all samples (ensures comparability)
  #   - Simple and interpretable
  #   - Selected peptides are reported in output
  #
  # ibaq: iBAQ (Intensity-Based Absolute Quantification)
  #   - Sum of intensities / theoretical peptide count
  #   - Enables cross-protein abundance comparison
  #   - Requires FASTA and enzyme settings (see ibaq section below)
  #
  # maxlfq: Maximum LFQ algorithm (MaxQuant-style)
  #   - Uses median pairwise peptide ratios between samples
  #   - Good when relative quantification is more reliable than absolute
  #
  method: "sum"
  
  # Top-N specific settings (used when method: topn)
  topn:
    n: 3                              # Number of top peptides to use
    selection: "median_abundance"     # How to rank: median_abundance, frequency
  
  # iBAQ specific settings (REQUIRED when method: ibaq)
  # iBAQ normalizes protein abundances by the number of theoretical peptides
  ibaq:
    fasta_path: null                  # Path to search FASTA (REQUIRED for iBAQ)
    enzyme: "trypsin"                 # Enzyme for theoretical digestion
    missed_cleavages: 0               # Typically 0 for iBAQ counting
    min_peptide_length: 6             # Minimum peptide length
    max_peptide_length: 30            # Maximum peptide length
  
  # For topn method
  topn:
    n: 3  # Number of peptides to select
    # Selection criterion: how to rank peptides for selection
    # Options:
    #   - median_abundance: Peptides with highest median across samples (default)
    #   - frequency: Peptides detected in most samples, then by abundance
    selection: "median_abundance"
  
  # For median_polish method
  median_polish:
    max_iterations: 20
    convergence_tolerance: 0.0001

# =============================================================================
# Output Options
# =============================================================================

output:
  # File format: parquet, csv, tsv
  format: "parquet"
  
  # Output directory (relative to working directory or absolute path)
  # output_dir: "prism_output/"
  
  # The pipeline always produces both:
  # - corrected_peptides.parquet: peptide-level quantities (batch-corrected)
  # - corrected_proteins.parquet: protein-level quantities (batch-corrected)
  # - protein_groups.tsv: protein group definitions from parsimony
  
  # Include median polish residuals for outlier analysis
  # Following Plubell et al. 2022, residuals may indicate biologically
  # interesting variation (proteoforms, PTMs, protein processing)
  include_residuals: true
  
  # Compress output files
  compress: true

# =============================================================================
# QC Report Options
# =============================================================================

qc_report:
  # Generate QC report
  enabled: true
  
  # Output filename (relative to output directory)
  filename: "qc_report.html"
  
  # Save individual PNG plots to qc_plots/ subdirectory
  save_plots: true
  
  # Embed plots directly in HTML (larger file but self-contained)
  embed_plots: true
  
  # Plots to include (all enabled by default)
  # Each plot type is generated for both peptide and protein levels
  # showing before/after normalization and batch correction comparisons
  plots:
    # Intensity distribution density plots
    # Shows sample distribution alignment before/after correction
    intensity_distribution: true
    
    # PCA comparison plots
    # Shows batch effects and sample grouping before/after correction
    # Samples are colored by type (experimental, reference, pool)
    pca_comparison: true
    
    # Correlation heatmap for control samples
    # Shows reproducibility of reference and QC samples after correction
    control_correlation: true
    
    # CV (coefficient of variation) histograms
    # Shows precision improvement for reference and QC samples
    # Generated separately for reference and pool sample types
    cv_distribution: true
    
    # RT-dependent residuals (only if RT correction is enabled)
    rt_correction: true
