//! # Fiqh Compliance: Business Assets (Urud al-Tijarah)
//!
//! ## Obligation
//! - Based on the Hadith of Samurah bin Jundub: "The Prophet (ï·º) commanded us to pay Zakat from what we prepared for sale." (Sunan Abu Dawud 1562).
//!
//! ## Valuation Logic
//! - **Formula**: `(Cash + Market Value of Inventory + Good Receivables) - Immediate Liabilities`.
//! - **Valuation**: Inventory must be valued at current *Market Price* at the time of Zakat, not Cost Price.
//! - **Debts**: Deducting `liabilities_due_now` aligns with the principle of *Dayn al-Hal* (immediate debt) preventing Zakat, as supported by AAOIFI Standard 35.

use rust_decimal::Decimal;
use crate::types::{ZakatDetails, ZakatError};
use crate::math::ZakatDecimal;
use serde::{Serialize, Deserialize};
use crate::traits::{CalculateZakat, ZakatConfigArgument};

use crate::inputs::IntoZakatDecimal;

// Use the zakat_asset! macro to generate common fields and setters
crate::zakat_asset! {
    /// Represents Business Assets for Zakat Calculation.
    /// 
    /// # Fiqh Note on Liabilities
    /// `liabilities_due_now` represents **Dayn al-Hal** (Immediate Debt). 
    /// Long-term non-commercial debts (like 20-year mortgages) should not be fully deducted; 
    /// only the upcoming year's payments should be considered (per AAOIFI).
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct BusinessZakat {
        // Assets
        pub cash_on_hand: Decimal,
        pub inventory_value: Decimal,
        pub receivables: Decimal,
        // Business-specific liabilities (separate from common liabilities_due_now)
        pub short_term_liabilities: Decimal,
    }
}

impl Default for BusinessZakat {
    fn default() -> Self {
        Self {
            cash_on_hand: Decimal::ZERO,
            inventory_value: Decimal::ZERO,
            receivables: Decimal::ZERO,
            short_term_liabilities: Decimal::ZERO,
            // Common fields (auto-generated by macro but need defaults)
            liabilities_due_now: Decimal::ZERO,
            hawl_satisfied: true,
            label: None,
            _id: uuid::Uuid::new_v4(),
            _input_errors: Vec::new(),
        }
    }
}

impl BusinessZakat {
    // Note: new(), debt(), hawl(), label() are generated by the macro

    /// Creates a BusinessZakat instance for a business with only cash assets.
    /// Sets defaults: No inventory, no receivables, no liabilities, Hawl satisfied.
    pub fn cash_only(amount: impl IntoZakatDecimal) -> Self {
        Self::new()
            .cash(amount)
            .hawl(true)
    }

    /// Sets cash on hand.
    /// 
    /// If the value cannot be converted to a valid decimal, the error is
    /// collected and will be returned by `validate()` or `calculate_zakat()`.
    pub fn cash(mut self, cash: impl IntoZakatDecimal) -> Self {
        match cash.into_zakat_decimal() {
            Ok(v) => self.cash_on_hand = v,
            Err(e) => self._input_errors.push(e),
        }
        self
    }

    /// Sets inventory value.
    /// 
    /// If the value cannot be converted to a valid decimal, the error is
    /// collected and will be returned by `validate()` or `calculate_zakat()`.
    pub fn inventory(mut self, inventory: impl IntoZakatDecimal) -> Self {
        match inventory.into_zakat_decimal() {
            Ok(v) => self.inventory_value = v,
            Err(e) => self._input_errors.push(e),
        }
        self
    }

    /// Sets receivables (money owed to the business).
    /// 
    /// If the value cannot be converted to a valid decimal, the error is
    /// collected and will be returned by `validate()` or `calculate_zakat()`.
    pub fn receivables(mut self, receivables: impl IntoZakatDecimal) -> Self {
        match receivables.into_zakat_decimal() {
            Ok(v) => self.receivables = v,
            Err(e) => self._input_errors.push(e),
        }
        self
    }

    /// Sets short-term business liabilities (deducted from gross assets).
    /// 
    /// If the value cannot be converted to a valid decimal, the error is
    /// collected and will be returned by `validate()` or `calculate_zakat()`.
    pub fn liabilities(mut self, liabilities: impl IntoZakatDecimal) -> Self {
        match liabilities.into_zakat_decimal() {
            Ok(v) => self.short_term_liabilities = v,
            Err(e) => self._input_errors.push(e),
        }
        self
    }
}

impl CalculateZakat for BusinessZakat {
    fn calculate_zakat<C: ZakatConfigArgument>(&self, config: C) -> Result<ZakatDetails, ZakatError> {
        // Validate deferred input errors first
        self.validate()?;
        
        let config_cow = config.resolve_config();
        let config = config_cow.as_ref();

        // Validation moved here
        if self.cash_on_hand < Decimal::ZERO || self.inventory_value < Decimal::ZERO || self.receivables < Decimal::ZERO {
            return Err(ZakatError::InvalidInput {
                field: "business_assets".to_string(),
                value: "negative".to_string(),
                reason: "Business assets must be non-negative".to_string(),
                source_label: self.label.clone(),
                asset_id: None,
            });
        }
        if self.short_term_liabilities < Decimal::ZERO || self.liabilities_due_now < Decimal::ZERO {
             return Err(ZakatError::InvalidInput {
                field: "liabilities".to_string(),
                value: "negative".to_string(),
                reason: "Liabilities must be non-negative".to_string(),
                source_label: self.label.clone(),
                asset_id: None,
             });
        }

        // For LowerOfTwo or Silver standard, we need silver price too
        let needs_silver = matches!(
            config.cash_nisab_standard,
            crate::madhab::NisabStandard::Silver | crate::madhab::NisabStandard::LowerOfTwo
        );
        
        if config.gold_price_per_gram <= Decimal::ZERO && !needs_silver {
            return Err(ZakatError::ConfigurationError {
                reason: "Gold price needed for Business Nisab".to_string(),
                source_label: self.label.clone(),
                asset_id: None,
            });
        }
        if needs_silver && config.silver_price_per_gram <= Decimal::ZERO {
            return Err(ZakatError::ConfigurationError {
                reason: "Silver price needed for Business Nisab with current standard".to_string(),
                source_label: self.label.clone(),
                asset_id: None,
            });
        }
        
        // Dynamic Nisab threshold based on config (Gold, Silver, or LowerOfTwo)
        let nisab_threshold_value = config.get_monetary_nisab_threshold();

        if !self.hawl_satisfied {
            return Ok(ZakatDetails::below_threshold(nisab_threshold_value, crate::types::WealthType::Business, "Hawl (1 lunar year) not met")
                .with_label(self.label.clone().unwrap_or_default()));
        }
        
        let gross_assets = ZakatDecimal::new(self.cash_on_hand)
            .safe_add(self.inventory_value)?
            .safe_add(self.receivables)?
            .with_source(self.label.clone());
            
        let total_liabilities = ZakatDecimal::new(self.short_term_liabilities)
            .safe_add(self.liabilities_due_now)?
            .with_source(self.label.clone());

        // Dynamic Zakat Rate from strategy (default 2.5%)
        let rate = config.strategy.get_rules().trade_goods_rate;

        // Build calculation trace
        // Note: gross_assets and total_liabilities are ZakatDecimal wrapper
        let net_assets_dec = gross_assets.safe_sub(*total_liabilities)?.0;
        let mut trace = vec![
            crate::types::CalculationStep::initial("step-cash-on-hand", "Cash on Hand", self.cash_on_hand),
            crate::types::CalculationStep::add("step-inventory-value", "Inventory Value", self.inventory_value),
            crate::types::CalculationStep::add("step-receivables", "Receivables", self.receivables),
            crate::types::CalculationStep::result("step-gross-assets", "Gross Assets", *gross_assets),
            crate::types::CalculationStep::subtract("step-short-term-liabilities", "Short-term Liabilities", self.short_term_liabilities),
            crate::types::CalculationStep::subtract("step-debts-due-now", "Debts Due Now", self.liabilities_due_now),
            crate::types::CalculationStep::result("step-net-business-assets", "Net Business Assets", net_assets_dec),
            crate::types::CalculationStep::compare("step-nisab-check", "Nisab Threshold", nisab_threshold_value),
        ];

        // We rely on ZakatDetails::with_trace to calculate final amounts, 
        // but we add a trace step for rate/info.
        if net_assets_dec >= nisab_threshold_value && net_assets_dec > Decimal::ZERO {
            trace.push(crate::types::CalculationStep::rate("step-rate-applied", "Applied Trade Goods Rate", rate));
        } else {
             trace.push(crate::types::CalculationStep::info("status-exempt", "Net Assets below Nisab - No Zakat Due"));
        }

        Ok(ZakatDetails::with_trace(
            *gross_assets, 
            *total_liabilities, 
            nisab_threshold_value, 
            rate, 
            crate::types::WealthType::Business, 
            trace
        ).with_label(self.label.clone().unwrap_or_default()))
    }

    fn get_label(&self) -> Option<String> {
        self.label.clone()
    }

    fn get_id(&self) -> uuid::Uuid {
        self._id
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::ZakatConfig;
    use rust_decimal_macros::dec;

    #[test]
    fn test_business_zakat() {
        let config = ZakatConfig { gold_price_per_gram: Decimal::from(100), ..Default::default() };
        
        let business = BusinessZakat::new()
            .cash(5000.0)
            .inventory(5000.0)
            .liabilities(1000.0)
            .hawl(true);

        let result = business.calculate_zakat(&config).unwrap();

        assert!(result.is_payable);
        assert_eq!(result.net_assets, Decimal::from(9000));
        assert_eq!(result.zakat_due, dec!(225.0)); // 225.0
    }

    #[test]
    fn test_business_below_nisab() {
         let config = ZakatConfig { gold_price_per_gram: Decimal::from(100), ..Default::default() };
         let business = BusinessZakat::new()
             .cash(1000.0)
             .inventory(1000.0);
         
         let result = business.calculate_zakat(&config).unwrap();
         
         assert!(!result.is_payable);
    }

    #[test]
    fn test_business_specific_case() {
        let config = ZakatConfig { gold_price_per_gram: Decimal::from(1000000), ..Default::default() };
        
        let business = BusinessZakat::new()
            .cash(100000000.0)
            .liabilities(20000000.0)
            .hawl(true);
        
        let result = business.calculate_zakat(&config).unwrap();
        
        assert!(!result.is_payable);
        assert_eq!(result.net_assets, Decimal::from(80000000));
    }

    #[test]
    fn test_business_validation() {
        let config = ZakatConfig::default();
        let business = BusinessZakat::new()
            .cash(-100.0);
            
        let result = business.calculate_zakat(&config);
        assert!(matches!(result, Err(ZakatError::InvalidInput { .. })));
    }
}
