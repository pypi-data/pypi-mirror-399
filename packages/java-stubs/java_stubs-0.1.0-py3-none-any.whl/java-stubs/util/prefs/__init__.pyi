
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import jpype
import typing



class BackingStoreException(java.lang.Exception):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class InvalidPreferencesFormatException(java.lang.Exception):
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str]): ...
    @typing.overload
    def __init__(self, string: typing.Union[java.lang.String, str], throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class NodeChangeEvent(java.util.EventObject):
    def __init__(self, preferences: 'Preferences', preferences2: 'Preferences'): ...
    def getChild(self) -> 'Preferences': ...
    def getParent(self) -> 'Preferences': ...

class NodeChangeListener(java.util.EventListener):
    def childAdded(self, nodeChangeEvent: NodeChangeEvent) -> None: ...
    def childRemoved(self, nodeChangeEvent: NodeChangeEvent) -> None: ...

class PreferenceChangeEvent(java.util.EventObject):
    def __init__(self, preferences: 'Preferences', string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]): ...
    def getKey(self) -> java.lang.String: ...
    def getNewValue(self) -> java.lang.String: ...
    def getNode(self) -> 'Preferences': ...

class PreferenceChangeListener(java.util.EventListener):
    def preferenceChange(self, preferenceChangeEvent: PreferenceChangeEvent) -> None: ...

class Preferences:
    MAX_KEY_LENGTH: typing.ClassVar[int] = ...
    MAX_VALUE_LENGTH: typing.ClassVar[int] = ...
    MAX_NAME_LENGTH: typing.ClassVar[int] = ...
    def absolutePath(self) -> java.lang.String: ...
    def addNodeChangeListener(self, nodeChangeListener: NodeChangeListener) -> None: ...
    def addPreferenceChangeListener(self, preferenceChangeListener: typing.Union[PreferenceChangeListener, typing.Callable]) -> None: ...
    def childrenNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def clear(self) -> None: ...
    def exportNode(self, outputStream: java.io.OutputStream) -> None: ...
    def exportSubtree(self, outputStream: java.io.OutputStream) -> None: ...
    def flush(self) -> None: ...
    def get(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def getBoolean(self, string: typing.Union[java.lang.String, str], boolean: bool) -> bool: ...
    def getByteArray(self, string: typing.Union[java.lang.String, str], byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.MutableSequence[int]: ...
    def getDouble(self, string: typing.Union[java.lang.String, str], double: float) -> float: ...
    def getFloat(self, string: typing.Union[java.lang.String, str], float: float) -> float: ...
    def getInt(self, string: typing.Union[java.lang.String, str], int: int) -> int: ...
    def getLong(self, string: typing.Union[java.lang.String, str], long: int) -> int: ...
    @staticmethod
    def importPreferences(inputStream: java.io.InputStream) -> None: ...
    def isUserNode(self) -> bool: ...
    def keys(self) -> typing.MutableSequence[java.lang.String]: ...
    def name(self) -> java.lang.String: ...
    def node(self, string: typing.Union[java.lang.String, str]) -> 'Preferences': ...
    def nodeExists(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def parent(self) -> 'Preferences': ...
    def put(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def putBoolean(self, string: typing.Union[java.lang.String, str], boolean: bool) -> None: ...
    def putByteArray(self, string: typing.Union[java.lang.String, str], byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    def putDouble(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def putFloat(self, string: typing.Union[java.lang.String, str], float: float) -> None: ...
    def putInt(self, string: typing.Union[java.lang.String, str], int: int) -> None: ...
    def putLong(self, string: typing.Union[java.lang.String, str], long: int) -> None: ...
    def remove(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def removeNode(self) -> None: ...
    def removeNodeChangeListener(self, nodeChangeListener: NodeChangeListener) -> None: ...
    def removePreferenceChangeListener(self, preferenceChangeListener: typing.Union[PreferenceChangeListener, typing.Callable]) -> None: ...
    def sync(self) -> None: ...
    @staticmethod
    def systemNodeForPackage(class_: typing.Type[typing.Any]) -> 'Preferences': ...
    @staticmethod
    def systemRoot() -> 'Preferences': ...
    def toString(self) -> java.lang.String: ...
    @staticmethod
    def userNodeForPackage(class_: typing.Type[typing.Any]) -> 'Preferences': ...
    @staticmethod
    def userRoot() -> 'Preferences': ...

class PreferencesFactory:
    def systemRoot(self) -> Preferences: ...
    def userRoot(self) -> Preferences: ...

class AbstractPreferences(Preferences):
    def absolutePath(self) -> java.lang.String: ...
    def addNodeChangeListener(self, nodeChangeListener: NodeChangeListener) -> None: ...
    def addPreferenceChangeListener(self, preferenceChangeListener: typing.Union[PreferenceChangeListener, typing.Callable]) -> None: ...
    def childrenNames(self) -> typing.MutableSequence[java.lang.String]: ...
    def clear(self) -> None: ...
    def exportNode(self, outputStream: java.io.OutputStream) -> None: ...
    def exportSubtree(self, outputStream: java.io.OutputStream) -> None: ...
    def flush(self) -> None: ...
    def get(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> java.lang.String: ...
    def getBoolean(self, string: typing.Union[java.lang.String, str], boolean: bool) -> bool: ...
    def getByteArray(self, string: typing.Union[java.lang.String, str], byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> typing.MutableSequence[int]: ...
    def getDouble(self, string: typing.Union[java.lang.String, str], double: float) -> float: ...
    def getFloat(self, string: typing.Union[java.lang.String, str], float: float) -> float: ...
    def getInt(self, string: typing.Union[java.lang.String, str], int: int) -> int: ...
    def getLong(self, string: typing.Union[java.lang.String, str], long: int) -> int: ...
    def isUserNode(self) -> bool: ...
    def keys(self) -> typing.MutableSequence[java.lang.String]: ...
    def name(self) -> java.lang.String: ...
    def node(self, string: typing.Union[java.lang.String, str]) -> Preferences: ...
    def nodeExists(self, string: typing.Union[java.lang.String, str]) -> bool: ...
    def parent(self) -> Preferences: ...
    def put(self, string: typing.Union[java.lang.String, str], string2: typing.Union[java.lang.String, str]) -> None: ...
    def putBoolean(self, string: typing.Union[java.lang.String, str], boolean: bool) -> None: ...
    def putByteArray(self, string: typing.Union[java.lang.String, str], byteArray: typing.Union[typing.List[int], jpype.JArray, bytes]) -> None: ...
    def putDouble(self, string: typing.Union[java.lang.String, str], double: float) -> None: ...
    def putFloat(self, string: typing.Union[java.lang.String, str], float: float) -> None: ...
    def putInt(self, string: typing.Union[java.lang.String, str], int: int) -> None: ...
    def putLong(self, string: typing.Union[java.lang.String, str], long: int) -> None: ...
    def remove(self, string: typing.Union[java.lang.String, str]) -> None: ...
    def removeNode(self) -> None: ...
    def removeNodeChangeListener(self, nodeChangeListener: NodeChangeListener) -> None: ...
    def removePreferenceChangeListener(self, preferenceChangeListener: typing.Union[PreferenceChangeListener, typing.Callable]) -> None: ...
    def sync(self) -> None: ...
    def toString(self) -> java.lang.String: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.util.prefs")``.

    AbstractPreferences: typing.Type[AbstractPreferences]
    BackingStoreException: typing.Type[BackingStoreException]
    InvalidPreferencesFormatException: typing.Type[InvalidPreferencesFormatException]
    NodeChangeEvent: typing.Type[NodeChangeEvent]
    NodeChangeListener: typing.Type[NodeChangeListener]
    PreferenceChangeEvent: typing.Type[PreferenceChangeEvent]
    PreferenceChangeListener: typing.Type[PreferenceChangeListener]
    Preferences: typing.Type[Preferences]
    PreferencesFactory: typing.Type[PreferencesFactory]
