<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Orcheo ChatKit Bubble Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script
      async
      src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js"
      crossorigin="anonymous"
    ></script>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        margin: 0;
        padding: 2rem clamp(1.5rem, 4vw, 3rem);
        background: radial-gradient(circle at top, #172554, #020617 65%);
        color: #e2e8f0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 3vw, 2.4rem);
      }

      p {
        margin: 0;
        line-height: 1.6;
      }

      code {
        background: rgba(30, 41, 59, 0.78);
        padding: 0.1rem 0.4rem;
        border-radius: 0.4rem;
        font-size: 0.9rem;
      }

      a {
        color: #38bdf8;
      }

      .container {
        background: rgba(2, 6, 23, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 1.2rem;
        padding: clamp(1.25rem, 2vw, 2rem);
        display: grid;
        gap: 1.5rem;
        max-width: 960px;
        width: 100%;
      }

      .note {
        padding: 1rem;
        border-radius: 1rem;
        border: 1px solid rgba(244, 114, 182, 0.4);
        background: rgba(76, 29, 149, 0.35);
        color: #fbcfe8;
      }

      .controls {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }

      .field span {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(148, 163, 184, 0.9);
      }

      .field input {
        appearance: none;
        width: 100%;
        padding: 0.65rem 0.75rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.8);
        color: inherit;
        font-size: 0.95rem;
        transition: border-color 150ms ease, box-shadow 150ms ease;
      }

      .field input:focus {
        outline: none;
        border-color: #38bdf8;
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      }

      button {
        font: inherit;
        cursor: pointer;
        padding: 0.75rem 1rem;
        border-radius: 0.85rem;
        border: 1px solid rgba(148, 163, 184, 0.5);
        background: rgba(56, 189, 248, 0.15);
        color: inherit;
        font-weight: 600;
        letter-spacing: 0.03em;
        transition: background 150ms ease, border-color 150ms ease, transform 150ms ease;
      }

      button:hover:not(:disabled) {
        background: rgba(56, 189, 248, 0.25);
        border-color: rgba(148, 163, 184, 0.75);
        transform: translateY(-1px);
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.55;
      }

      .status {
        font-size: 0.95rem;
        padding: 0.75rem 1rem;
        border-radius: 0.9rem;
        background: rgba(30, 41, 59, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.3);
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }

      .status[data-tone="success"] {
        border-color: rgba(34, 197, 94, 0.6);
        background: rgba(22, 101, 52, 0.55);
        color: #bbf7d0;
      }

      .status[data-tone="warn"] {
        border-color: rgba(251, 191, 36, 0.5);
        background: rgba(120, 53, 15, 0.55);
        color: #fef9c3;
      }

      .status[data-tone="error"] {
        border-color: rgba(248, 113, 113, 0.55);
        background: rgba(127, 29, 29, 0.55);
        color: #fecaca;
      }

      .selection {
        font-size: 0.95rem;
        color: rgba(226, 232, 240, 0.9);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .bubble-launcher {
        position: fixed;
        right: clamp(1.5rem, 3vw, 2.5rem);
        bottom: clamp(1.5rem, 3vw, 2.5rem);
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.75rem;
        z-index: 20;
      }

      .bubble-toggle {
        background: linear-gradient(120deg, #38bdf8, #6366f1);
        border: none;
        color: #0f172a;
        min-width: 180px;
        box-shadow: 0 20px 60px rgba(15, 23, 42, 0.45);
      }

      .bubble-toggle[data-state="open"] {
        background: rgba(15, 23, 42, 0.95);
        color: #e2e8f0;
        border: 1px solid rgba(148, 163, 184, 0.4);
      }

      .bubble-panel {
        width: min(420px, calc(100vw - 2rem));
        max-height: min(80vh, 680px);
        border-radius: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(2, 6, 23, 0.97);
        box-shadow: 0 35px 80px rgba(2, 6, 23, 0.7);
        overflow: hidden;
        transform-origin: bottom right;
        transform: translateY(20px) scale(0.95);
        opacity: 0;
        pointer-events: none;
        transition: opacity 180ms ease, transform 180ms ease;
      }

      .bubble-panel[data-open="true"] {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .bubble-panel header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.85rem 1.2rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(15, 23, 42, 0.9);
      }

      .bubble-panel header strong {
        font-size: 0.95rem;
        letter-spacing: 0.03em;
      }

      .bubble-panel header button {
        border: none;
        padding: 0.35rem 0.6rem;
        border-radius: 999px;
        background: rgba(248, 113, 113, 0.2);
        color: #fecaca;
        font-size: 0.85rem;
      }

      .bubble-panel header button:hover {
        background: rgba(248, 113, 113, 0.35);
      }

      openai-chatkit {
        display: block;
        width: 100%;
        height: min(70vh, 600px);
      }

      .launcher-hint {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.85);
        background: rgba(15, 23, 42, 0.8);
        padding: 0.5rem 0.75rem;
        border-radius: 0.65rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
      }

      @media (max-width: 640px) {
        body {
          padding-top: 1.5rem;
        }
        .controls {
          grid-template-columns: 1fr;
        }
        .bubble-launcher {
          bottom: 1rem;
          right: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <h1>ChatKit Bubble ↔️ Published Workflows</h1>
    <div class="container">
      <div class="note">
        <strong>Heads up:</strong> Publish a workflow first (`orcheo workflow publish <id>`), then paste the
        share URL or workflow ID below. The demo sends requests straight to
        <code>/api/chatkit</code> using the public workflow path, so no session tokens or CLI secrets are stored.
      </div>

      <div class="controls">
        <label class="field">
          <span>Backend URL</span>
          <input id="backend-url" type="url" placeholder="http://localhost:8000" />
        </label>
        <label class="field">
          <span>Workflow Share URL or ID</span>
          <input id="workflow-input" type="text" placeholder="https://canvas.local/chat/wf_123" />
        </label>
        <label class="field">
          <span>Workflow Display Name</span>
          <input id="workflow-name" type="text" placeholder="Public Support Bot" />
        </label>
      </div>

      <div class="actions">
        <button type="button" id="connect-workflow">Connect Chat Bubble</button>
        <button type="button" id="clear-selection" aria-label="Clear workflow selection">
          Clear selection
        </button>
      </div>

      <p class="selection">
        Selected workflow:
        <span data-selected-workflow>None</span>
      </p>

      <p class="status" id="status-message" data-tone="info" role="status">
        Paste a published workflow share link to enable the bubble.
      </p>

      <p>
        Need to test locally? Run <code>make dev-server</code>, publish a workflow, then set the backend to
        <code>http://localhost:8000</code>. When the bubble opens you can chat with the published workflow exactly
        like the public Canvas page, including OAuth-gated workflows (cookies are forwarded with every request).
      </p>
    </div>

    <div class="bubble-launcher" aria-live="polite">
      <div class="launcher-hint" data-launcher-hint>
        Configure a workflow to unlock the chat bubble.
      </div>
      <button type="button" class="bubble-toggle" data-chat-toggle disabled>
        Open Chat Bubble
      </button>
      <div class="bubble-panel" data-chat-panel>
        <header>
          <strong data-bubble-title>ChatKit</strong>
          <button type="button" data-chat-close aria-label="Close chat bubble">Close</button>
        </header>
        <openai-chatkit></openai-chatkit>
      </div>
    </div>

    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const chatkit = document.querySelector("openai-chatkit");
        const backendInput = document.getElementById("backend-url");
        const workflowInput = document.getElementById("workflow-input");
        const workflowNameInput = document.getElementById("workflow-name");
        const connectButton = document.getElementById("connect-workflow");
        const clearButton = document.getElementById("clear-selection");
        const statusElement = document.getElementById("status-message");
        const selectionElement = document.querySelector("[data-selected-workflow]");
        const bubbleToggle = document.querySelector("[data-chat-toggle]");
        const bubblePanel = document.querySelector("[data-chat-panel]");
        const bubbleTitle = document.querySelector("[data-bubble-title]");
        const closeButton = document.querySelector("[data-chat-close]");
        const launcherHint = document.querySelector("[data-launcher-hint]");

        const defaultBackend = window.ORCHEO_BACKEND_URL || "http://localhost:8000";
        const isFileProtocol = window.location.protocol === "file:";
        const presetWorkflowId = window.ORCHEO_WORKFLOW_ID || null;
        const presetWorkflowName = window.ORCHEO_WORKFLOW_NAME || null;
        const domainKey = window.ORCHEO_CHATKIT_DOMAIN_KEY || "domain_pk_localhost_dev";
        const STORAGE_KEY = "orcheo.chatkit.published";

        const sanitizeBaseUrl = (value) => (value || "").trim().replace(/\/+$/, "");

        const parseWorkflowId = (rawValue) => {
          if (!rawValue) {
            return null;
          }
          const trimmed = rawValue.trim();
          if (!trimmed) {
            return null;
          }
          try {
            const parsed = new URL(trimmed);
            const segments = parsed.pathname.split("/").filter(Boolean);
            if (segments.length) {
              return segments[segments.length - 1];
            }
          } catch (error) {
            // Not a URL, fall through and treat as plain ID.
          }
          return trimmed;
        };

        const loadStoredState = () => {
          try {
            const raw = window.sessionStorage.getItem(STORAGE_KEY);
            if (!raw) {
              return null;
            }
            return JSON.parse(raw);
          } catch (error) {
            console.warn("Unable to parse saved workflow state", error);
            return null;
          }
        };

        const persistState = () => {
          try {
            window.sessionStorage.setItem(
              STORAGE_KEY,
              JSON.stringify({
                backendBase: state.backendBase,
                workflow: state.workflow,
                workflowInput: workflowInput.value,
                workflowName: workflowNameInput.value,
              }),
            );
          } catch (error) {
            console.warn("Unable to persist workflow state", error);
          }
        };

        const stored = loadStoredState();
        const state = {
          backendBase: sanitizeBaseUrl(stored?.backendBase || defaultBackend),
          workflow: presetWorkflowId
            ? { id: presetWorkflowId, name: presetWorkflowName || presetWorkflowId }
            : stored?.workflow || null,
        };

        backendInput.value = state.backendBase;
        if (stored?.workflowInput) {
          workflowInput.value = stored.workflowInput;
        }
        if (stored?.workflowName) {
          workflowNameInput.value = stored.workflowName;
        }

        const setStatus = (message, tone = "info") => {
          statusElement.textContent = message;
          statusElement.dataset.tone = tone;
        };

        const setLauncherHint = (message) => {
          if (launcherHint) {
            launcherHint.textContent = message;
          }
        };

        const syncBubbleAvailability = () => {
          const enabled = Boolean(state.workflow) && !isFileProtocol;
          bubbleToggle.disabled = !enabled;
          bubbleToggle.dataset.ready = enabled ? "true" : "false";
          if (!enabled) {
            bubbleToggle.dataset.state = "closed";
            closeBubble();
          }
          setLauncherHint(
            enabled
              ? `Chat bubble ready for ${state.workflow.name}`
              : "Configure a workflow to unlock the chat bubble.",
          );
          persistState();
        };

        const syncComposerDisabled = () => {
          if (!chatkit || typeof chatkit !== "object") {
            return;
          }
          const root = chatkit.shadowRoot;
          if (!root) {
            return;
          }
          const sendButton =
            root.querySelector('[data-testid="composer-send-button"]') ||
            root.querySelector('button[type="submit"]');
          if (!sendButton) {
            return;
          }
          const disabled = !state.workflow;
          sendButton.disabled = disabled;
          if (disabled) {
            sendButton.title = "Select a workflow to enable messaging.";
          } else {
            sendButton.removeAttribute("title");
          }
        };

        const updateSelectionLabel = () => {
          if (state.workflow) {
            selectionElement.textContent = `${state.workflow.name} (${state.workflow.id})`;
            bubbleTitle.textContent = state.workflow.name;
          } else {
            selectionElement.textContent = "None";
            bubbleTitle.textContent = "ChatKit";
          }
          syncBubbleAvailability();
          syncComposerDisabled();
        };

        const parseErrorResponse = async (response) => {
          try {
            const payload = await response.clone().json();
            if (!payload) {
              return { message: response.statusText };
            }
            if (typeof payload === "string") {
              return { message: payload };
            }
            const detail =
              (payload.detail && typeof payload.detail === "object"
                ? payload.detail
                : payload) || {};
            return {
              message:
                detail.message || payload.message || response.statusText || "ChatKit request failed.",
              code: detail.code || payload.code,
            };
          } catch (error) {
            return {
              message: response.statusText || "ChatKit request failed.",
            };
          }
        };

        const handleHttpError = async (response) => {
          const detail = await parseErrorResponse(response);
          const pieces = [
            detail.message || "ChatKit request failed.",
            detail.code ? `(${detail.code})` : null,
          ].filter(Boolean);
          setStatus(pieces.join(" "), "error");
        };

        const buildPublicChatFetch = ({ workflowId, backendBase, metadata }) => {
          const baseFetch = window.fetch.bind(window);
          const resolvedUrl = `${backendBase}/api/chatkit`;
          return async (input, init = {}) => {
            const requestInfo = input || resolvedUrl;
            const nextInit = {
              ...init,
              credentials: "include",
            };
            const headers = new Headers(nextInit.headers || {});
            const contentType = headers.get("Content-Type") || "";
            const expectsJson = contentType.includes("application/json");
            const bodyIsString = typeof nextInit.body === "string";

            const ensureBody = (serialized) => {
              if (!serialized) {
                return JSON.stringify({
                  workflow_id: workflowId,
                  metadata: {
                    ...(metadata || {}),
                    workflow_id: workflowId,
                  },
                });
              }
              try {
                const payload = JSON.parse(serialized);
                if (payload && typeof payload === "object") {
                  if (!payload.workflow_id) {
                    payload.workflow_id = workflowId;
                  }
                  const payloadMetadata =
                    payload.metadata && typeof payload.metadata === "object"
                      ? { ...payload.metadata }
                      : {};
                  if (metadata) {
                    Object.assign(payloadMetadata, metadata);
                  }
                  payloadMetadata.workflow_id = workflowId;
                  payload.metadata = payloadMetadata;
                }
                return JSON.stringify(payload);
              } catch (error) {
                console.warn("Unable to augment ChatKit payload metadata", error);
                return serialized;
              }
            };

            if (expectsJson || bodyIsString || !nextInit.body) {
              const serialized = bodyIsString ? nextInit.body : null;
              nextInit.body = ensureBody(serialized);
              headers.set("Content-Type", "application/json");
            }

            nextInit.headers = headers;
            const response = await baseFetch(requestInfo, nextInit);
            if (!response.ok) {
              await handleHttpError(response.clone());
            }
            return response;
          };
        };

        const applyChatKitOptions = (autoOpen = false) => {
          if (isFileProtocol) {
            setStatus(
              "Serve this page via http(s) (e.g., `python -m http.server`) before connecting to ChatKit.",
              "error",
            );
            return;
          }

          if (!state.workflow) {
            syncComposerDisabled();
            return;
          }

          const workflowId = state.workflow.id;
          const workflowName = state.workflow.name;
          const backendBase = state.backendBase;

          const options = {
            api: {
              url: `${backendBase}/api/chatkit`,
              domainKey,
              fetch: buildPublicChatFetch({
                workflowId,
                backendBase,
                metadata: {
                  workflow_name: workflowName,
                  source: "html-bubble-demo",
                },
              }),
            },
            header: {
              enabled: true,
              title: { text: workflowName },
            },
            history: { enabled: true },
            startScreen: {
              greeting: `Welcome to the ${workflowName} public chat`,
              prompts: [
                { label: "Capabilities", prompt: `What can ${workflowName} help with?`, icon: "sparkle" },
                { label: "Latest run", prompt: `Summarize the latest run for ${workflowName}.`, icon: "search" },
                { label: "Share context", prompt: "Here is some context you should know…", icon: "book-open" },
              ],
            },
            composer: {
              placeholder: `Chat with ${workflowName}…`,
            },
          };

          const assign = () => {
            if (typeof chatkit?.setOptions === "function") {
              chatkit.setOptions(options);
              setStatus(`ChatKit configured for workflow “${workflowName}”.`, "success");
              if (autoOpen) {
                openBubble();
              }
            }
          };

          if (customElements.get("openai-chatkit")) {
            assign();
          } else {
            customElements.whenDefined("openai-chatkit").then(assign);
          }
        };

        const openBubble = () => {
          bubblePanel.dataset.open = "true";
          bubbleToggle.dataset.state = "open";
        };

        const closeBubble = () => {
          bubblePanel.dataset.open = "false";
          bubbleToggle.dataset.state = "closed";
        };

        bubbleToggle.addEventListener("click", () => {
          if (!state.workflow) {
            setStatus("Select a workflow before opening the bubble.", "warn");
            return;
          }
          const isOpen = bubblePanel.dataset.open === "true";
          if (isOpen) {
            closeBubble();
          } else {
            openBubble();
          }
        });

        closeButton.addEventListener("click", () => {
          closeBubble();
        });

        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            closeBubble();
          }
        });

        connectButton.addEventListener("click", () => {
          if (isFileProtocol) {
            setStatus(
              "Serve this page via http(s) so ChatKit can communicate with your backend.",
              "error",
            );
            return;
          }

          const backendBase = sanitizeBaseUrl(backendInput.value) || defaultBackend;
          const workflowId = parseWorkflowId(workflowInput.value) || presetWorkflowId;
          const workflowName = (workflowNameInput.value || "").trim();

          if (!workflowId) {
            setStatus("Enter a workflow ID or share URL first.", "warn");
            state.workflow = null;
            updateSelectionLabel();
            return;
          }

          state.backendBase = backendBase;
          state.workflow = {
            id: workflowId,
            name: workflowName || workflowId,
          };

          backendInput.value = backendBase;
          workflowInput.value = workflowInput.value || workflowId;
          if (!workflowName && presetWorkflowName) {
            workflowNameInput.value = presetWorkflowName;
          }

          persistState();
          updateSelectionLabel();
          applyChatKitOptions(true);
          setStatus(`Ready to chat with ${state.workflow.name}.`, "success");
        });

        clearButton.addEventListener("click", () => {
          state.workflow = null;
          workflowInput.value = "";
          workflowNameInput.value = "";
          persistState();
          closeBubble();
          updateSelectionLabel();
          setStatus("Workflow selection cleared.", "info");
        });

        const composerWatcher = window.setInterval(syncComposerDisabled, 800);
        window.addEventListener("beforeunload", () => {
          window.clearInterval(composerWatcher);
        });

        updateSelectionLabel();
        if (isFileProtocol) {
          setStatus(
            "Open this page with a local web server (not file://) to finish the ChatKit setup.",
            "warn",
          );
          connectButton.disabled = true;
        } else if (state.workflow) {
          applyChatKitOptions();
          setStatus(`Restored workflow “${state.workflow.name}” from storage.`, "info");
        }
      });
    </script>
  </body>
</html>
