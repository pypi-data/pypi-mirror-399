// defer to types in global.d.ts
// this local... naming is to workaround a TypeScript limitation that
// doesn't allow referring explicitly to global names (thus cannot override here)
// IMPROVE: invert relationship for global.d.ts looks here instead
import * as IO from 'io-ts';

type localJsonScalar = JsonScalar
type localJsonValue = JsonValue
type localObjectId = ObjectId

export type {
  localJsonScalar as JsonScalar,
  localJsonValue as JsonValue,
  localObjectId as ObjectId,
}

export const IOObjectId = IO.Integer;
export const IOJsonScalar = IO.union([IO.string, IO.number, IO.boolean, IO.null]);
export const IOJsonValue: IO.Type<JsonValue> = IO.recursion('JsonValue', () =>
  IO.union([
    IOJsonScalar,
    IO.record(IO.string, IOJsonValue),
    IO.array(IOJsonValue),
  ]),
);

// Testing this approach to get strongly typed strings. If it proves
// useful we should elevant to type_spec. The same is possible in Python
export interface nominal<T> {
  "nominal structural brand": T
}

// Ids matching a strict integer number are converted to integers
export const ID_REGEX = /^-?[1-9][0-9]{0,20}$/
// Matches ISO 8601 dates. Stricter than `Date.parse`.
// https://www.w3.org/TR/NOTE-datetime
export const ISO8601_DATE_REGEX = /^(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2})(\.\d+)?([+-]\d{2}:?\d{2}|Z)$/
