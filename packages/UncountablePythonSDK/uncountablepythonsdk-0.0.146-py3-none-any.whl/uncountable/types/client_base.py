# DO NOT MODIFY -- This file is generated by type_spec
# ruff: noqa: E402 Q003
# fmt: off
# isort: skip_file
# ruff: noqa: PLR0904
from __future__ import annotations
import typing  # noqa: F401
import datetime  # noqa: F401
from decimal import Decimal  # noqa: F401
from pkgs.serialization import OpaqueKey
import uncountable.types.api.notebooks.add_notebook_content as add_notebook_content_t
import uncountable.types.api.recipes.add_recipe_to_project as add_recipe_to_project_t
import uncountable.types.api.recipes.add_time_series_data as add_time_series_data_t
import uncountable.types.api.recipes.archive_recipes as archive_recipes_t
import uncountable.types.api.equipment.associate_equipment_input as associate_equipment_input_t
import uncountable.types.api.recipes.associate_recipe_as_input as associate_recipe_as_input_t
import uncountable.types.api.recipes.associate_recipe_as_lot as associate_recipe_as_lot_t
from uncountable.types import async_batch_t
from uncountable.types import base_t
import uncountable.types.api.recipes.clear_recipe_outputs as clear_recipe_outputs_t
from uncountable.types import client_config_t
import uncountable.types.api.uploader.complete_async_parse as complete_async_parse_t
import uncountable.types.api.runsheet.complete_async_upload as complete_async_upload_t
import uncountable.types.api.chemical.convert_chemical_formats as convert_chemical_formats_t
import uncountable.types.api.entity.create_entities as create_entities_t
import uncountable.types.api.entity.create_entity as create_entity_t
import uncountable.types.api.files.create_file_record as create_file_record_t
import uncountable.types.api.inputs.create_inputs as create_inputs_t
import uncountable.types.api.recipes.create_mix_order as create_mix_order_t
import uncountable.types.api.entity.create_or_update_entity as create_or_update_entity_t
import uncountable.types.api.recipes.create_recipe as create_recipe_t
import uncountable.types.api.recipe_links.create_recipe_link as create_recipe_link_t
import uncountable.types.api.recipes.create_recipes as create_recipes_t
import uncountable.types.api.recipes.disassociate_recipe_as_input as disassociate_recipe_as_input_t
import uncountable.types.api.recipes.edit_recipe_inputs as edit_recipe_inputs_t
from uncountable.types import entity_t
import uncountable.types.api.batch.execute_batch as execute_batch_t
import uncountable.types.api.batch.execute_batch_load_async as execute_batch_load_async_t
import uncountable.types.api.runsheet.export_default_runsheet as export_default_runsheet_t
import uncountable.types.api.entity.export_entities as export_entities_t
from uncountable.types import exports_t
import uncountable.types.api.listing.fetch_listing as fetch_listing_t
from uncountable.types import field_values_t
from uncountable.types import generic_upload_t
import uncountable.types.api.recipes.get_column_calculation_values as get_column_calculation_values_t
import uncountable.types.api.user.get_current_user_info as get_current_user_info_t
import uncountable.types.api.recipes.get_curve as get_curve_t
import uncountable.types.api.entity.get_entities_data as get_entities_data_t
import uncountable.types.api.inputs.get_input_data as get_input_data_t
import uncountable.types.api.input_groups.get_input_group_names as get_input_group_names_t
import uncountable.types.api.inputs.get_input_names as get_input_names_t
import uncountable.types.api.inputs.get_inputs_data as get_inputs_data_t
import uncountable.types.api.outputs.get_output_data as get_output_data_t
import uncountable.types.api.outputs.get_output_names as get_output_names_t
import uncountable.types.api.outputs.get_output_organization as get_output_organization_t
import uncountable.types.api.project.get_projects as get_projects_t
import uncountable.types.api.project.get_projects_data as get_projects_data_t
import uncountable.types.api.recipes.get_recipe_calculations as get_recipe_calculations_t
import uncountable.types.api.recipes.get_recipe_links as get_recipe_links_t
import uncountable.types.api.recipe_metadata.get_recipe_metadata_data as get_recipe_metadata_data_t
import uncountable.types.api.recipes.get_recipe_names as get_recipe_names_t
import uncountable.types.api.recipes.get_recipe_output_metadata as get_recipe_output_metadata_t
import uncountable.types.api.recipes.get_recipes_data as get_recipes_data_t
import uncountable.types.api.entity.grant_entity_permissions as grant_entity_permissions_t
from uncountable.types import id_source_t
from uncountable.types import identifier_t
import uncountable.types.api.uploader.invoke_uploader as invoke_uploader_t
import uncountable.types.api.entity.list_aggregate as list_aggregate_t
import uncountable.types.api.entity.list_entities as list_entities_t
import uncountable.types.api.id_source.list_id_source as list_id_source_t
from uncountable.types import listing_t
import uncountable.types.api.entity.lock_entity as lock_entity_t
import uncountable.types.api.recipes.lock_recipes as lock_recipes_t
import uncountable.types.api.entity.lookup_entity as lookup_entity_t
import uncountable.types.api.id_source.match_id_source as match_id_source_t
from uncountable.types import notices_t
from uncountable.types import notifications_t
from uncountable.types import permissions_t
from uncountable.types import post_base_t
import uncountable.types.api.integrations.push_notification as push_notification_t
from uncountable.types import recipe_identifiers_t
from uncountable.types import recipe_links_t
from uncountable.types import recipe_metadata_t
from uncountable.types import recipe_workflow_steps_t
import uncountable.types.api.integrations.register_sockets_token as register_sockets_token_t
import uncountable.types.api.recipes.remove_recipe_from_project as remove_recipe_from_project_t
import uncountable.types.api.recipe_links.remove_recipe_link as remove_recipe_link_t
import uncountable.types.api.entity.resolve_entity_ids as resolve_entity_ids_t
import uncountable.types.api.outputs.resolve_output_conditions as resolve_output_conditions_t
import uncountable.types.api.triggers.run_trigger as run_trigger_t
import uncountable.types.api.entity.set_barcode as set_barcode_t
import uncountable.types.api.permissions.set_core_permissions as set_core_permissions_t
import uncountable.types.api.entity.set_entity_field_values as set_entity_field_values_t
import uncountable.types.api.inputs.set_input_attribute_values as set_input_attribute_values_t
import uncountable.types.api.inputs.set_input_category as set_input_category_t
import uncountable.types.api.inputs.set_input_subcategories as set_input_subcategories_t
import uncountable.types.api.inputs.set_intermediate_type as set_intermediate_type_t
import uncountable.types.api.recipes.set_recipe_inputs as set_recipe_inputs_t
import uncountable.types.api.recipes.set_recipe_metadata as set_recipe_metadata_t
import uncountable.types.api.recipes.set_recipe_output_annotations as set_recipe_output_annotations_t
import uncountable.types.api.recipes.set_recipe_output_file as set_recipe_output_file_t
import uncountable.types.api.recipes.set_recipe_outputs as set_recipe_outputs_t
import uncountable.types.api.recipes.set_recipe_tags as set_recipe_tags_t
import uncountable.types.api.recipes.set_recipe_total as set_recipe_total_t
import uncountable.types.api.entity.set_values as set_values_t
from uncountable.types import sockets_t
import uncountable.types.api.entity.transition_entity_phase as transition_entity_phase_t
import uncountable.types.api.recipes.unarchive_recipes as unarchive_recipes_t
import uncountable.types.api.entity.unlock_entity as unlock_entity_t
import uncountable.types.api.recipes.unlock_recipes as unlock_recipes_t
import uncountable.types.api.material_families.update_entity_material_families as update_entity_material_families_t
from uncountable.types import uploader_t
import uncountable.types.api.condition_parameters.upsert_condition_match as upsert_condition_match_t
import uncountable.types.api.field_options.upsert_field_options as upsert_field_options_t
from abc import ABC, abstractmethod
import dataclasses

DT = typing.TypeVar("DT")


@dataclasses.dataclass(kw_only=True)
class APIRequest:
    method: str
    endpoint: str
    args: typing.Any
    request_options: client_config_t.RequestOptions | None = None


class ClientMethods(ABC):

    @abstractmethod
    def do_request(self, *, api_request: APIRequest, return_type: type[DT]) -> DT:
        ...

    def add_notebook_content(
        self,
        *,
        notebook_key: identifier_t.IdentifierKey,
        location: add_notebook_content_t.Location,
        contents: list[add_notebook_content_t.InputContent],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> add_notebook_content_t.Data:
        """Adds content to an existing notebook

        :param notebook_key: Key of the notebook to add the content to
        :param location: The location to add the content to in the notebook
        :param contents: List of input content to add to the notebook
        """
        args = add_notebook_content_t.Arguments(
            notebook_key=notebook_key,
            location=location,
            contents=contents,
        )
        api_request = APIRequest(
            method=add_notebook_content_t.ENDPOINT_METHOD,
            endpoint=add_notebook_content_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=add_notebook_content_t.Data)

    def add_recipe_to_project(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        project_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> add_recipe_to_project_t.Data:
        """Adds a recipe to a project

        :param recipe_key: The identifier key of the recipe to add to the project
        :param project_key: The identifier key of the project to add the recipe to
        """
        args = add_recipe_to_project_t.Arguments(
            recipe_key=recipe_key,
            project_key=project_key,
        )
        api_request = APIRequest(
            method=add_recipe_to_project_t.ENDPOINT_METHOD,
            endpoint=add_recipe_to_project_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=add_recipe_to_project_t.Data)

    def external_add_time_series_data(
        self,
        *,
        time_series_segment_key: identifier_t.IdentifierKey,
        time_series_data: list[add_time_series_data_t.TimeSeriesDatum],
        on_conflict: add_time_series_data_t.OnTimepointConflict = add_time_series_data_t.OnTimepointConflict.ERROR,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> add_time_series_data_t.Data:
        """Add timepoint data to a time series segment.

        :param time_series_segment_key: The time series segment to add data to
        :param time_series_data: The data to add to the time series segment
        :param on_conflict: What to do if a TimeSeriesDatum already exists at the same timestamp
        """
        args = add_time_series_data_t.Arguments(
            time_series_segment_key=time_series_segment_key,
            time_series_data=time_series_data,
            on_conflict=on_conflict,
        )
        api_request = APIRequest(
            method=add_time_series_data_t.ENDPOINT_METHOD,
            endpoint=add_time_series_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=add_time_series_data_t.Data)

    def archive_recipes(
        self,
        *,
        recipes: list[identifier_t.IdentifierKey],
        reason: str | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> archive_recipes_t.Data:
        """Archive the provided recipes and their children

        :param recipes: Identifier for the recipe
        :param reason: This reason will be written to the audit log archive entry
        """
        args = archive_recipes_t.Arguments(
            recipes=recipes,
            reason=reason,
        )
        api_request = APIRequest(
            method=archive_recipes_t.ENDPOINT_METHOD,
            endpoint=archive_recipes_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=archive_recipes_t.Data)

    def associate_equipment_input(
        self,
        *,
        equipment_key: identifier_t.IdentifierKey,
        material_family_ids: list[base_t.ObjectId],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> associate_equipment_input_t.Data:
        """Create or return the input association for equipment

        :param equipment_key: Identifier of the equipment to associate
        :param material_family_ids: The list of material families to add the input to. This must be non-empty
        """
        args = associate_equipment_input_t.Arguments(
            equipment_key=equipment_key,
            material_family_ids=material_family_ids,
        )
        api_request = APIRequest(
            method=associate_equipment_input_t.ENDPOINT_METHOD,
            endpoint=associate_equipment_input_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=associate_equipment_input_t.Data)

    def associate_recipe_as_input(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        input_key: identifier_t.IdentifierKey | None = None,
        show_in_listings: bool | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> associate_recipe_as_input_t.Data:
        """Create or return the input association for a recipe

        :param recipe_key: Identifier for the recipe
        :param input_key: Identifier for an input to use for the association.  Optionally supplied.  If not supplied, one is created
        :param show_in_listings: After associating the input should it be present in listings
        """
        args = associate_recipe_as_input_t.Arguments(
            recipe_key=recipe_key,
            input_key=input_key,
            show_in_listings=show_in_listings,
        )
        api_request = APIRequest(
            method=associate_recipe_as_input_t.ENDPOINT_METHOD,
            endpoint=associate_recipe_as_input_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=associate_recipe_as_input_t.Data)

    def associate_recipe_as_lot(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        ingredient_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> associate_recipe_as_lot_t.Data:
        """Create a new lot association for the provided recipe with the provided ingredient

        :param recipe_key: Identifier for the recipe
        :param ingredient_key: Identifier for the ingredient
        """
        args = associate_recipe_as_lot_t.Arguments(
            recipe_key=recipe_key,
            ingredient_key=ingredient_key,
        )
        api_request = APIRequest(
            method=associate_recipe_as_lot_t.ENDPOINT_METHOD,
            endpoint=associate_recipe_as_lot_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=associate_recipe_as_lot_t.Data)

    def clear_recipe_outputs(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> clear_recipe_outputs_t.Data:
        """Clears all output values & output metadata for a given recipe

        :param recipe_key: The identifier of the recipe
        """
        args = clear_recipe_outputs_t.Arguments(
            recipe_key=recipe_key,
        )
        api_request = APIRequest(
            method=clear_recipe_outputs_t.ENDPOINT_METHOD,
            endpoint=clear_recipe_outputs_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=clear_recipe_outputs_t.Data)

    def complete_async_parse(
        self,
        *,
        parsed_file_data: list[uploader_t.ParsedFileData],
        async_job_key: identifier_t.IdentifierKey,
        upload_destination: generic_upload_t.UploadDestinationRecipe,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> complete_async_parse_t.Data:
        """Parses uploaded files asynchronously

        """
        args = complete_async_parse_t.Arguments(
            parsed_file_data=parsed_file_data,
            async_job_key=async_job_key,
            upload_destination=upload_destination,
        )
        api_request = APIRequest(
            method=complete_async_parse_t.ENDPOINT_METHOD,
            endpoint=complete_async_parse_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=complete_async_parse_t.Data)

    def complete_async_upload(
        self,
        *,
        async_job_id: base_t.ObjectId,
        file_id: base_t.ObjectId,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> complete_async_upload_t.Data:
        """Processes an file id with a given async job id to be uploaded asynchronously

        """
        args = complete_async_upload_t.Arguments(
            async_job_id=async_job_id,
            file_id=file_id,
        )
        api_request = APIRequest(
            method=complete_async_upload_t.ENDPOINT_METHOD,
            endpoint=complete_async_upload_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=complete_async_upload_t.Data)

    def convert_chemical_formats(
        self,
        *,
        source_chemical_structures: list[convert_chemical_formats_t.ChemicalStructureFile],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> convert_chemical_formats_t.Data:
        """Converts chemical formats, into the format used by Uncountable and usable in other APIs for eg. set_input_attribute_values

        """
        args = convert_chemical_formats_t.Arguments(
            source_chemical_structures=source_chemical_structures,
        )
        api_request = APIRequest(
            method=convert_chemical_formats_t.ENDPOINT_METHOD,
            endpoint=convert_chemical_formats_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=convert_chemical_formats_t.Data)

    def create_entities(
        self,
        *,
        entity_type: entity_t.LimitedEntityType,
        entities_to_create: list[create_entities_t.EntityToCreate],
        definition_id: base_t.ObjectId | None = None,
        definition_key: identifier_t.IdentifierKey | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_entities_t.Data:
        """Creates new Uncountable entities

        :param definition_id: Definition id for the entities to create
        :param definition_key: Key for the definition of the entities to create
        :param entity_type: The type of the entities to create
        :param entities_to_create: A list of the entities to create
        """
        args = create_entities_t.Arguments(
            definition_id=definition_id,
            definition_key=definition_key,
            entity_type=entity_type,
            entities_to_create=entities_to_create,
        )
        api_request = APIRequest(
            method=create_entities_t.ENDPOINT_METHOD,
            endpoint=create_entities_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_entities_t.Data)

    def create_entity(
        self,
        *,
        entity_type: entity_t.LimitedEntityType,
        definition_id: base_t.ObjectId | None = None,
        definition_key: identifier_t.IdentifierKey | None = None,
        field_values: list[field_values_t.FieldRefNameValue] | None = None,
        parent_entity: entity_t.Entity | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_entity_t.Data:
        """Creates a new Uncountable entity

        :param definition_id: Definition id of the entity to create
        :param definition_key: Key for the definition of the entity to create
        :param entity_type: The type of the entities requested
        :param parent_entity: The parent entity associated for this new entity. This only applies if there is a pre-defined relationship.
        """
        args = create_entity_t.Arguments(
            definition_id=definition_id,
            definition_key=definition_key,
            entity_type=entity_type,
            field_values=field_values,
            parent_entity=parent_entity,
        )
        api_request = APIRequest(
            method=create_entity_t.ENDPOINT_METHOD,
            endpoint=create_entity_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_entity_t.Data)

    def create_file_record(
        self,
        *,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_file_record_t.Data:
        """Upload Files to Uncountable and retrieve the File Id. File bytes must be included in a multi-part form field that shares its name with the uploaded file.

        """
        args = create_file_record_t.Arguments()
        api_request = APIRequest(
            method=create_file_record_t.ENDPOINT_METHOD,
            endpoint=create_file_record_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_file_record_t.Data)

    def external_create_inputs(
        self,
        *,
        inputs_to_create: list[create_inputs_t.InputToCreate],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_inputs_t.Data:
        """Creates new inputs

        :param inputs_to_create: A list of inputs to create
        """
        args = create_inputs_t.Arguments(
            inputs_to_create=inputs_to_create,
        )
        api_request = APIRequest(
            method=create_inputs_t.ENDPOINT_METHOD,
            endpoint=create_inputs_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_inputs_t.Data)

    def create_mix_order(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        recipe_workflow_step_identifier: recipe_workflow_steps_t.RecipeWorkflowStepIdentifier,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_mix_order_t.Data:
        """Creates mix order on a recipe workflow step

        """
        args = create_mix_order_t.Arguments(
            recipe_key=recipe_key,
            recipe_workflow_step_identifier=recipe_workflow_step_identifier,
        )
        api_request = APIRequest(
            method=create_mix_order_t.ENDPOINT_METHOD,
            endpoint=create_mix_order_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_mix_order_t.Data)

    def create_or_update_entity(
        self,
        *,
        entity_type: entity_t.EntityType,
        definition_key: identifier_t.IdentifierKey,
        field_values: list[field_values_t.FieldArgumentValue],
        entity_key: identifier_t.IdentifierKey | None = None,
        on_create_init_field_values: list[field_values_t.FieldArgumentValue] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_or_update_entity_t.Data:
        """Creates or updates field values for an entity

        :param on_create_init_field_values: Field values set only when the entity is created (will be ignored if entity already exists)
        """
        args = create_or_update_entity_t.Arguments(
            entity_key=entity_key,
            entity_type=entity_type,
            definition_key=definition_key,
            field_values=field_values,
            on_create_init_field_values=on_create_init_field_values,
        )
        api_request = APIRequest(
            method=create_or_update_entity_t.ENDPOINT_METHOD,
            endpoint=create_or_update_entity_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_or_update_entity_t.Data)

    def create_recipe(
        self,
        *,
        material_family_id: base_t.ObjectId,
        workflow_id: base_t.ObjectId,
        name: str | None = None,
        project_id: base_t.ObjectId | None = None,
        workflow_variant_id: base_t.ObjectId | None = None,
        recipe_metadata: list[recipe_metadata_t.MetadataValue] | None = None,
        identifiers: recipe_identifiers_t.RecipeIdentifiers | None = None,
        definition_key: identifier_t.IdentifierKey | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_recipe_t.Data:
        """Returns the id of the recipe being created.

        :param name: The name for the recipe
        :param material_family_id: The material family for the recipe
        :param project_id: The identifier of the project to create the recipe in
        :param workflow_id: The identifier of the workflow to create the recipe with
        :param workflow_variant_id: The identifier of the workflow variant to create the recipe with
        :param recipe_metadata: Metadata values to populate the recipe with
        :param identifiers: A recipe won't be created if it matches the identifier.  An identifier must be unique in the schema
        :param definition_key: The entity definition identifier, default is used if not supplied
        """
        args = create_recipe_t.Arguments(
            name=name,
            material_family_id=material_family_id,
            project_id=project_id,
            workflow_id=workflow_id,
            workflow_variant_id=workflow_variant_id,
            recipe_metadata=recipe_metadata,
            identifiers=identifiers,
            definition_key=definition_key,
        )
        api_request = APIRequest(
            method=create_recipe_t.ENDPOINT_METHOD,
            endpoint=create_recipe_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_recipe_t.Data)

    def create_recipe_link(
        self,
        *,
        recipe_from_key: identifier_t.IdentifierKey,
        recipe_to_key: identifier_t.IdentifierKey,
        link_type: typing.Literal[recipe_links_t.RecipeLinkType.CHILD] | typing.Literal[recipe_links_t.RecipeLinkType.CONTROL] | typing.Literal[recipe_links_t.RecipeLinkType.USER_LINK] | typing.Literal[recipe_links_t.RecipeLinkType.PREVIOUS_EXPERIMENT],
        name: str | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_recipe_link_t.Data:
        """Create a link between two recipes.  Skip if the link already exists

        :param recipe_from_key: Identifier for the recipe the link comes from
        :param recipe_to_key: Identifier for the recipe the link goes to
        :param link_type: The type of link being created
        :param name: The name used for the link
        """
        args = create_recipe_link_t.Arguments(
            recipe_from_key=recipe_from_key,
            recipe_to_key=recipe_to_key,
            link_type=link_type,
            name=name,
        )
        api_request = APIRequest(
            method=create_recipe_link_t.ENDPOINT_METHOD,
            endpoint=create_recipe_link_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_recipe_link_t.Data)

    def create_recipes(
        self,
        *,
        material_family_id: base_t.ObjectId,
        recipe_definitions: list[create_recipes_t.CreateRecipeDefinition],
        project_id: base_t.ObjectId | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> create_recipes_t.Data:
        """Creates recipes in Uncountable, optionally with metadata values, and returns the resulting ids in corresponding order

        :param material_family_id: The identifier of the material family to create the recipes in
        :param project_id: The identifier of the project to create the recipes in
        """
        args = create_recipes_t.Arguments(
            material_family_id=material_family_id,
            project_id=project_id,
            recipe_definitions=recipe_definitions,
        )
        api_request = APIRequest(
            method=create_recipes_t.ENDPOINT_METHOD,
            endpoint=create_recipes_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=create_recipes_t.Data)

    def disassociate_recipe_as_input(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> disassociate_recipe_as_input_t.Data:
        """Remove any association between a recipe and ingredients

        :param recipe_key: Identifier for the recipe
        """
        args = disassociate_recipe_as_input_t.Arguments(
            recipe_key=recipe_key,
        )
        api_request = APIRequest(
            method=disassociate_recipe_as_input_t.ENDPOINT_METHOD,
            endpoint=disassociate_recipe_as_input_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=disassociate_recipe_as_input_t.Data)

    def edit_recipe_inputs(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        recipe_workflow_step_identifier: recipe_workflow_steps_t.RecipeWorkflowStepIdentifier,
        edits: list[edit_recipe_inputs_t.RecipeInputEdit],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> edit_recipe_inputs_t.Data:
        """Clear, update, or add inputs on a recipe

        :param recipe_key: Identifier for the recipe
        """
        args = edit_recipe_inputs_t.Arguments(
            recipe_key=recipe_key,
            recipe_workflow_step_identifier=recipe_workflow_step_identifier,
            edits=edits,
        )
        api_request = APIRequest(
            method=edit_recipe_inputs_t.ENDPOINT_METHOD,
            endpoint=edit_recipe_inputs_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=edit_recipe_inputs_t.Data)

    def execute_batch(
        self,
        *,
        requests: list[execute_batch_t.BatchRequest],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> execute_batch_t.Data:
        """Run multiple API calls via one request

        """
        args = execute_batch_t.Arguments(
            requests=requests,
        )
        api_request = APIRequest(
            method=execute_batch_t.ENDPOINT_METHOD,
            endpoint=execute_batch_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=execute_batch_t.Data)

    def execute_batch_load_async(
        self,
        *,
        requests: list[async_batch_t.AsyncBatchRequest],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> execute_batch_load_async_t.Data:
        """Run multiple API calls via one request

        """
        args = execute_batch_load_async_t.Arguments(
            requests=requests,
        )
        api_request = APIRequest(
            method=execute_batch_load_async_t.ENDPOINT_METHOD,
            endpoint=execute_batch_load_async_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=execute_batch_load_async_t.Data)

    def export_default_runsheet(
        self,
        *,
        entities: list[identifier_t.IdentifierKey],
        entity_type: entity_t.EntityType = entity_t.EntityType.RECIPE,
        runsheet_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> export_default_runsheet_t.Data:
        """Export default runsheet for specified entities

        :param entities: List of identifiers for entities to include in the runsheet export
        :param entity_type: Type of entities to include in the runsheet export. Defaults to Recipe if not provided.
        :param runsheet_key: Identifier key for the runsheet definition to use for export
        """
        args = export_default_runsheet_t.Arguments(
            entities=entities,
            entity_type=entity_type,
            runsheet_key=runsheet_key,
        )
        api_request = APIRequest(
            method=export_default_runsheet_t.ENDPOINT_METHOD,
            endpoint=export_default_runsheet_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=export_default_runsheet_t.Data)

    def export_entities(
        self,
        *,
        config_key: identifier_t.IdentifierKey,
        type: exports_t.ExportType = exports_t.ExportType.EXCEL,
        client_timezone: exports_t.ListingExportUserTimezone | None = None,
        limit: int | None = None,
        attributes: list[export_entities_t.ListingAttribute] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> export_entities_t.Data:
        """Uses a structured loading configuration to export entities in the system. This endpoint is asynchronous, and returns the job ID that can be used to query the status of the export.

        :param config_key: The configuration reference for the listing config
        :param limit: The number of data points to return. If not filled in, all filtered entities will be included in the export.
        """
        args = export_entities_t.Arguments(
            config_key=config_key,
            client_timezone=client_timezone,
            limit=limit,
            type=type,
            attributes=attributes,
        )
        api_request = APIRequest(
            method=export_entities_t.ENDPOINT_METHOD,
            endpoint=export_entities_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=export_entities_t.Data)

    def fetch_listing(
        self,
        *,
        entity_type: entity_t.EntityType,
        columns: list[listing_t.ColumnIdentifier],
        filters: listing_t.FilterNode | None = None,
        limit: int | None = None,
        offset: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> fetch_listing_t.Data:
        """External API for fetching a listing based on some structured columns and filters

        :param entity_type: The entity type to fetch listing entries for
        :param columns: The columns to include in the results
        :param filters: Structured filters to apply to the listing, represented by a FilterNode object
        :param limit: The number of entries to return. If not provided, defaults to 100. Note a maximum of 100 entries can be returned.
        :param offset: The number of entries to skip for pagination
        """
        args = fetch_listing_t.Arguments(
            entity_type=entity_type,
            columns=columns,
            filters=filters,
            limit=limit,
            offset=offset,
        )
        api_request = APIRequest(
            method=fetch_listing_t.ENDPOINT_METHOD,
            endpoint=fetch_listing_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=fetch_listing_t.Data)

    def get_column_calculation_values(
        self,
        *,
        recipe_keys: list[identifier_t.IdentifierKey],
        calculation_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_column_calculation_values_t.Data:
        """Get the values for a column calculations for recipes

        :param recipe_keys: Required: The recipe keys to load values for
        :param calculation_key: Required: The calculation key to get the values for
        """
        args = get_column_calculation_values_t.Arguments(
            recipe_keys=recipe_keys,
            calculation_key=calculation_key,
        )
        api_request = APIRequest(
            method=get_column_calculation_values_t.ENDPOINT_METHOD,
            endpoint=get_column_calculation_values_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_column_calculation_values_t.Data)

    def get_current_user_info(
        self,
        *,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_current_user_info_t.Data:
        """Return information about the current user

        """
        args = get_current_user_info_t.Arguments()
        api_request = APIRequest(
            method=get_current_user_info_t.ENDPOINT_METHOD,
            endpoint=get_current_user_info_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_current_user_info_t.Data)

    def get_curve(
        self,
        *,
        recipe_output_id: base_t.ObjectId | None = None,
        recipe_input_id: base_t.ObjectId | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_curve_t.Data:
        """Returns an array of values for the specified curve id.

        :param recipe_output_id: The recipe output ID to fetch the curve for. This must be a curve recipe output. Recipe Outputs can be found from external_get_recipes_data
        :param recipe_input_id: The recipe input ID to fetch the curve for. This must be a curve recipe input. Recipe Inputs can be found from external_get_recipes_data
        """
        args = get_curve_t.Arguments(
            recipe_output_id=recipe_output_id,
            recipe_input_id=recipe_input_id,
        )
        api_request = APIRequest(
            method=get_curve_t.ENDPOINT_METHOD,
            endpoint=get_curve_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_curve_t.Data)

    def get_entities_data(
        self,
        *,
        entity_ids: list[base_t.ObjectId],
        entity_type: entity_t.EntityType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_entities_data_t.Data:
        """Gets the details for a passed entity

        :param entity_ids: Ids of the entity to retrieve
        :param entity_type: The type of the entities requested, e.g. lab_request or approval
        """
        args = get_entities_data_t.Arguments(
            entity_ids=entity_ids,
            entity_type=entity_type,
        )
        api_request = APIRequest(
            method=get_entities_data_t.ENDPOINT_METHOD,
            endpoint=get_entities_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_entities_data_t.Data)

    def get_input_data(
        self,
        *,
        material_family_id: base_t.ObjectId,
        input_ids: list[base_t.ObjectId] | None,
        is_parameter: bool | None,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_input_data_t.Data:
        """Gets the attribute, categorization and other metadata associated with a set of inputs. An input is either an ingredient or process parameter, with metadata and calculations assigned separately

        :param material_family_id: The material family ID to get the input values from.
        :param input_ids: The input IDs to get the data from. If this is not filled in, all inputs from a material family will be returned (in paginated form).
        :param offset: Used for pagination, where the number of results returned exceeds the limit. Results are always ordered by the input ID. [Pagination More Info](#pagination)
        :param is_parameter: Whether to get parameters or ingredients. By default both are returned. When set to true, only parameters are returned, and when set to false, only ingredients are returned
        :param limit: The maximum number of results to return. By default this is set to 1,000 and it cannot be set higher than 1,000. [Pagination More Info](#pagination)
        """
        args = get_input_data_t.Arguments(
            material_family_id=material_family_id,
            input_ids=input_ids,
            offset=offset,
            is_parameter=is_parameter,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_input_data_t.ENDPOINT_METHOD,
            endpoint=get_input_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_input_data_t.Data)

    def get_input_group_names(
        self,
        *,
        material_family_id: base_t.ObjectId,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_input_group_names_t.Data:
        """Gets the name of all input groups in a material family that either the user created, or are shared to all users.

        :param material_family_id: Required: The Material Family ID to get the input groups from.
        """
        args = get_input_group_names_t.Arguments(
            material_family_id=material_family_id,
        )
        api_request = APIRequest(
            method=get_input_group_names_t.ENDPOINT_METHOD,
            endpoint=get_input_group_names_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_input_group_names_t.Data)

    def get_input_names(
        self,
        *,
        material_family_id: base_t.ObjectId,
        is_parameter: bool | None,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_input_names_t.Data:
        """Gets the name of all inputs for a material family. An input is either an ingredient or process parameter, with metadata and calculations assigned separately

        :param material_family_id: The material family ID to get the input values from
        :param offset: Used for pagination, where the number of results returned exceeds the limit. Results are always ordered by the input ID. [Pagination More Info](#pagination)
        :param is_parameter: Whether to get parameters or ingredients. By default both are returned. When set to true, only parameters are returned, and when set to false, only ingredients are returned
        :param limit: The maximum number of results to return. By default this is set to 20,000 and it cannot be set higher than 20,000. [Pagination More Info](#pagination)
        """
        args = get_input_names_t.Arguments(
            material_family_id=material_family_id,
            offset=offset,
            is_parameter=is_parameter,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_input_names_t.ENDPOINT_METHOD,
            endpoint=get_input_names_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_input_names_t.Data)

    def get_inputs_data(
        self,
        *,
        input_ids: list[base_t.ObjectId],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_inputs_data_t.Data:
        """Gets the details for passed input ids

        :param input_ids: Ids of the inputs to retrieve
        """
        args = get_inputs_data_t.Arguments(
            input_ids=input_ids,
        )
        api_request = APIRequest(
            method=get_inputs_data_t.ENDPOINT_METHOD,
            endpoint=get_inputs_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_inputs_data_t.Data)

    def get_output_data(
        self,
        *,
        material_family_id: base_t.ObjectId,
        output_ids: list[base_t.ObjectId] | None = None,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_output_data_t.Data:
        """Gets the attribute, categorization and other metadata associated with a set of outputs

        :param material_family_id: The material family ID to get the output values from.
        :param output_ids: The output IDs to get the data from. If this is not filled in, all outputs from a material family will be returned (in paginated form).
        :param offset: Used for pagination, where the number of results returned exceeds the limit. Results are always ordered by the output ID. [Pagination More Info](#pagination)
        :param limit: The maximum number of results to return. By default this is set to 1,000 and it cannot be set higher than 1,000. [Pagination More Info](#pagination)
        """
        args = get_output_data_t.Arguments(
            material_family_id=material_family_id,
            output_ids=output_ids,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_output_data_t.ENDPOINT_METHOD,
            endpoint=get_output_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_output_data_t.Data)

    def get_output_names(
        self,
        *,
        material_family_id: base_t.ObjectId,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_output_names_t.Data:
        """Gets the name of all outputs for a material family. An output represents a measurement value of any time (numeric, text, curve, etc). This includes calculations based off of other outputs, such as a calculated change over time

        :param material_family_id: The material family ID to get the output values from
        :param offset: Used for pagination, where the number of results returned exceeds the limit. Results are always ordered by the output ID. [Pagination More Info](#pagination)
        :param limit: The maximum number of results to return. By default this is set to 20,000 and it cannot be set higher than 20,000. [Pagination More Info](#pagination)
        """
        args = get_output_names_t.Arguments(
            material_family_id=material_family_id,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_output_names_t.ENDPOINT_METHOD,
            endpoint=get_output_names_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_output_names_t.Data)

    def get_output_organization(
        self,
        *,
        request: get_output_organization_t.OutputOrganizationRequest,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_output_organization_t.Data:
        """Returns the output organization for the specified material family, project, or user

        """
        args = get_output_organization_t.Arguments(
            request=request,
        )
        api_request = APIRequest(
            method=get_output_organization_t.ENDPOINT_METHOD,
            endpoint=get_output_organization_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_output_organization_t.Data)

    def get_projects(
        self,
        *,
        all_material_families: bool,
        material_family_id: base_t.ObjectId | None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_projects_t.Data:
        """Gets either all projects created in the platform, or the projects associated with a material family ID. Projects are where experiments are placed in Uncountable, similar to folders in a directory structure

        :param all_material_families: Whether to get projects from all material families. Material families are high level groupings of data, usually separated by functional area
        :param material_family_id: The specific material family ID to get projects from. Only fill this in if all_material_families is set to false
        """
        args = get_projects_t.Arguments(
            all_material_families=all_material_families,
            material_family_id=material_family_id,
        )
        api_request = APIRequest(
            method=get_projects_t.ENDPOINT_METHOD,
            endpoint=get_projects_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_projects_t.Data)

    def get_projects_data(
        self,
        *,
        project_ids: list[base_t.ObjectId],
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_projects_data_t.Data:
        """Gets either all data associated with a set of projects created in the platform.  Because Uncountables recipe structure is complex, various data values are exploded out to increase efficiency in parsing, and this page is paginated to prevent too large of return values

        :param project_ids: The projects to get the data from
        :param offset: Used for pagination. All pagination is done in order of Project ID. [Pagination More Info](#pagination)
        :param limit: The number of data points to return. If not filled in, it will be set to 100, and cannot be set higher than 100. [Pagination More Info](#pagination)
        """
        args = get_projects_data_t.Arguments(
            project_ids=project_ids,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_projects_data_t.ENDPOINT_METHOD,
            endpoint=get_projects_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_projects_data_t.Data)

    def get_recipe_calculations(
        self,
        *,
        recipe_ids: list[base_t.ObjectId],
        calculation_ids: list[base_t.ObjectId] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipe_calculations_t.Data:
        """Gets the calculations for the passed recipes. When calculation_ids is omitted, only cached calculations stored in the database are returned, which may not include all calculations.

        :param recipe_ids: Ids of the Recipes to retrieve calculations for
        :param calculation_ids: Optional list of calculation IDs to compute and retrieve. When omitted, only cached calculations are returned (may not include all calculations).
        """
        args = get_recipe_calculations_t.Arguments(
            recipe_ids=recipe_ids,
            calculation_ids=calculation_ids,
        )
        api_request = APIRequest(
            method=get_recipe_calculations_t.ENDPOINT_METHOD,
            endpoint=get_recipe_calculations_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipe_calculations_t.Data)

    def get_recipe_links(
        self,
        *,
        recipe_ids: list[base_t.ObjectId],
        depth: int = 1,
        link_types: list[recipe_links_t.RecipeLinkType] | None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipe_links_t.Data:
        """Gets the links for the passed recipes

        :param recipe_ids: Ids of the Recipes to retrieve links for
        :param depth: How many layers deep to look for links
        :param link_types: Optional filter to only desired link types
        """
        args = get_recipe_links_t.Arguments(
            recipe_ids=recipe_ids,
            depth=depth,
            link_types=link_types,
        )
        api_request = APIRequest(
            method=get_recipe_links_t.ENDPOINT_METHOD,
            endpoint=get_recipe_links_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipe_links_t.Data)

    def get_recipe_metadata_data(
        self,
        *,
        material_family_id: base_t.ObjectId,
        recipe_metadata_ids: list[base_t.ObjectId] | None,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipe_metadata_data_t.Data:
        """Gets the recipe metadata. Recipe metadata is data associated with experiments that is not an input, output or calculation, such as a sample ID.

        :param material_family_id: The material family ID to get the recipe metadata values from.
        :param recipe_metadata_ids: The recipe metadata IDs to get the data from. If this is not filled in, all metadata from a material family will be returned (in paginated form).
        :param offset: Used for pagination, where the number of results returned exceeds the limit. Results are always ordered by the metadata ID. [Pagination More Info](#pagination)
        :param limit: The maximum number of results to return. By default this is set to 1,000 and it cannot be set higher than 1,000. [Pagination More Info](#pagination)
        """
        args = get_recipe_metadata_data_t.Arguments(
            material_family_id=material_family_id,
            recipe_metadata_ids=recipe_metadata_ids,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=get_recipe_metadata_data_t.ENDPOINT_METHOD,
            endpoint=get_recipe_metadata_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipe_metadata_data_t.Data)

    def get_recipe_names(
        self,
        *,
        project_id: base_t.ObjectId,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipe_names_t.Data:
        """Gets the name of all recipes (or experiments, used as synonyms by Uncountable) for a project. The call external_get_projects can be used to find projects

        :param project_id: Required: The project ID to get the recipes/experiments from.
        """
        args = get_recipe_names_t.Arguments(
            project_id=project_id,
        )
        api_request = APIRequest(
            method=get_recipe_names_t.ENDPOINT_METHOD,
            endpoint=get_recipe_names_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipe_names_t.Data)

    def get_recipe_output_metadata(
        self,
        *,
        recipe_output_ids: list[base_t.ObjectId],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipe_output_metadata_t.Data:
        """Gets the metadata values for the passed recipe outputs

        :param recipe_output_ids: Ids of the Recipe Outputs to retrieve metadata for
        """
        args = get_recipe_output_metadata_t.Arguments(
            recipe_output_ids=recipe_output_ids,
        )
        api_request = APIRequest(
            method=get_recipe_output_metadata_t.ENDPOINT_METHOD,
            endpoint=get_recipe_output_metadata_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipe_output_metadata_t.Data)

    def get_recipes_data(
        self,
        *,
        recipe_ids: list[base_t.ObjectId] | None = None,
        project_id: base_t.ObjectId | None = None,
        offset: int | None = None,
        limit: int | None = None,
        empty_output_behavior: get_recipes_data_t.RecipeOutputInclusion | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> get_recipes_data_t.Data:
        """Gets all data associated with a set of recipes. Because Uncountables recipe structure is complex, various data values are exploded out to increase efficiency in parsing, and this page is paginated to prevent too large of return values

        :param recipe_ids: The recipes to get the data from. Either these or project_id must be filled in
        :param project_id: The projects to get the data from. Either these or recipe_ids must be filled in
        :param offset: Used for pagination. All pagination is done in order of Recipe ID. [Pagination More Info](#pagination)
        :param limit: The number of data points to return. If not filled in, it will be set to 100, and cannot be set higher than 100. [Pagination More Info](#pagination)
        :param empty_output_behavior: Recipe output inclusion behavior for empty outputs. Empty recipe outputs are outputs added to the experiment that do not have a value associated with them.
        """
        args = get_recipes_data_t.Arguments(
            recipe_ids=recipe_ids,
            project_id=project_id,
            offset=offset,
            limit=limit,
            empty_output_behavior=empty_output_behavior,
        )
        api_request = APIRequest(
            method=get_recipes_data_t.ENDPOINT_METHOD,
            endpoint=get_recipes_data_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=get_recipes_data_t.Data)

    def grant_entity_permissions(
        self,
        *,
        entity_type: entity_t.LimitedEntityType,
        entity_key: identifier_t.IdentifierKey,
        permission_types: list[entity_t.GrantableEntityPermissionType],
        user_keys: list[identifier_t.IdentifierKey] | None = None,
        user_group_keys: list[identifier_t.IdentifierKey] | None = None,
        all_users: bool | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> grant_entity_permissions_t.Data:
        """Grant entity permissions to a list of users or user groups or to all users.

        """
        args = grant_entity_permissions_t.Arguments(
            entity_type=entity_type,
            entity_key=entity_key,
            permission_types=permission_types,
            user_keys=user_keys,
            user_group_keys=user_group_keys,
            all_users=all_users,
        )
        api_request = APIRequest(
            method=grant_entity_permissions_t.ENDPOINT_METHOD,
            endpoint=grant_entity_permissions_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=grant_entity_permissions_t.Data)

    def invoke_uploader(
        self,
        *,
        uploader_key: identifier_t.IdentifierKey,
        destination: generic_upload_t.UploadDestination,
        file_id: base_t.ObjectId | None = None,
        file_ids: list[base_t.ObjectId] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> invoke_uploader_t.Data:
        """Runs a file through an uploader. Non-SDK users: use file_upload/external_create_file_record to upload files. SDK users: use client.upload_files() helper method.

        :param file_id: DEPRECATED: use file_ids
        """
        args = invoke_uploader_t.Arguments(
            file_id=file_id,
            file_ids=file_ids,
            uploader_key=uploader_key,
            destination=destination,
        )
        api_request = APIRequest(
            method=invoke_uploader_t.ENDPOINT_METHOD,
            endpoint=invoke_uploader_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=invoke_uploader_t.Data)

    def list_aggregate(
        self,
        *,
        config_reference: str,
        attribute_values: list[list_aggregate_t.AttributeValue] | None = None,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> list_aggregate_t.Data:
        """Uses a structured loading configuration to list aggregated data from the platform

        :param config_reference: The configuration reference name for the listing config
        :param attribute_values: Attributes to pass to the configuration for parameterizing filters
        :param offset: Used for pagination. Pagination is done based on the sorting of the config. [Pagination More Info](#pagination)
        :param limit: The number of data points to return. If not filled in, it will be set to 100, and cannot be set higher than 100. [Pagination More Info](#pagination)
        """
        args = list_aggregate_t.Arguments(
            config_reference=config_reference,
            attribute_values=attribute_values,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=list_aggregate_t.ENDPOINT_METHOD,
            endpoint=list_aggregate_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=list_aggregate_t.Data)

    def list_entities(
        self,
        *,
        config_reference: str,
        entity_type: entity_t.EntityType | None = None,
        attributes: dict[OpaqueKey, base_t.JsonValue] | None = None,
        offset: int | None = None,
        limit: int | None = None,
        additional_filter_configs: list[list_entities_t.AdditionalFilterConfig] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> list_entities_t.Data:
        """Uses a structured loading configuration to list entities in the system

        :param entity_type: DEPRECATED: The type of the entities requested, e.g. lab_request, recipe
        :param config_reference: The configuration reference name for the listing config
        :param attributes: Attributes to pass to the configuration for parameterizing filters
        :param offset: Used for pagination. Pagination is done based on the sorting of the config. [Pagination More Info](#pagination)
        :param limit: The number of data points to return. If not filled in, it will be set to 100, and cannot be set higher than 100. [Pagination More Info](#pagination)
        :param additional_filter_configs: Advanced property: Additional filter configurations to apply to the listing. A maximum of 10 additional filter configs are supported.
        """
        args = list_entities_t.Arguments(
            entity_type=entity_type,
            config_reference=config_reference,
            attributes=attributes,
            offset=offset,
            limit=limit,
            additional_filter_configs=additional_filter_configs,
        )
        api_request = APIRequest(
            method=list_entities_t.ENDPOINT_METHOD,
            endpoint=list_entities_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=list_entities_t.Data)

    def list_id_source(
        self,
        *,
        spec: id_source_t.IdSourceSpec,
        search_label: str,
        offset: int | None = None,
        limit: int | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> list_id_source_t.Data:
        """Lists id and label pairs

        :param spec: The id source spec to use
        :param search_label: Text to search within the labels to search matches
        :param offset: Used for pagination. Pagination is done based on the sorting of the config. [Pagination More Info](#pagination)
        :param limit: The number of data points to return. If not filled in, it will be set to 100, and cannot be set higher than 100. [Pagination More Info](#pagination)
        """
        args = list_id_source_t.Arguments(
            spec=spec,
            search_label=search_label,
            offset=offset,
            limit=limit,
        )
        api_request = APIRequest(
            method=list_id_source_t.ENDPOINT_METHOD,
            endpoint=list_id_source_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=list_id_source_t.Data)

    def external_lock_entity(
        self,
        *,
        entity_key: identifier_t.IdentifierKey,
        entity_type: entity_t.EntityType,
        globally_removable: bool | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> lock_entity_t.Data:
        """Lock an entity

        :param entity_key: Identifier for the entity
        :param globally_removable: Should the lock be removable by any user or just admins
        """
        args = lock_entity_t.Arguments(
            entity_key=entity_key,
            entity_type=entity_type,
            globally_removable=globally_removable,
        )
        api_request = APIRequest(
            method=lock_entity_t.ENDPOINT_METHOD,
            endpoint=lock_entity_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=lock_entity_t.Data)

    def lock_recipes(
        self,
        *,
        type: lock_recipes_t.RecipeLockType = lock_recipes_t.RecipeLockType.ALL,
        recipes: list[identifier_t.IdentifierKey],
        globally_removable: bool,
        lock_samples: bool | None = None,
        comments: str | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> lock_recipes_t.Data:
        """Lock experiments. Experiments will require unlocking to be editable. Edits to the experiments are blocked while they are locked.

        :param type: The type of lock to set.
    All = both inputs and measurements are locked.
    Inputs Only = only inputs are locked from editing.

        :param recipes: The recipes to lock, a maximum of 100 can be sent
        :param globally_removable: If true any user can unlock the experiment. If false the locking user is the only user that can unlock.
        :param lock_samples: Should associated experiment test samples also be locked.
        :param comments: Optional comment describing the purpose of locking
        """
        args = lock_recipes_t.Arguments(
            type=type,
            recipes=recipes,
            globally_removable=globally_removable,
            lock_samples=lock_samples,
            comments=comments,
        )
        api_request = APIRequest(
            method=lock_recipes_t.ENDPOINT_METHOD,
            endpoint=lock_recipes_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=lock_recipes_t.Data)

    def lookup_entity(
        self,
        *,
        entity_type: entity_t.EntityType,
        query: lookup_entity_t.LookupEntityQuery,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> lookup_entity_t.Data:
        """Look up an entity based on an identifier or field values

        """
        args = lookup_entity_t.Arguments(
            entity_type=entity_type,
            query=query,
        )
        api_request = APIRequest(
            method=lookup_entity_t.ENDPOINT_METHOD,
            endpoint=lookup_entity_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=lookup_entity_t.Data)

    def match_id_source(
        self,
        *,
        spec: id_source_t.IdSourceSpec,
        names: list[str],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> match_id_source_t.Data:
        """Lists id and label pairs

        :param spec: The id source spec to use
        :param names: The names to match with the id source.  At most 10 are allowed at a time
        """
        args = match_id_source_t.Arguments(
            spec=spec,
            names=names,
        )
        api_request = APIRequest(
            method=match_id_source_t.ENDPOINT_METHOD,
            endpoint=match_id_source_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=match_id_source_t.Data)

    def push_notification(
        self,
        *,
        notification_targets: list[notifications_t.NotificationTarget],
        subject: str,
        message: str,
        display_notice: bool = False,
        entity: entity_t.EntityIdentifier | None = None,
        notice_configuration: notices_t.NotificationNoticeConfiguration | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> push_notification_t.Data:
        """Push a notification to a user or user group

        """
        args = push_notification_t.Arguments(
            notification_targets=notification_targets,
            subject=subject,
            message=message,
            entity=entity,
            display_notice=display_notice,
            notice_configuration=notice_configuration,
        )
        api_request = APIRequest(
            method=push_notification_t.ENDPOINT_METHOD,
            endpoint=push_notification_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=push_notification_t.Data)

    def register_sockets_token(
        self,
        *,
        socket_request: sockets_t.SocketTokenRequest,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> register_sockets_token_t.Data:
        """Request token for connecting to sockets server

        """
        args = register_sockets_token_t.Arguments(
            socket_request=socket_request,
        )
        api_request = APIRequest(
            method=register_sockets_token_t.ENDPOINT_METHOD,
            endpoint=register_sockets_token_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=register_sockets_token_t.Data)

    def remove_recipe_from_project(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        project_key: identifier_t.IdentifierKey,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> remove_recipe_from_project_t.Data:
        """Removes a recipe from a project

        :param recipe_key: The identifier key of the recipe to remove from the project
        :param project_key: The identifier key of the project to remove the recipe from
        """
        args = remove_recipe_from_project_t.Arguments(
            recipe_key=recipe_key,
            project_key=project_key,
        )
        api_request = APIRequest(
            method=remove_recipe_from_project_t.ENDPOINT_METHOD,
            endpoint=remove_recipe_from_project_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=remove_recipe_from_project_t.Data)

    def remove_recipe_link(
        self,
        *,
        recipe_from_key: identifier_t.IdentifierKey,
        recipe_to_key: identifier_t.IdentifierKey,
        link_type: typing.Literal[recipe_links_t.RecipeLinkType.CHILD] | typing.Literal[recipe_links_t.RecipeLinkType.CONTROL] | typing.Literal[recipe_links_t.RecipeLinkType.USER_LINK] | typing.Literal[recipe_links_t.RecipeLinkType.PREVIOUS_EXPERIMENT],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> remove_recipe_link_t.Data:
        """Remove a link between two recipes.  Skip if the link doesn't already exist

        :param recipe_from_key: Identifier for the recipe the link comes from
        :param recipe_to_key: Identifier for the recipe the link goes to
        :param link_type: The type of link being removed
        """
        args = remove_recipe_link_t.Arguments(
            recipe_from_key=recipe_from_key,
            recipe_to_key=recipe_to_key,
            link_type=link_type,
        )
        api_request = APIRequest(
            method=remove_recipe_link_t.ENDPOINT_METHOD,
            endpoint=remove_recipe_link_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=remove_recipe_link_t.Data)

    def resolve_entity_ids(
        self,
        *,
        entity_ids: list[str | base_t.ObjectId],
        entity_type: entity_t.EntityType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> resolve_entity_ids_t.Data:
        """Gets the names for passed in ids

        :param entity_ids: Ids of the entity to retrieve
        :param entity_type: The type of the entities requested
        """
        args = resolve_entity_ids_t.Arguments(
            entity_ids=entity_ids,
            entity_type=entity_type,
        )
        api_request = APIRequest(
            method=resolve_entity_ids_t.ENDPOINT_METHOD,
            endpoint=resolve_entity_ids_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=resolve_entity_ids_t.Data)

    def resolve_output_conditions(
        self,
        *,
        requested_conditions: list[resolve_output_conditions_t.ConditionRequest],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> resolve_output_conditions_t.Data:
        """For the provided set of condition parameter id and values, returns the existing or newly created output condition id for that value and id pair.

        """
        args = resolve_output_conditions_t.Arguments(
            requested_conditions=requested_conditions,
        )
        api_request = APIRequest(
            method=resolve_output_conditions_t.ENDPOINT_METHOD,
            endpoint=resolve_output_conditions_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=resolve_output_conditions_t.Data)

    def run_trigger(
        self,
        *,
        trigger_ref_name: str,
        entity: entity_t.Entity | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> run_trigger_t.Data:
        """Runs a trigger.  Requires admin access

        """
        args = run_trigger_t.Arguments(
            entity=entity,
            trigger_ref_name=trigger_ref_name,
        )
        api_request = APIRequest(
            method=run_trigger_t.ENDPOINT_METHOD,
            endpoint=run_trigger_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=run_trigger_t.Data)

    def set_barcode(
        self,
        *,
        entity_key: entity_t.EntityIdentifier,
        barcode_value: str,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_barcode_t.Data:
        """Sets the barcode for an entity

        """
        args = set_barcode_t.Arguments(
            entity_key=entity_key,
            barcode_value=barcode_value,
        )
        api_request = APIRequest(
            method=set_barcode_t.ENDPOINT_METHOD,
            endpoint=set_barcode_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_barcode_t.Data)

    def set_core_permissions(
        self,
        *,
        scope: set_core_permissions_t.PermissionsScope,
        permissions_types: list[permissions_t.CorePermissionType],
        update_type: post_base_t.UpdateType,
        user_group_ids: list[int] | None = None,
        user_ids: list[int] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_core_permissions_t.Data:
        """Sets recipe related permissions

        :param scope: Scope of permissions to change
        :param user_group_ids: User group ids to grant permission to
        :param user_ids: User ids to grant permission to
        :param update_type: The type of update to perform
        """
        args = set_core_permissions_t.Arguments(
            scope=scope,
            user_group_ids=user_group_ids,
            user_ids=user_ids,
            permissions_types=permissions_types,
            update_type=update_type,
        )
        api_request = APIRequest(
            method=set_core_permissions_t.ENDPOINT_METHOD,
            endpoint=set_core_permissions_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_core_permissions_t.Data)

    def set_entity_field_values(
        self,
        *,
        entity_identifier: entity_t.EntityIdentifier,
        field_values: list[field_values_t.FieldArgumentValue],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_entity_field_values_t.Data:
        """Sets field values for an entity

        :param entity_identifier: Entity to update
        :param field_values: Field values to set
        """
        args = set_entity_field_values_t.Arguments(
            entity_identifier=entity_identifier,
            field_values=field_values,
        )
        api_request = APIRequest(
            method=set_entity_field_values_t.ENDPOINT_METHOD,
            endpoint=set_entity_field_values_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_entity_field_values_t.Data)

    def set_input_attribute_values(
        self,
        *,
        attribute_values: list[set_input_attribute_values_t.InputAttributeValue],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_input_attribute_values_t.Data:
        """Sets attribute values for an input

        :param attribute_values: The attributes of the input to set
        """
        args = set_input_attribute_values_t.Arguments(
            attribute_values=attribute_values,
        )
        api_request = APIRequest(
            method=set_input_attribute_values_t.ENDPOINT_METHOD,
            endpoint=set_input_attribute_values_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_input_attribute_values_t.Data)

    def external_set_input_category(
        self,
        *,
        input_key: identifier_t.IdentifierKey,
        category_id: int | None,
        material_family_ids: list[int] | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_input_category_t.Data:
        """Sets subcategories for an input

        :param input_key: Identifier for the input
        :param category_id: The category identifier to set. Null unsets the current category.
        :param material_family_ids: The material families to perform the update in
        """
        args = set_input_category_t.Arguments(
            input_key=input_key,
            category_id=category_id,
            material_family_ids=material_family_ids,
        )
        api_request = APIRequest(
            method=set_input_category_t.ENDPOINT_METHOD,
            endpoint=set_input_category_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_input_category_t.Data)

    def external_set_input_subcategories(
        self,
        *,
        input_key: identifier_t.IdentifierKey,
        subcategory_ids: list[int],
        update_type: post_base_t.UpdateType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_input_subcategories_t.Data:
        """Sets subcategories for an input

        :param input_key: Identifier for the input
        :param subcategory_ids: The subcategory identifiers to set
        :param update_type: The type of update to perform
        """
        args = set_input_subcategories_t.Arguments(
            input_key=input_key,
            subcategory_ids=subcategory_ids,
            update_type=update_type,
        )
        api_request = APIRequest(
            method=set_input_subcategories_t.ENDPOINT_METHOD,
            endpoint=set_input_subcategories_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_input_subcategories_t.Data)

    def set_intermediate_type(
        self,
        *,
        input_key: identifier_t.IdentifierKey,
        intermediate_type: set_intermediate_type_t.IntermediateType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_intermediate_type_t.Data:
        """Sets the type of an intermediate ingredient.

        :param input_key: The identifier key of the intermediate ingredient
        :param intermediate_type: The new type of the intermediate ingredient
        """
        args = set_intermediate_type_t.Arguments(
            input_key=input_key,
            intermediate_type=intermediate_type,
        )
        api_request = APIRequest(
            method=set_intermediate_type_t.ENDPOINT_METHOD,
            endpoint=set_intermediate_type_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_intermediate_type_t.Data)

    def set_recipe_inputs(
        self,
        *,
        input_data: list[set_recipe_inputs_t.RecipeInputValue],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_inputs_t.Data:
        """Sets inputs values for an experiment. Values set can be numeric, text or categorical types in the Uncountable system

        :param input_data: The inputs to set. Must be at most 100 entries long
        """
        args = set_recipe_inputs_t.Arguments(
            input_data=input_data,
        )
        api_request = APIRequest(
            method=set_recipe_inputs_t.ENDPOINT_METHOD,
            endpoint=set_recipe_inputs_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_inputs_t.Data)

    def set_recipe_metadata(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        recipe_metadata: list[recipe_metadata_t.MetadataValue],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_metadata_t.Data:
        """Set metadata values on a recipe

        :param recipe_key: Identifier for the recipe
        :param recipe_metadata: Metadata values to populate the recipe with
        """
        args = set_recipe_metadata_t.Arguments(
            recipe_key=recipe_key,
            recipe_metadata=recipe_metadata,
        )
        api_request = APIRequest(
            method=set_recipe_metadata_t.ENDPOINT_METHOD,
            endpoint=set_recipe_metadata_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_metadata_t.Data)

    def set_recipe_output_annotations(
        self,
        *,
        updates: list[set_recipe_output_annotations_t.RecipeOutputUpdateAnnotations],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_output_annotations_t.Data:
        """Update annotations for an experiments outputs

        :param updates: The output edits to perform. Must be at most 100 entries long
        """
        args = set_recipe_output_annotations_t.Arguments(
            updates=updates,
        )
        api_request = APIRequest(
            method=set_recipe_output_annotations_t.ENDPOINT_METHOD,
            endpoint=set_recipe_output_annotations_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_output_annotations_t.Data)

    def set_recipe_output_file(
        self,
        *,
        output_file_data: set_recipe_output_file_t.RecipeOutputFileValue,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_output_file_t.Data:
        """Sets output file value for an experiment.  Include a single file as part of the FormData of the request with the filename as the key

        :param output_file_data: The output file to set
        """
        args = set_recipe_output_file_t.Arguments(
            output_file_data=output_file_data,
        )
        api_request = APIRequest(
            method=set_recipe_output_file_t.ENDPOINT_METHOD,
            endpoint=set_recipe_output_file_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_output_file_t.Data)

    def set_recipe_outputs(
        self,
        *,
        output_data: list[set_recipe_outputs_t.RecipeOutputValue],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_outputs_t.Data:
        """Sets output values for an experiment. Values set can be numeric, text or categorical types in the Uncountable system

        :param output_data: The outputs to set. Must be at most 100 entries long
        """
        args = set_recipe_outputs_t.Arguments(
            output_data=output_data,
        )
        api_request = APIRequest(
            method=set_recipe_outputs_t.ENDPOINT_METHOD,
            endpoint=set_recipe_outputs_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_outputs_t.Data)

    def set_recipe_tags(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        recipe_tag_update: set_recipe_tags_t.RecipeTagUpdate,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_tags_t.Data:
        """Modifies recipes tags for a recipe

        :param recipe_key: Identifier for the recipe
        :param recipe_tag_update: The update to perform on the recipe tags
        """
        args = set_recipe_tags_t.Arguments(
            recipe_key=recipe_key,
            recipe_tag_update=recipe_tag_update,
        )
        api_request = APIRequest(
            method=set_recipe_tags_t.ENDPOINT_METHOD,
            endpoint=set_recipe_tags_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_tags_t.Data)

    def set_recipe_total(
        self,
        *,
        recipe_key: identifier_t.IdentifierKey,
        value: set_recipe_total_t.ValueNumeric,
        recipe_workflow_step_identifier: recipe_workflow_steps_t.RecipeWorkflowStepIdentifier | None = None,
        calculation_key: identifier_t.IdentifierKey | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_recipe_total_t.Data:
        """Updates the Set Total value for a recipe or one of its workflow steps

        :param recipe_key: Identifier for the recipe
        :param recipe_workflow_step_identifier: Identifier for the recipe workflow step
        :param value: The quantity in mass, volume, or moles to set for the total
        :param calculation_key: The linked basis calculation to set
        """
        args = set_recipe_total_t.Arguments(
            recipe_key=recipe_key,
            recipe_workflow_step_identifier=recipe_workflow_step_identifier,
            value=value,
            calculation_key=calculation_key,
        )
        api_request = APIRequest(
            method=set_recipe_total_t.ENDPOINT_METHOD,
            endpoint=set_recipe_total_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_recipe_total_t.Data)

    def set_values(
        self,
        *,
        entity: entity_t.Entity,
        values: list[field_values_t.ArgumentValueRefName],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> set_values_t.Data:
        """Sets field values for an entity

        """
        args = set_values_t.Arguments(
            entity=entity,
            values=values,
        )
        api_request = APIRequest(
            method=set_values_t.ENDPOINT_METHOD,
            endpoint=set_values_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=set_values_t.Data)

    def transition_entity_phase(
        self,
        *,
        transition: transition_entity_phase_t.TransitionIdentifier,
        entity: entity_t.Entity | None = None,
        entity_identifier: entity_t.EntityIdentifier | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> transition_entity_phase_t.Data:
        """Transitions an entity from one phase to another

        :param entity: Entity to transition. If entity_identifier is provided, this should be omitted.
        :param entity_identifier: Identifier of the entity to transition. If entity is provided, this should be omitted.
        :param transition: Identifier of the transition to perform
        """
        args = transition_entity_phase_t.Arguments(
            entity=entity,
            entity_identifier=entity_identifier,
            transition=transition,
        )
        api_request = APIRequest(
            method=transition_entity_phase_t.ENDPOINT_METHOD,
            endpoint=transition_entity_phase_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=transition_entity_phase_t.Data)

    def unarchive_recipes(
        self,
        *,
        recipes: list[identifier_t.IdentifierKey],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> unarchive_recipes_t.Data:
        """Unarchive/restore the provided recipes

        :param recipes: Identifier for the recipe
        """
        args = unarchive_recipes_t.Arguments(
            recipes=recipes,
        )
        api_request = APIRequest(
            method=unarchive_recipes_t.ENDPOINT_METHOD,
            endpoint=unarchive_recipes_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=unarchive_recipes_t.Data)

    def external_unlock_entity(
        self,
        *,
        entity_key: identifier_t.IdentifierKey,
        entity_type: entity_t.EntityType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> unlock_entity_t.Data:
        """Unlock an entity

        :param entity_key: Identifier for the entity
        """
        args = unlock_entity_t.Arguments(
            entity_key=entity_key,
            entity_type=entity_type,
        )
        api_request = APIRequest(
            method=unlock_entity_t.ENDPOINT_METHOD,
            endpoint=unlock_entity_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=unlock_entity_t.Data)

    def unlock_recipes(
        self,
        *,
        type: unlock_recipes_t.RecipeUnlockType = unlock_recipes_t.RecipeUnlockType.STANDARD,
        recipes: list[identifier_t.IdentifierKey],
        unlock_samples: bool | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> unlock_recipes_t.Data:
        """Unlock experiments. Experiments will edtiable after unlocking if they are currently locked.

        :param type: The method to unlock recipes. Default is standard.
        :param recipes: The recipes to unlock, a maximum of 100 can be sent
        :param unlock_samples: Should associated experiment test samples also be unlocked.
        """
        args = unlock_recipes_t.Arguments(
            type=type,
            recipes=recipes,
            unlock_samples=unlock_samples,
        )
        api_request = APIRequest(
            method=unlock_recipes_t.ENDPOINT_METHOD,
            endpoint=unlock_recipes_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=unlock_recipes_t.Data)

    def update_entity_material_families(
        self,
        *,
        entity_key: identifier_t.IdentifierKey,
        entity_type: typing.Literal[entity_t.EntityType.RECIPE_METADATA] | typing.Literal[entity_t.EntityType.INGREDIENT] | typing.Literal[entity_t.EntityType.OUTPUT] | typing.Literal[entity_t.EntityType.CONDITION_PARAMETER] | typing.Literal[entity_t.EntityType.INGREDIENT_ATTRIBUTE] | typing.Literal[entity_t.EntityType.INGREDIENT_CATEGORY_ALL],
        material_family_ids: list[base_t.ObjectId],
        update_type: post_base_t.UpdateType,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> update_entity_material_families_t.Data:
        """Updates the material families that the entity is available in

        :param entity_key: The identifier for the entity to update across material families
        :param entity_type: The type of the entities requested
        :param material_family_ids: The material families to update
        :param update_type: The type of update to make
        """
        args = update_entity_material_families_t.Arguments(
            entity_key=entity_key,
            entity_type=entity_type,
            material_family_ids=material_family_ids,
            update_type=update_type,
        )
        api_request = APIRequest(
            method=update_entity_material_families_t.ENDPOINT_METHOD,
            endpoint=update_entity_material_families_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=update_entity_material_families_t.Data)

    def upsert_condition_match(
        self,
        *,
        explicit_name: bool = False,
        name: str | None = None,
        condition_parameters: list[upsert_condition_match_t.ConditionParameter] | None = None,
        output_conditions: list[identifier_t.IdentifierKey] | None = None,
        existing_condition_match: identifier_t.IdentifierKey | None = None,
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> upsert_condition_match_t.Data:
        """Creates or updates condition match

        """
        args = upsert_condition_match_t.Arguments(
            name=name,
            condition_parameters=condition_parameters,
            output_conditions=output_conditions,
            explicit_name=explicit_name,
            existing_condition_match=existing_condition_match,
        )
        api_request = APIRequest(
            method=upsert_condition_match_t.ENDPOINT_METHOD,
            endpoint=upsert_condition_match_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=upsert_condition_match_t.Data)

    def upsert_field_options(
        self,
        *,
        option_set_key: identifier_t.IdentifierKey,
        field_options: list[upsert_field_options_t.FieldOption],
        _request_options: client_config_t.RequestOptions | None = None,
    ) -> upsert_field_options_t.Data:
        """Creates or updates field options for an option set

        :param option_set_key: Identifier for the field option set
        :param field_options: Field options to upsert
        """
        args = upsert_field_options_t.Arguments(
            option_set_key=option_set_key,
            field_options=field_options,
        )
        api_request = APIRequest(
            method=upsert_field_options_t.ENDPOINT_METHOD,
            endpoint=upsert_field_options_t.ENDPOINT_PATH,
            args=args,
            request_options=_request_options,
        )
        return self.do_request(api_request=api_request, return_type=upsert_field_options_t.Data)
