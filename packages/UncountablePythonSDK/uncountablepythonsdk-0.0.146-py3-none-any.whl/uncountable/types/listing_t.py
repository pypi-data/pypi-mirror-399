# DO NOT MODIFY -- This file is generated by type_spec
# ruff: noqa: E402 Q003
# fmt: off
# isort: skip_file
from __future__ import annotations
import typing  # noqa: F401
import datetime  # noqa: F401
from decimal import Decimal  # noqa: F401
from enum import StrEnum
import dataclasses
from pkgs.serialization import serial_class
from pkgs.serialization import serial_union_annotation
from pkgs.serialization import serial_alias_annotation
from pkgs.serialization import serial_string_enum
from . import base_t
from . import entity_t

__all__: list[str] = [
    "AggregateLoadTypes",
    "ColumnIdentifier",
    "ColumnIdentifierEntityRefName",
    "ColumnIdentifierTransitive",
    "ColumnIdentifierTransitiveAggregate",
    "ColumnType",
    "DateGroupType",
    "FilterIdType",
    "FilterNode",
    "FilterNodeBase",
    "FilterNodeColumnAnd",
    "FilterNodeType",
    "FilterRelation",
    "FilterScalarType",
    "FilterSpec",
    "FilterSpecBase",
    "FilterSpecEquals",
    "FilterSpecExists",
    "FilterSpecGeq",
    "FilterSpecGreater",
    "FilterSpecIStrContains",
    "FilterSpecIStrStartsWith",
    "FilterSpecInclude",
    "FilterSpecLeq",
    "FilterSpecLess",
    "LoadAggregateCollect",
    "LoadAggregateCollectDistinct",
    "LoadAggregateCount",
    "LoadAggregateCountDistinct",
    "LoadAggregateFirst",
    "LoadAggregateGroupBy",
    "LoadAggregateGroupByDate",
    "LoadAggregateMax",
    "LoadAggregateMean",
    "LoadAggregateMin",
    "LoadAggregateStddev",
    "LoadAggregateSum",
    "LoadAggregateType",
    "LoadAggregateUniqueValue",
    "StringFilterValue",
]


# DO NOT MODIFY -- This file is generated by type_spec
class ColumnType(StrEnum):
    ENTITY_REF_NAME = "entity_ref_name"
    TRANSITIVE = "transitive"
    TRANSITIVE_AGGREGATE = "transitive_aggregate"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.ColumnIdentifierEntityRefName",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class ColumnIdentifierEntityRefName:
    type: typing.Literal[ColumnType.ENTITY_REF_NAME] = ColumnType.ENTITY_REF_NAME
    entity_type: entity_t.EntityType
    ref_name: str


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.ColumnIdentifierTransitive",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class ColumnIdentifierTransitive:
    type: typing.Literal[ColumnType.TRANSITIVE] = ColumnType.TRANSITIVE
    entity_type: entity_t.EntityType
    via: ColumnIdentifier
    target: ColumnIdentifier


# DO NOT MODIFY -- This file is generated by type_spec
@serial_string_enum(
    labels={
        "group_by": "Group By",
        "group_by_date": "Group By Date",
        "collect": "Collect",
        "collect_distinct": "Distinct",
        "count": "Count",
        "count_distinct": "Count Distinct",
        "first": "First",
        "unique_value": "Unique Value",
        "min": "Minimum",
        "max": "Maximum",
        "mean": "Mean",
        "stddev": "Standard Deviation",
        "sum": "Sum",
    },
)
class LoadAggregateType(StrEnum):
    GROUP_BY = "group_by"
    GROUP_BY_DATE = "group_by_date"
    COLLECT = "collect"
    COLLECT_DISTINCT = "collect_distinct"
    COUNT = "count"
    COUNT_DISTINCT = "count_distinct"
    FIRST = "first"
    UNIQUE_VALUE = "unique_value"
    MIN = "min"
    MAX = "max"
    MEAN = "mean"
    STDDEV = "stddev"
    SUM = "sum"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateGroupBy",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateGroupBy:
    type: typing.Literal[LoadAggregateType.GROUP_BY] = LoadAggregateType.GROUP_BY


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateCollect",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateCollect:
    type: typing.Literal[LoadAggregateType.COLLECT] = LoadAggregateType.COLLECT


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateCollectDistinct",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateCollectDistinct:
    type: typing.Literal[LoadAggregateType.COLLECT_DISTINCT] = LoadAggregateType.COLLECT_DISTINCT


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateCount",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateCount:
    type: typing.Literal[LoadAggregateType.COUNT] = LoadAggregateType.COUNT


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateCountDistinct",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateCountDistinct:
    type: typing.Literal[LoadAggregateType.COUNT_DISTINCT] = LoadAggregateType.COUNT_DISTINCT


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateFirst",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateFirst:
    type: typing.Literal[LoadAggregateType.FIRST] = LoadAggregateType.FIRST


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateUniqueValue",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateUniqueValue:
    type: typing.Literal[LoadAggregateType.UNIQUE_VALUE] = LoadAggregateType.UNIQUE_VALUE


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateMin",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateMin:
    type: typing.Literal[LoadAggregateType.MIN] = LoadAggregateType.MIN


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateMax",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateMax:
    type: typing.Literal[LoadAggregateType.MAX] = LoadAggregateType.MAX


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateMean",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateMean:
    type: typing.Literal[LoadAggregateType.MEAN] = LoadAggregateType.MEAN


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateStddev",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateStddev:
    type: typing.Literal[LoadAggregateType.STDDEV] = LoadAggregateType.STDDEV


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateSum",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateSum:
    type: typing.Literal[LoadAggregateType.SUM] = LoadAggregateType.SUM


# DO NOT MODIFY -- This file is generated by type_spec
class DateGroupType(StrEnum):
    DAY = "day"
    WEEK = "week"
    MONTH = "month"
    QUARTER = "quarter"
    YEAR = "year"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.LoadAggregateGroupByDate",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class LoadAggregateGroupByDate:
    type: typing.Literal[LoadAggregateType.GROUP_BY_DATE] = LoadAggregateType.GROUP_BY_DATE
    date_group: DateGroupType
    user_timezone: str | None = None


# DO NOT MODIFY -- This file is generated by type_spec
AggregateLoadTypes = typing.Annotated[
    LoadAggregateGroupByDate | LoadAggregateGroupBy | LoadAggregateCollect | LoadAggregateCollectDistinct | LoadAggregateCount | LoadAggregateCountDistinct | LoadAggregateFirst | LoadAggregateUniqueValue | LoadAggregateMin | LoadAggregateMax | LoadAggregateMean | LoadAggregateStddev | LoadAggregateSum,
    serial_union_annotation(
    named_type_path="sdk.listing.AggregateLoadTypes",
        discriminator="type",
        discriminator_map={
            "group_by_date": LoadAggregateGroupByDate,
            "group_by": LoadAggregateGroupBy,
            "collect": LoadAggregateCollect,
            "collect_distinct": LoadAggregateCollectDistinct,
            "count": LoadAggregateCount,
            "count_distinct": LoadAggregateCountDistinct,
            "first": LoadAggregateFirst,
            "unique_value": LoadAggregateUniqueValue,
            "min": LoadAggregateMin,
            "max": LoadAggregateMax,
            "mean": LoadAggregateMean,
            "stddev": LoadAggregateStddev,
            "sum": LoadAggregateSum,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.ColumnIdentifierTransitiveAggregate",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class ColumnIdentifierTransitiveAggregate:
    type: typing.Literal[ColumnType.TRANSITIVE_AGGREGATE] = ColumnType.TRANSITIVE_AGGREGATE
    entity_type: entity_t.EntityType
    via: ColumnIdentifier
    target: ColumnIdentifier
    aggregate: AggregateLoadTypes
    filters: FilterNode | None = None


# DO NOT MODIFY -- This file is generated by type_spec
ColumnIdentifier = typing.Annotated[
    ColumnIdentifierEntityRefName | ColumnIdentifierTransitive | ColumnIdentifierTransitiveAggregate,
    serial_union_annotation(
    named_type_path="sdk.listing.ColumnIdentifier",
        discriminator="type",
        discriminator_map={
            "entity_ref_name": ColumnIdentifierEntityRefName,
            "transitive": ColumnIdentifierTransitive,
            "transitive_aggregate": ColumnIdentifierTransitiveAggregate,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
class FilterRelation(StrEnum):
    EQUALS = "equals"
    GREATER = "greater"
    GEQ = "geq"
    LESS = "less"
    LEQ = "leq"
    ISTR_CONTAINS = "istr_contains"
    ISTR_STARTS_WITH = "istr_starts_with"
    INCLUDE = "include"
    EXISTS = "exists"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecBase",
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecBase:
    relation: FilterRelation
    column: ColumnIdentifier


# DO NOT MODIFY -- This file is generated by type_spec
FilterScalarType = typing.Annotated[
    str | int | Decimal,
    serial_alias_annotation(
    named_type_path="sdk.listing.FilterScalarType",
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
FilterIdType = typing.Annotated[
    base_t.ObjectId | str,
    serial_alias_annotation(
    named_type_path="sdk.listing.FilterIdType",
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
StringFilterValue = typing.Annotated[
    typing.Union[str],
    serial_alias_annotation(
    named_type_path="sdk.listing.StringFilterValue",
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecEquals",
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecEquals(FilterSpecBase):
    relation: typing.Literal[FilterRelation.EQUALS] = FilterRelation.EQUALS
    value: FilterScalarType


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecInclude",
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecInclude(FilterSpecBase):
    relation: typing.Literal[FilterRelation.INCLUDE] = FilterRelation.INCLUDE
    value: FilterIdType | tuple[FilterIdType, ...]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecIStrContains",
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecIStrContains(FilterSpecBase):
    relation: typing.Literal[FilterRelation.ISTR_CONTAINS] = FilterRelation.ISTR_CONTAINS
    value: str


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecIStrStartsWith",
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecIStrStartsWith(FilterSpecBase):
    relation: typing.Literal[FilterRelation.ISTR_STARTS_WITH] = FilterRelation.ISTR_STARTS_WITH
    value: str


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecExists",
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecExists(FilterSpecBase):
    relation: typing.Literal[FilterRelation.EXISTS] = FilterRelation.EXISTS


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecGreater",
    to_string_values={"value"},
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecGreater(FilterSpecBase):
    relation: typing.Literal[FilterRelation.GREATER] = FilterRelation.GREATER
    value: Decimal


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecLess",
    to_string_values={"value"},
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecLess(FilterSpecBase):
    relation: typing.Literal[FilterRelation.LESS] = FilterRelation.LESS
    value: Decimal


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecGeq",
    to_string_values={"value"},
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecGeq(FilterSpecBase):
    relation: typing.Literal[FilterRelation.GEQ] = FilterRelation.GEQ
    value: Decimal


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterSpecLeq",
    to_string_values={"value"},
    parse_require={"relation"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterSpecLeq(FilterSpecBase):
    relation: typing.Literal[FilterRelation.LEQ] = FilterRelation.LEQ
    value: Decimal


# DO NOT MODIFY -- This file is generated by type_spec
FilterSpec = typing.Annotated[
    FilterSpecEquals | FilterSpecGreater | FilterSpecGeq | FilterSpecLeq | FilterSpecIStrContains | FilterSpecIStrStartsWith | FilterSpecInclude | FilterSpecExists | FilterSpecLess,
    serial_union_annotation(
    named_type_path="sdk.listing.FilterSpec",
        discriminator="relation",
        discriminator_map={
            "equals": FilterSpecEquals,
            "greater": FilterSpecGreater,
            "geq": FilterSpecGeq,
            "leq": FilterSpecLeq,
            "istr_contains": FilterSpecIStrContains,
            "istr_starts_with": FilterSpecIStrStartsWith,
            "include": FilterSpecInclude,
            "exists": FilterSpecExists,
            "less": FilterSpecLess,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
class FilterNodeType(StrEnum):
    COLUMN_AND = "column_and"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterNodeBase",
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class FilterNodeBase:
    type: FilterNodeType


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.listing.FilterNodeColumnAnd",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True, frozen=True, eq=True)  # type: ignore[literal-required]
class FilterNodeColumnAnd:
    type: typing.Literal[FilterNodeType.COLUMN_AND] = FilterNodeType.COLUMN_AND
    filters: tuple[FilterSpec, ...]


# DO NOT MODIFY -- This file is generated by type_spec
FilterNode = typing.Annotated[
    typing.Union[FilterNodeColumnAnd],
    serial_union_annotation(
    named_type_path="sdk.listing.FilterNode",
        discriminator="type",
        discriminator_map={
            "column_and": FilterNodeColumnAnd,
        },
    ),
]
# DO NOT MODIFY -- This file is generated by type_spec
