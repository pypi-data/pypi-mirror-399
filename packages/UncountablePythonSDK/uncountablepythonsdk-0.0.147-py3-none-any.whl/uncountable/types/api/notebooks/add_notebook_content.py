# DO NOT MODIFY -- This file is generated by type_spec
# ruff: noqa: E402 Q003
# fmt: off
# isort: skip_file
from __future__ import annotations
import typing  # noqa: F401
import datetime  # noqa: F401
from decimal import Decimal  # noqa: F401
from enum import StrEnum
import dataclasses
from pkgs.serialization import serial_class
from pkgs.serialization import serial_union_annotation
from pkgs.serialization import serial_string_enum
from ... import base_t
from ... import identifier_t

__all__: list[str] = [
    "Arguments",
    "Data",
    "ENDPOINT_METHOD",
    "ENDPOINT_PATH",
    "InputContent",
    "InputContentTable",
    "InputContentTextMarkdown",
    "InputContentType",
    "Location",
    "LocationAppendToFirstPage",
    "LocationType",
    "TableCell",
    "TableCellContent",
    "TableCellContentText",
    "TableCellContentType",
]

ENDPOINT_METHOD = "POST"
ENDPOINT_PATH = "api/external/notebooks/add_notebook_content"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_string_enum(
    labels={
        "append_to_first_page": "Append To First Page",
    },
)
class LocationType(StrEnum):
    APPEND_TO_FIRST_PAGE = "append_to_first_page"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.LocationAppendToFirstPage",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class LocationAppendToFirstPage:
    type: typing.Literal[LocationType.APPEND_TO_FIRST_PAGE] = LocationType.APPEND_TO_FIRST_PAGE


# DO NOT MODIFY -- This file is generated by type_spec
Location = typing.Annotated[
    typing.Union[LocationAppendToFirstPage],
    serial_union_annotation(
    named_type_path="sdk.api.notebooks.add_notebook_content.Location",
        discriminator="type",
        discriminator_map={
            "append_to_first_page": LocationAppendToFirstPage,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_string_enum(
    labels={
        "text_markdown": "Text Markdown",
        "table": "Table",
    },
)
class InputContentType(StrEnum):
    TEXT_MARKDOWN = "text_markdown"
    TABLE = "table"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_string_enum(
    labels={
        "text": "Text",
    },
)
class TableCellContentType(StrEnum):
    TEXT = "text"


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.TableCellContentText",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class TableCellContentText:
    type: typing.Literal[TableCellContentType.TEXT] = TableCellContentType.TEXT
    text: str


# DO NOT MODIFY -- This file is generated by type_spec
TableCellContent = typing.Annotated[
    typing.Union[TableCellContentText],
    serial_union_annotation(
    named_type_path="sdk.api.notebooks.add_notebook_content.TableCellContent",
        discriminator="type",
        discriminator_map={
            "text": TableCellContentText,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.TableCell",
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class TableCell:
    content: TableCellContent


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.InputContentTable",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class InputContentTable:
    type: typing.Literal[InputContentType.TABLE] = InputContentType.TABLE
    rows: list[list[TableCell]]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.InputContentTextMarkdown",
    parse_require={"type"},
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class InputContentTextMarkdown:
    type: typing.Literal[InputContentType.TEXT_MARKDOWN] = InputContentType.TEXT_MARKDOWN
    text_markdown: str


# DO NOT MODIFY -- This file is generated by type_spec
InputContent = typing.Annotated[
    InputContentTextMarkdown | InputContentTable,
    serial_union_annotation(
    named_type_path="sdk.api.notebooks.add_notebook_content.InputContent",
        discriminator="type",
        discriminator_map={
            "text_markdown": InputContentTextMarkdown,
            "table": InputContentTable,
        },
    ),
]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.Arguments",
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class Arguments:
    notebook_key: identifier_t.IdentifierKey
    location: Location
    contents: list[InputContent]


# DO NOT MODIFY -- This file is generated by type_spec
@serial_class(
    named_type_path="sdk.api.notebooks.add_notebook_content.Data",
)
@dataclasses.dataclass(slots=base_t.ENABLE_SLOTS, kw_only=True)  # type: ignore[literal-required]
class Data:
    pass
# DO NOT MODIFY -- This file is generated by type_spec
